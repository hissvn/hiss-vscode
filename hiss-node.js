// Generated by Haxe 4.2.0-rc.1+5fdb1661b
(function ($hx_exports, $global) { "use strict";
$hx_exports["hiss"] = $hx_exports["hiss"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = "EReg";
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedLeft: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return HxOverrides.substr(this.r.s,0,this.r.m.index);
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		return s.replace(this.r,"#__delim__#").split("#__delim__#");
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
IntIterator.__name__ = "IntIterator";
IntIterator.prototype = {
	min: null
	,max: null
	,hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
	,__class__: IntIterator
};
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) a.push(i.next());
	return a;
};
Lambda.list = function(it) {
	var l = new haxe_ds_List();
	var i = $getIterator(it);
	while(i.hasNext()) l.add(i.next());
	return l;
};
Lambda.map = function(it,f) {
	var l = new haxe_ds_List();
	var x = $getIterator(it);
	while(x.hasNext()) l.add(f(x.next()));
	return l;
};
Lambda.mapi = function(it,f) {
	var l = new haxe_ds_List();
	var i = 0;
	var x = $getIterator(it);
	while(x.hasNext()) l.add(f(i++,x.next()));
	return l;
};
Lambda.flatten = function(it) {
	var l = new haxe_ds_List();
	var e = $getIterator(it);
	while(e.hasNext()) {
		var x = $getIterator(e.next());
		while(x.hasNext()) l.add(x.next());
	}
	return l;
};
Lambda.flatMap = function(it,f) {
	return Lambda.flatten(Lambda.map(it,f));
};
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) if(x.next() == elt) {
		return true;
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) if(f(x.next())) {
		return true;
	}
	return false;
};
Lambda.foreach = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) if(!f(x.next())) {
		return false;
	}
	return true;
};
Lambda.iter = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) f(x.next());
};
Lambda.filter = function(it,f) {
	var l = new haxe_ds_List();
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			l.add(x1);
		}
	}
	return l;
};
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) first = f(x.next(),first);
	return first;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			_.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) if(pred(x.next())) {
			++n;
		}
	}
	return n;
};
Lambda.empty = function(it) {
	return !$getIterator(it).hasNext();
};
Lambda.indexOf = function(it,v) {
	var i = 0;
	var v2 = $getIterator(it);
	while(v2.hasNext()) {
		if(v == v2.next()) {
			return i;
		}
		++i;
	}
	return -1;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Lambda.concat = function(a,b) {
	var l = new haxe_ds_List();
	var x = $getIterator(a);
	while(x.hasNext()) l.add(x.next());
	var x = $getIterator(b);
	while(x.hasNext()) l.add(x.next());
	return l;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return null;
	}
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.setProperty = function(o,field,value) {
	var tmp;
	var tmp1;
	if(o.__properties__) {
		tmp = o.__properties__["set_" + field];
		tmp1 = tmp;
	} else {
		tmp1 = false;
	}
	if(tmp1) {
		o[tmp](value);
	} else {
		o[field] = value;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.copy = function(o) {
	if(o == null) {
		return null;
	}
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	b: null
	,__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b = "" + (s == null ? "null" : "" + s);
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	while(true) {
		s = "0123456789ABCDEF".charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var Sys = function() { };
Sys.__name__ = "Sys";
Sys.getEnv = function(s) {
	return process.env[s];
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
Sys.getChar = function(echo) {
	throw haxe_Exception.thrown("Sys.getChar is currently not implemented on node.js");
};
Sys.sleep = function(seconds) {
	var end = Date.now() + seconds * 1000;
	while(Date.now() <= end) {
	}
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = "haxe.io.Output";
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = "_Sys.FileOutput";
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	fd: null
	,writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = "haxe.io.Input";
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readLine: function() {
		var buf = new haxe_io_BytesBuffer();
		var last;
		var s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(_g1);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	,__class__: haxe_io_Input
};
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = "_Sys.FileInput";
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fd: null
	,readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileInput
});
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
Type.__name__ = "Type";
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return $hxEnums[o.__enum__];
};
Type.createInstance = function(cl,args) {
	return new (Function.prototype.bind.apply(cl,[null].concat(args)));
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.getClassFields = function(c) {
	var a = Reflect.fields(c);
	HxOverrides.remove(a,"__name__");
	HxOverrides.remove(a,"__interfaces__");
	HxOverrides.remove(a,"__properties__");
	HxOverrides.remove(a,"__super__");
	HxOverrides.remove(a,"__meta__");
	HxOverrides.remove(a,"prototype");
	return a;
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.exceptionStack = function() {
	return haxe_CallStack.subtract(haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack()),haxe_CallStack.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g++];
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) if(haxe_CallStack.equalItems(this1[i],stack[_g++])) {
			if(startIndex < 0) {
				startIndex = i;
			}
			++i;
			if(i >= this1.length) {
				break;
			}
		} else {
			startIndex = -1;
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				return item1.m == item2.m;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				if(item1.file == item2.file && item1.line == item2.line && item1.column == item2.column) {
					return haxe_CallStack.equalItems(item1.s,item2.s);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				if(item1.classname == item2.classname) {
					return item1.method == item2.method;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				return item1.v == item2.v;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var _g = s.m;
		b.b = (b.b += "module ") + (_g == null ? "null" : "" + _g);
		break;
	case 2:
		var _g = s.column;
		var _g1 = s.line;
		var _g2 = s.file;
		var _g3 = s.s;
		if(_g3 != null) {
			haxe_CallStack.itemToString(b,_g3);
			b.b += " (";
		}
		b.b = (b.b += _g2 == null ? "null" : "" + _g2) + " line ";
		b.b += _g1 == null ? "null" : "" + _g1;
		if(_g != null) {
			b.b = (b.b += " column ") + (_g == null ? "null" : "" + _g);
		}
		if(_g3 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var _g = s.method;
		var _g1 = s.classname;
		b.b = (b.b += Std.string(_g1 == null ? "<unknown>" : _g1)) + ".";
		b.b += _g == null ? "null" : "" + _g;
		break;
	case 4:
		var _g = s.v;
		b.b = (b.b += "local function #") + (_g == null ? "null" : "" + _g);
		break;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	get: null
	,keys: null
	,__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
	,__properties__: {get_native:"get_native",get_message:"get_message"}
});
var haxe_Int32 = {};
haxe_Int32.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
var haxe_Int64 = {};
haxe_Int64.divMod = function(dividend,divisor) {
	if(divisor.high == 0) {
		switch(divisor.low) {
		case 0:
			throw haxe_Exception.thrown("divide by zero");
		case 1:
			return { quotient : new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low), modulus : new haxe__$Int64__$_$_$Int64(0,0)};
		}
	}
	var divSign = dividend.high < 0 != divisor.high < 0;
	var modulus;
	if(dividend.high < 0) {
		var high = ~dividend.high;
		var low = ~dividend.low + 1 | 0;
		if(low == 0) {
			++high;
			high = high | 0;
		}
		modulus = new haxe__$Int64__$_$_$Int64(high,low);
	} else {
		modulus = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
	}
	if(divisor.high < 0) {
		var high = ~divisor.high;
		var low = ~divisor.low + 1 | 0;
		if(low == 0) {
			++high;
			high = high | 0;
		}
		divisor = new haxe__$Int64__$_$_$Int64(high,low);
	}
	var quotient = new haxe__$Int64__$_$_$Int64(0,0);
	var mask = new haxe__$Int64__$_$_$Int64(0,1);
	while(!(divisor.high < 0)) {
		var v = haxe_Int32.ucompare(divisor.high,modulus.high);
		var cmp = v != 0 ? v : haxe_Int32.ucompare(divisor.low,modulus.low);
		divisor = new haxe__$Int64__$_$_$Int64(divisor.high << 1 | divisor.low >>> 31,divisor.low << 1);
		mask = new haxe__$Int64__$_$_$Int64(mask.high << 1 | mask.low >>> 31,mask.low << 1);
		if(cmp >= 0) {
			break;
		}
	}
	while(mask.high != 0 || mask.low != 0) {
		var v = haxe_Int32.ucompare(modulus.high,divisor.high);
		if((v != 0 ? v : haxe_Int32.ucompare(modulus.low,divisor.low)) >= 0) {
			quotient = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
			var high = modulus.high - divisor.high | 0;
			if(haxe_Int32.ucompare(modulus.low,divisor.low) < 0) {
				--high;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,modulus.low - divisor.low | 0);
		}
		mask = new haxe__$Int64__$_$_$Int64(mask.high >>> 1,mask.high << 31 | mask.low >>> 1);
		divisor = new haxe__$Int64__$_$_$Int64(divisor.high >>> 1,divisor.high << 31 | divisor.low >>> 1);
	}
	if(divSign) {
		var high = ~quotient.high;
		var low = ~quotient.low + 1 | 0;
		if(low == 0) {
			++high;
			high = high | 0;
		}
		quotient = new haxe__$Int64__$_$_$Int64(high,low);
	}
	if(dividend.high < 0) {
		var high = ~modulus.high;
		var low = ~modulus.low + 1 | 0;
		if(low == 0) {
			++high;
			high = high | 0;
		}
		modulus = new haxe__$Int64__$_$_$Int64(high,low);
	}
	return { quotient : quotient, modulus : modulus};
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
haxe__$Int64__$_$_$Int64.prototype = {
	high: null
	,low: null
	,__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Int64Helper = function() { };
haxe_Int64Helper.__name__ = "haxe.Int64Helper";
haxe_Int64Helper.fromFloat = function(f) {
	if(isNaN(f) || !isFinite(f)) {
		throw haxe_Exception.thrown("Number is NaN or Infinite");
	}
	var noFractions = f - f % 1;
	if(noFractions > 9007199254740991) {
		throw haxe_Exception.thrown("Conversion overflow");
	}
	if(noFractions < -9007199254740991) {
		throw haxe_Exception.thrown("Conversion underflow");
	}
	var result = new haxe__$Int64__$_$_$Int64(0,0);
	var neg = noFractions < 0;
	var rest = neg ? -noFractions : noFractions;
	var i = 0;
	while(rest >= 1) {
		var curr = rest % 2;
		rest /= 2;
		if(curr >= 1) {
			var a_high = 0;
			var a_low = 1;
			var b = i;
			b &= 63;
			var b1 = b == 0 ? new haxe__$Int64__$_$_$Int64(a_high,a_low) : b < 32 ? new haxe__$Int64__$_$_$Int64(a_high << b | a_low >>> 32 - b,a_low << b) : new haxe__$Int64__$_$_$Int64(a_low << b - 32,0);
			var high = result.high + b1.high | 0;
			var low = result.low + b1.low | 0;
			if(haxe_Int32.ucompare(low,result.low) < 0) {
				++high;
				high = high | 0;
			}
			result = new haxe__$Int64__$_$_$Int64(high,low);
		}
		++i;
	}
	if(neg) {
		var high = ~result.high;
		var low = ~result.low + 1 | 0;
		if(low == 0) {
			++high;
			high = high | 0;
		}
		result = new haxe__$Int64__$_$_$Int64(high,low);
	}
	return result;
};
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) str += ", " + Std.string(_g1[_g++]);
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.lastError = null;
haxe_NativeStackTrace.wrapCallSite = null;
haxe_NativeStackTrace.saveStack = function(e) {
	haxe_NativeStackTrace.lastError = e;
};
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.exceptionStack = function() {
	return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	Error.prepareStackTrace = oldValue;
	return e.stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				method = haxe_StackItem.Method(fullName.substring(0,idx),fullName.substring(idx + 1));
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	while(true) if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			skip = --skip;
			pos += 1;
			continue;
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.measure = function(f,pos) {
	var hrtime = process.hrtime();
	var t0 = hrtime[0] + hrtime[1] / 1e9;
	var r = f();
	var tmp = haxe_Log.trace;
	var hrtime = process.hrtime();
	tmp(hrtime[0] + hrtime[1] / 1e9 - t0 + "s",pos);
	return r;
};
haxe_Timer.prototype = {
	id: null
	,stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
haxe_crypto_Adler32.__name__ = "haxe.crypto.Adler32";
haxe_crypto_Adler32.make = function(b) {
	var a = new haxe_crypto_Adler32();
	a.update(b,0,b.length);
	return a.get();
};
haxe_crypto_Adler32.prototype = {
	a1: null
	,a2: null
	,get: function() {
		return this.a2 << 16 | this.a1;
	}
	,update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			a1 = (a1 + b.b[_g++]) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var code1 = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,toHex: function() {
		var s_b = "";
		var chars = [];
		var str = "0123456789abcdef";
		var _g = 0;
		var _g1 = str.length;
		while(_g < _g1) chars.push(HxOverrides.cca(str,_g++));
		var _g = 0;
		var _g1 = this.length;
		while(_g < _g1) {
			var c = this.b[_g++];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:"haxe.io.Encoding",__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
haxe_crypto_BaseCode.prototype = {
	base: null
	,nbits: null
	,tbl: null
	,encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	,initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) tbl[_g++] = -1;
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_crypto_Crc32 = function() { };
haxe_crypto_Crc32.__name__ = "haxe.crypto.Crc32";
haxe_crypto_Crc32.make = function(data) {
	var c_crc = -1;
	var len = data.length;
	var b = data.b.bufferValue;
	var _g = 0;
	while(_g < len) {
		var tmp = (c_crc ^ b.bytes[_g++]) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		c_crc = c_crc >>> 8 ^ tmp;
	}
	return c_crc ^ -1;
};
var haxe_crypto_Md5 = function() {
};
haxe_crypto_Md5.__name__ = "haxe.crypto.Md5";
haxe_crypto_Md5.make = function(b) {
	var h = new haxe_crypto_Md5().doEncode(haxe_crypto_Md5.bytes2blks(b));
	var out = new haxe_io_Bytes(new ArrayBuffer(16));
	out.b[0] = h[0] & 255;
	out.b[1] = h[0] >> 8 & 255;
	out.b[2] = h[0] >> 16 & 255;
	out.b[3] = h[0] >>> 24;
	out.b[4] = h[1] & 255;
	out.b[5] = h[1] >> 8 & 255;
	out.b[6] = h[1] >> 16 & 255;
	out.b[7] = h[1] >>> 24;
	out.b[8] = h[2] & 255;
	out.b[9] = h[2] >> 8 & 255;
	out.b[10] = h[2] >> 16 & 255;
	out.b[11] = h[2] >>> 24;
	out.b[12] = h[3] & 255;
	out.b[13] = h[3] >> 8 & 255;
	out.b[14] = h[3] >> 16 & 255;
	out.b[15] = h[3] >>> 24;
	return out;
};
haxe_crypto_Md5.bytes2blks = function(b) {
	var nblk = (b.length + 8 >> 6) + 1;
	var blks = [];
	var blksSize = nblk * 16;
	var _g = 0;
	while(_g < blksSize) blks[_g++] = 0;
	var i = 0;
	while(i < b.length) {
		blks[i >> 2] |= b.b[i] << (((b.length << 3) + i & 3) << 3);
		++i;
	}
	blks[i >> 2] |= 128 << (b.length * 8 + i) % 4 * 8;
	var l = b.length * 8;
	var k = nblk * 16 - 2;
	blks[k] = l & 255;
	blks[k] = (blks[k] |= (l >>> 8 & 255) << 8) | (l >>> 16 & 255) << 16;
	blks[k] |= (l >>> 24 & 255) << 24;
	return blks;
};
haxe_crypto_Md5.prototype = {
	bitOR: function(a,b) {
		return (a >>> 1 | b >>> 1) << 1 | (a & 1 | b & 1);
	}
	,bitXOR: function(a,b) {
		return (a >>> 1 ^ b >>> 1) << 1 | a & 1 ^ b & 1;
	}
	,bitAND: function(a,b) {
		return (a >>> 1 & b >>> 1) << 1 | a & 1 & (b & 1);
	}
	,addme: function(x,y) {
		var lsw = (x & 65535) + (y & 65535);
		return (x >> 16) + (y >> 16) + (lsw >> 16) << 16 | lsw & 65535;
	}
	,rol: function(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	,cmn: function(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	,ff: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	,gg: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	,hh: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	,ii: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	,doEncode: function(x) {
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	,__class__: haxe_crypto_Md5
};
var haxe_crypto_Sha1 = function() {
};
haxe_crypto_Sha1.__name__ = "haxe.crypto.Sha1";
haxe_crypto_Sha1.make = function(b) {
	var h = new haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b));
	var out = new haxe_io_Bytes(new ArrayBuffer(20));
	out.b[0] = h[0] >>> 24;
	out.b[1] = h[0] >> 16 & 255;
	out.b[2] = h[0] >> 8 & 255;
	out.b[3] = h[0] & 255;
	out.b[4] = h[1] >>> 24;
	out.b[5] = h[1] >> 16 & 255;
	out.b[6] = h[1] >> 8 & 255;
	out.b[7] = h[1] & 255;
	out.b[8] = h[2] >>> 24;
	out.b[9] = h[2] >> 16 & 255;
	out.b[10] = h[2] >> 8 & 255;
	out.b[11] = h[2] & 255;
	out.b[12] = h[3] >>> 24;
	out.b[13] = h[3] >> 16 & 255;
	out.b[14] = h[3] >> 8 & 255;
	out.b[15] = h[3] & 255;
	out.b[16] = h[4] >>> 24;
	out.b[17] = h[4] >> 16 & 255;
	out.b[18] = h[4] >> 8 & 255;
	out.b[19] = h[4] & 255;
	return out;
};
haxe_crypto_Sha1.bytes2blks = function(b) {
	var nblk = (b.length + 8 >> 6) + 1;
	var blks = [];
	var _g = 0;
	var _g1 = nblk * 16;
	while(_g < _g1) blks[_g++] = 0;
	var _g = 0;
	var _g1 = b.length;
	while(_g < _g1) {
		var i = _g++;
		blks[i >> 2] |= b.b[i] << 24 - ((i & 3) << 3);
	}
	var i = b.length;
	blks[i >> 2] |= 128 << 24 - ((i & 3) << 3);
	blks[nblk * 16 - 1] = b.length * 8;
	return blks;
};
haxe_crypto_Sha1.prototype = {
	doEncode: function(x) {
		var w = [];
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var e = -1009589776;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;
			var j = 0;
			while(j < 80) {
				if(j < 16) {
					w[j] = x[i + j];
				} else {
					var num = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
					w[j] = num << 1 | num >>> 31;
				}
				var t = (a << 5 | a >>> 27) + this.ft(j,b,c,d) + e + w[j];
				e = d;
				d = c;
				c = b << 30 | b >>> 2;
				b = a;
				a = t + this.kt(j);
				++j;
			}
			a += olda;
			b += oldb;
			c += oldc;
			d += oldd;
			e += olde;
			i += 16;
		}
		return [a,b,c,d,e];
	}
	,ft: function(t,b,c,d) {
		if(t < 20) {
			return b & c | ~b & d;
		}
		if(t < 40) {
			return b ^ c ^ d;
		}
		if(t < 60) {
			return b & c | b & d | c & d;
		}
		return b ^ c ^ d;
	}
	,kt: function(t) {
		if(t < 20) {
			return 1518500249;
		}
		if(t < 40) {
			return 1859775393;
		}
		if(t < 60) {
			return -1894007588;
		}
		return -899497514;
	}
	,__class__: haxe_crypto_Sha1
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: haxe_ds__$List_ListNode
};
var haxe_ds__$List_ListIterator = function(head) {
	this.head = head;
};
haxe_ds__$List_ListIterator.__name__ = "haxe.ds._List.ListIterator";
haxe_ds__$List_ListIterator.prototype = {
	head: null
	,hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: haxe_ds__$List_ListIterator
};
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__:"haxe.ds.Option",__constructs__:null
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_._hx_name="Some",$_.__params__ = ["v"],$_)
	,None: {_hx_name:"None",_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
haxe_ds_Option.__constructs__ = [haxe_ds_Option.Some,haxe_ds_Option.None];
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.createCopy = function(h) {
	var copy = new haxe_ds_StringMap();
	for (var key in h) copy.h[key] = h[key];
	return copy;
};
haxe_ds_StringMap.prototype = {
	h: null
	,get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	h: null
	,keys: null
	,length: null
	,current: null
	,hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapKeyValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyValueIterator.__name__ = "haxe.ds._StringMap.StringMapKeyValueIterator";
haxe_ds__$StringMap_StringMapKeyValueIterator.prototype = {
	h: null
	,keys: null
	,length: null
	,current: null
	,hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		var key = this.keys[this.current++];
		return { key : key, value : this.h[key]};
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyValueIterator
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	posInfos: null
	,toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_http_HttpBase = function(url) {
	this.url = url;
	this.headers = [];
	this.params = [];
	this.emptyOnData = $bind(this,this.onData);
};
haxe_http_HttpBase.__name__ = "haxe.http.HttpBase";
haxe_http_HttpBase.prototype = {
	url: null
	,responseBytes: null
	,responseAsString: null
	,postData: null
	,postBytes: null
	,headers: null
	,params: null
	,emptyOnData: null
	,setHeader: function(name,value) {
		var _g = 0;
		var _g1 = this.headers.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.headers[i].name == name) {
				this.headers[i] = { name : name, value : value};
				return this;
			}
		}
		this.headers.push({ name : name, value : value});
		return this;
	}
	,setParameter: function(name,value) {
		var _g = 0;
		var _g1 = this.params.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.params[i].name == name) {
				this.params[i] = { name : name, value : value};
				return this;
			}
		}
		this.params.push({ name : name, value : value});
		return this;
	}
	,setPostData: function(data) {
		this.postData = data;
		this.postBytes = null;
		return this;
	}
	,onData: function(data) {
	}
	,onBytes: function(data) {
	}
	,onError: function(msg) {
	}
	,onStatus: function(status) {
	}
	,hasOnData: function() {
		return !Reflect.compareMethods($bind(this,this.onData),this.emptyOnData);
	}
	,success: function(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	,get_responseData: function() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
	,__class__: haxe_http_HttpBase
	,__properties__: {get_responseData:"get_responseData"}
};
var haxe_http_HttpNodeJs = function(url) {
	haxe_http_HttpBase.call(this,url);
};
haxe_http_HttpNodeJs.__name__ = "haxe.http.HttpNodeJs";
haxe_http_HttpNodeJs.__super__ = haxe_http_HttpBase;
haxe_http_HttpNodeJs.prototype = $extend(haxe_http_HttpBase.prototype,{
	req: null
	,request: function(post) {
		var _gthis = this;
		this.responseAsString = null;
		this.responseBytes = null;
		var parsedUrl = js_node_Url.parse(this.url);
		var secure = parsedUrl.protocol == "https:";
		var host = parsedUrl.hostname;
		var path = parsedUrl.path;
		var port = parsedUrl.port != null ? Std.parseInt(parsedUrl.port) : secure ? 443 : 80;
		var h = { };
		var _g = 0;
		var _g1 = this.headers;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			var arr = Reflect.field(h,i.name);
			if(arr == null) {
				arr = [];
				h[i.name] = arr;
			}
			arr.push(i.value);
		}
		if(this.postData != null || this.postBytes != null) {
			post = true;
		}
		var uri = null;
		var _g = 0;
		var _g1 = this.params;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(uri == null) {
				uri = "";
			} else {
				uri += "&";
			}
			var s = p.name;
			var uri1 = encodeURIComponent(s) + "=";
			var s1 = p.value;
			uri += uri1 + encodeURIComponent(s1);
		}
		var question = path.split("?").length <= 1;
		if(uri != null) {
			path += (question ? "?" : "&") + uri;
		}
		var opts = { protocol : parsedUrl.protocol, hostname : host, port : port, method : post ? "POST" : "GET", path : path, headers : h};
		var httpResponse = function(res) {
			res.setEncoding("binary");
			var s = res.statusCode;
			if(s != null) {
				_gthis.onStatus(s);
			}
			var data = [];
			res.on("data",function(chunk) {
				data.push(js_node_buffer_Buffer.from(chunk,"binary"));
			});
			res.on("end",function(_) {
				var buf = data.length == 1 ? data[0] : js_node_buffer_Buffer.concat(data);
				var httpResponse = buf.buffer.slice(buf.byteOffset,buf.byteOffset + buf.byteLength);
				_gthis.responseBytes = haxe_io_Bytes.ofData(httpResponse);
				_gthis.req = null;
				if(s != null && s >= 200 && s < 400) {
					_gthis.success(_gthis.responseBytes);
				} else {
					_gthis.onError("Http Error #" + s);
				}
			});
		};
		this.req = secure ? js_node_Https.request(opts,httpResponse) : js_node_Http.request(opts,httpResponse);
		if(post) {
			if(this.postData != null) {
				this.req.write(this.postData);
			} else if(this.postBytes != null) {
				this.req.setHeader("Content-Length","" + this.postBytes.length);
				this.req.write(js_node_buffer_Buffer.from(this.postBytes.b.bufferValue));
			}
		}
		this.req.end();
	}
	,__class__: haxe_http_HttpNodeJs
});
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
haxe_io_BytesBuffer.prototype = {
	buffer: null
	,view: null
	,u8: null
	,pos: null
	,size: null
	,addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	b: null
	,writeByte: function(c) {
		this.b.addByte(c);
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:"haxe.io.Error",__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_io_Path = function() { };
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < paths.length) {
		var v = paths[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	if(_g.length == 0) {
		return "";
	}
	var path = _g[0];
	var _g1 = 1;
	var _g2 = _g.length;
	while(_g1 < _g2) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += _g[_g1++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = target.join(slash);
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_rtti_Meta = function() { };
haxe_rtti_Meta.__name__ = "haxe.rtti.Meta";
haxe_rtti_Meta.getMeta = function(t) {
	return t.__meta__;
};
haxe_rtti_Meta.getFields = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.fields == null) {
		return { };
	} else {
		return meta.fields;
	}
};
var hiss_SetType = $hxEnums["hiss.SetType"] = { __ename__:"hiss.SetType",__constructs__:null
	,Global: {_hx_name:"Global",_hx_index:0,__enum__:"hiss.SetType",toString:$estr}
	,Local: {_hx_name:"Local",_hx_index:1,__enum__:"hiss.SetType",toString:$estr}
	,Destructive: {_hx_name:"Destructive",_hx_index:2,__enum__:"hiss.SetType",toString:$estr}
};
hiss_SetType.__constructs__ = [hiss_SetType.Global,hiss_SetType.Local,hiss_SetType.Destructive];
var hiss_CCInterp = $hx_exports["hiss"]["CCInterp"] = function(printFunction) {
	this.scriptArgs = [];
	this.currentEvalAllFunction = null;
	this.currentBeginFunction = null;
	this.debugClassImports = false;
	this.errorHandler = null;
	this.maxStackDepth = 0;
	this.readingProgram = false;
	this.tempTrace = null;
	var _gthis = this;
	hiss_HissTestCase.reallyTrace = haxe_Log.trace;
	this.globals = this.emptyDict();
	this.reader = new hiss_HissReader(this);
	var code = 0;
	this.importFunction(Sys,function() {
		process.exit(code);
	},{ name : "quit!", argNames : []});
	var _g = $bind(this,this.set);
	var type = hiss_SetType.Global;
	this.importSpecialForm(function(args,env,cc) {
		_g(type,args,env,cc);
	},{ name : "defvar"});
	var _g1 = $bind(this,this.set);
	var type1 = hiss_SetType.Local;
	this.importSpecialForm(function(args,env,cc) {
		_g1(type1,args,env,cc);
	},{ name : "setlocal!"});
	var _g2 = $bind(this,this.set);
	var type2 = hiss_SetType.Destructive;
	this.importSpecialForm(function(args,env,cc) {
		_g2(type2,args,env,cc);
	},{ name : "set!"});
	var _g3 = $bind(this,this.setCallable);
	var isMacro = false;
	this.importSpecialForm(function(args,env,cc) {
		_g3(isMacro,args,env,cc);
	},{ name : "defun"});
	var _g4 = $bind(this,this.setCallable);
	var isMacro1 = true;
	this.importSpecialForm(function(args,env,cc) {
		_g4(isMacro1,args,env,cc);
	},{ name : "defmacro"});
	this.importSpecialForm($bind(this,this.defAlias),{ name : "defalias"});
	this.importSpecialForm($bind(this,this._eval),{ name : "eval"});
	var _g5 = $bind(this,this.funcall);
	var callInline = false;
	this.importSpecialForm(function(args,env,cc) {
		_g5(callInline,args,env,cc);
	},{ name : "funcall"});
	var _g6 = $bind(this,this.funcall);
	var callInline1 = true;
	this.importSpecialForm(function(args,env,cc) {
		_g6(callInline1,args,env,cc);
	},{ name : "funcall-inline"});
	this.useFunctions($bind(this,this.trBegin),$bind(this,this.trEvalAll),$bind(this,this.iterate));
	var _g7 = $bind(this,this.useFunctions);
	var beginFunction = $bind(this,this.trBegin);
	var evalAllFunction = $bind(this,this.trEvalAll);
	var iterateFunction = $bind(this,this.iterate);
	this.importFunction(this,function() {
		return _g7(beginFunction,evalAllFunction,iterateFunction);
	},{ name : "disable-cc!"});
	var _g8 = $bind(this,this.useFunctions);
	var beginFunction1 = $bind(this,this.begin);
	var evalAllFunction1 = $bind(this,this.evalAll);
	var iterateFunction1 = $bind(this,this.iterateCC);
	this.importFunction(this,function() {
		return _g8(beginFunction1,evalAllFunction1,iterateFunction1);
	},{ name : "enable-cc!"});
	this.importFunction(this,$bind(this,this.error),{ name : "error!", argNames : ["message"]},hiss_HValue.Nil);
	this.importSpecialForm($bind(this,this.throwsError),{ name : "error?"});
	this.importSpecialForm($bind(this,this.hissTry),{ name : "try"});
	this.importFunction(this,$bind(this,this.repl),{ name : "repl"});
	this.importFunction(this,$bind(this,this.read),{ name : "read", argNames : ["string"]},hiss_HValue.Nil);
	this.importFunction(this,$bind(this,this.readAll),{ name : "read-all", argNames : ["string"]},hiss_HValue.Nil);
	this.importClass(hiss_HStream,{ name : "HStream"});
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.setMacroString)),{ name : "set-macro-string!", argNames : ["string","read-function"]},hiss_HValue.List([hiss_HValue.Int(1)]));
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.setDefaultReadFunction)),{ name : "set-default-read-function!", argNames : ["read-function"]},hiss_HValue.T);
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.readNumber)),{ name : "read-number!", argNames : ["start","stream"]},hiss_HValue.Nil);
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.readString)),{ name : "read-string!", argNames : ["start","stream"]},hiss_HValue.Nil);
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.readSymbol)),{ name : "read-symbol!", argNames : ["start","stream"]},hiss_HValue.Nil);
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.nextToken)),{ name : "HStream:next-token!", argNames : ["stream"]},hiss_HValue.Nil);
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.readDelimitedList)),{ name : "read-delimited-list!", argNames : ["terminator","delimiters","eof-terminates","blank-elements","start","stream"]},hiss_HValue.List([hiss_HValue.Int(3)]));
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.copyReadtable)),{ name : "copy-readtable"});
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.useReadtable)),{ name : "use-readtable!"});
	this.importFunction(this.reader,($_=this.reader,$bind($_,$_.read)),{ name : "read-next!", argNames : ["start","stream"]});
	this.defDestructiveAlias("read-number!","!");
	this.defDestructiveAlias("read-string!","!");
	this.defDestructiveAlias("read-symbol!","!");
	this.defDestructiveAlias("read-delimited-list!","!");
	this.defDestructiveAlias("read-next!","!");
	this.importClass(hiss_Stdlib,{ name : "Stdlib", omitStaticPrefixes : true});
	if(printFunction != null) {
		this.importFunction(this,printFunction,{ name : "print!", argNames : ["value"]},hiss_HValue.Nil);
	}
	this.importClass(hiss_VariadicFunctions,{ name : "VariadicFunctions", omitStaticPrefixes : true});
	this.importClass(hiss_HDict,{ name : "Dict", omitMemberPrefixes : true, omitStaticPrefixes : true, convertNames : function(name) {
		return "dict-" + hx_strings_Strings.toLowerHyphen(name);
	}});
	this.importClass(hiss_wrappers_HFile,{ name : "File"});
	this.importFunction(this,function() {
		return hiss_HValue.List(_gthis.scriptArgs);
	},{ name : "args"});
	this.importClass(hiss_wrappers_HStringTools,{ name : "StringTools", omitStaticPrefixes : true});
	this.importClass(hiss_wrappers_HHttp,{ name : "Http"});
	this.importClass(hiss_wrappers_HHttp,{ name : "HTTP"});
	this.importClass(hiss_wrappers_HDate,{ name : "Date"});
	this.importClass(hiss_wrappers_HType,{ name : "Type"});
	this.importCCFunction($bind(this,this._load),{ name : "load!", argNames : ["file"]});
	var interp = this;
	this.importSpecialForm(function(args,env,cc) {
		hiss_HissTestCase.testAtRuntime(interp,args,env,cc);
	},{ name : "test!"});
	var interp1 = this;
	this.importCCFunction(function(args,env,cc) {
		hiss_HissTestCase.hissPrints(interp1,args,env,cc);
	},{ name : "prints"});
	this.importFunction(hiss_StaticFiles,hiss_StaticFiles.getContent,{ name : "get-content", argNames : ["file"]});
	this.importClass(hiss_SpecialForms,{ name : "SpecialForms", omitStaticPrefixes : true});
	this.importSpecialForm($bind(this,this.loop),{ name : "loop"});
	this.importFunction(this,function() {
		return new hiss_HDict(_gthis);
	},{ name : "empty-readtable"});
	this.importFunction(Std,Std.random,{ name : "random"});
	this.importFunction(Std,Std.parseInt,{ name : "int"});
	this.importFunction(Std,Std.parseFloat,{ name : "float"});
	this.importFunction(Sys,Sys.sleep,{ name : "sleep!", argNames : ["seconds"]});
	this.importFunction(Sys,Sys.getEnv,{ name : "get-env", argNames : ["var"]});
	hiss_StaticFiles._registerFileContent("Stdlib.hiss","/*\r\n    Hiss standard library functions implemented in Hiss\r\n*/\r\n\r\n(defalias add +)\r\n(defalias subtract -)\r\n(defalias divide /)\r\n(defalias multiply *)\r\n(defalias mod %)\r\n(defalias lesser <)\r\n(defalias lesser-equal <=)\r\n(defalias greater >)\r\n(defalias greater-equal >=)\r\n(defalias equal =)\r\n\r\n(defalias dict-make-dict dict)\r\n(defvar dict-make-dict nil)\r\n(defalias dict-put! dict-set!)\r\n(defalias dict-put! dict-set @deprecated)\r\n(defalias dict-exists dict-contains)\r\n\r\n(defalias call-cc call/cc)\r\n\r\n(defun first (l) (nth l 0))\r\n\r\n(defmacro register-method! (method name &optional call-on-reference keep-args-wrapped return-instance)\r\n    \"Register a method call as an unqualified global function. This function will work on any object that defines that function\"\r\n    `(defun ,name (instance &rest args)\r\n        (setlocal! result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))\r\n        (if ,return-instance instance result)))\r\n(defalias register-method! register-method @deprecated)\r\n\r\n(register-method! \"push\" push! t t t)\r\n(defalias push! push @deprecated)\r\n\r\n(register-method! \"shift\" shift! t)\r\n(defalias shift! shift @deprecated)\r\n\r\n(register-method! \"pop\" pop! t)\r\n(defalias pop! pop @deprecated)\r\n\r\n(defun take! (l num)\r\n    \"Destructively take the first num elements from l as a new list\"\r\n    (call-haxe l \"splice\" (list 0 num) t))\r\n(defalias take! take @deprecated)\r\n\r\n(defun drop! (l num)\r\n    \"Destructively remove the first num elements from l\"\r\n    (call-haxe l \"splice\" (list 0 num) t)\r\n    l)\r\n(defalias drop! drop @deprecated)\r\n\r\n(defun slice (l start &optional end)\r\n    (call-haxe l \"slice\" (list start (or end (length l)))))\r\n(defun rslice (l start &optional end)\r\n    (let (len (length l))\r\n        (slice l (- len (or end len)) (- len start))))\r\n(defun peek (l num)\r\n    (slice l 0 num))\r\n(defun last (l)\r\n    (nth l (- (length l) 1)))\r\n\r\n(defalias setlocal! setlocal @deprecated)\r\n(defalias set! set @deprecated)\r\n(defalias set-nth! set-nth @deprecated) \r\n\r\n(defun nil? (v) (eq nil v))\r\n\r\n// String functions:\r\n(register-method! \"split\" split)\r\n(register-method! \"substr\" substring)\r\n(defun char-at (str idx) (substring str idx 1))\r\n\r\n(defun list (&rest args) args)\r\n(defun empty? (list-or-string) (or (nil? list-or-string) (= 0 (length list-or-string))))\r\n\r\n(defun zip (&rest lists)\r\n    \"Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists\"\r\n    (setlocal! final-length (first (sort (for l lists (length l)))))\r\n    (for i (range final-length)\r\n        (for l lists (nth l i))))\r\n\r\n(defmacro cond (&rest forms)\r\n    `(if (not ',forms)\r\n            (error! \"cond ran out of options. add a default case\")\r\n        (and ',forms (if (eval (first (first ',forms)))\r\n            (eval (cons 'begin (rest (first ',forms))))\r\n        (eval (cons 'cond (rest ',forms)))))))\r\n\r\n(defmacro when (cond &rest body)\r\n    `(if ,cond (begin ,@body)))\r\n\r\n(defmacro unless (cond &rest body)\r\n    `(when (not ,cond) ,@body))\r\n\r\n(defmacro while (cond &rest body)\r\n    `(call/cc (lambda (break)\r\n        (loop ()\r\n            (when ,cond\r\n                (call/cc (lambda (continue)\r\n                    ,@body))\r\n                (if ,cond (recur)))))))\r\n\r\n(defun groups (l size &optional take-remainder)\r\n    (setlocal! c (list-copy l))\r\n    (setlocal! g (list))\r\n    (while c\r\n        (cond\r\n            ((< (length c) size)\r\n                (when take-remainder\r\n                    (push! g (list-copy c)))\r\n                (clear! c))\r\n            (t\r\n                (push! g (take! c size)))))\r\n\tg)\r\n\r\n(defmacro let (bindings &rest body)\r\n    (setlocal! setlocal-exps \r\n        (cond\r\n            ; New-fangled, single-list let bindings like (name1 val1 name2 val2)\r\n            ((symbol? (first bindings))\r\n                (for pair (groups bindings 2) `(setlocal! ,(first pair) ,(nth pair 1))))\r\n\r\n            ; Old-school, many-list let bindings like ((name1 val1) (name2 val2))\r\n            ((list? (first bindings))\r\n                (for pair bindings `(setlocal! ,@pair)))))\r\n    `(begin\r\n        ,@setlocal-exps\r\n        ,@body))\r\n\r\n(defun apply (f args)\r\n    (eval `(,f ',@args)))\r\n\r\n(defmacro bind (f &rest bind-args)\r\n    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))\r\n        `(lambda (&rest call-args)\r\n            (setlocal! args (for arg ',bind-args (if (eq '_ arg) (shift! call-args) arg)))\r\n            (apply ,f (append args call-args)))))\r\n\r\n(defmacro rbind (f &rest bind-args)\r\n    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))\r\n        `(lambda (&rest call-args)\r\n            (setlocal! args (for arg ',bind-args (if (eq '_ arg) (pop! call-args) arg)))\r\n            (apply ,f (append call-args args)))))\r\n\r\n(defvar second (rbind nth 1))\r\n(defvar third (rbind nth 2))\r\n(defvar fourth (rbind nth 3))\r\n(defvar fifth (rbind nth 4))\r\n(defvar sixth (rbind nth 5))\r\n(defvar seventh (rbind nth 6))\r\n(defvar eighth (rbind nth 7))\r\n(defvar ninth (rbind nth 8))\r\n(defvar tenth (rbind nth 9))\r\n\r\n(defun collect (iterable)\r\n    (for elem iterable elem))\r\n\r\n(defun enumerate (l)\r\n    (zip (collect (range (length l))) l))\r\n\r\n(defun filter (l &optional pred)\r\n    (let (pred (or pred (lambda (x) x))\r\n            result (list))\r\n        (do-for elem l (when (pred elem) (push! result elem)))\r\n        result))\r\n\r\n(defun current-continuation ()\r\n    (call/cc (lambda (cc) \r\n        (cc cc))))\r\n\r\n(defmacro _case (value &rest case-list)\r\n    (let (case-first (first case-list)\r\n            case-rest (rest case-list))\r\n        (if case-first\r\n            `(if (or (eq ',(first case-first) 'default) (eq ,(first case-first) ,value))\r\n                (begin ,@(rest case-first))\r\n                (case ,value ,@case-rest))\r\n            nil)))\r\n(defmacro case (form &rest case-list)\r\n    `(let (value ,form) (_case value ,@case-list)))\r\n\r\n(defun input-string! (&optional prompt)\r\n    (when prompt (message! prompt))\r\n    (read-line!))\r\n(defalias input-string! input-string @deprecated)\r\n\r\n(defun input-int! (&optional prompt)\r\n    (int (input-string prompt)))\r\n(defalias input-int! input-int @deprecated)\r\n\r\n(defun input-float! (&optional prompt)\r\n    (float (input-string prompt)))\r\n(defalias input-float! input-float @deprecated)\r\n\r\n(defun input-symbol! (&optional prompt)\r\n    (let (name \r\n                (input-string prompt))\r\n        // don't return a gensym if the input is blank\r\n        (if (empty? name) nil (symbol name))))\r\n(defalias input-symbol! input-symbol @deprecated)\r\n\r\n// Very dangerous function:\r\n(defun input-expression! (&optional prompt)\r\n    (eval (read (input-string prompt))))\r\n(defalias input-expression! input-expression @deprecated)\r\n\r\n(defun input-choice! (choices &optional prompt)\r\n    (when prompt (message! prompt))\r\n    (do-for (idx choice) (enumerate choices)\r\n        (message! \"${idx}. $(to-print choice)\"))\r\n    (nth choices (input-int \"> \")))\r\n(defalias input-choice! input-choice @deprecated)\r\n\r\n(defmacro set-default! (var value)\r\n    `(if (or (not (bound? ,var)) (nil? ,var)) (set! ,var ,value)))\r\n\r\n// (next) and (has-next) should work on Iterables AND Iterators, for convenience\r\n(defun iterator (iterable-or-iterator)\r\n    (if (get-property iterable-or-iterator \"iterator\")\r\n        (call-haxe iterable-or-iterator \"iterator\") iterator-or-iterable))\r\n\r\n(defun next! (iterable-or-iterator)\r\n    (call-haxe (iterator iterable-or-iterator) \"next\"))\r\n(defalias next! next @deprecated)\r\n\r\n(defun has-next (iterable-or-iterator)\r\n    (call-haxe (iterator iterable-or-iterator) \"hasNext\"))\r\n\r\n(if (bound? Thread)\r\n    (defmacro defgen (name args &rest body)\r\n        `(defun ,name ,args\r\n            (let (__lock__ (new Lock)\r\n                    __deque__ (new Deque)\r\n                    __thread__ nil\r\n                    __next__ nil // When has-next is called, the next value must be stored\r\n                    __done__ nil\r\n                    __done-signal__ (symbol)\r\n                    yield (lambda (value)\r\n                                (Deque:add! __deque__ value)\r\n                                (Lock:wait! __lock__))\r\n                    next (lambda ()\r\n                            (if __done__ nil\r\n                                (begin\r\n                                    (if __next__\r\n                                        (return (let (ret __next__)\r\n                                            (set! __next__ nil)\r\n                                            ret)))\r\n                                    (if (not __thread__)\r\n                                        (set! __thread__ (Thread:create!\r\n                                                                (lambda ()\r\n                                                                    ,@body\r\n                                                                    (Deque:add! __deque__ __done-signal__)))))\r\n                                    (Lock:release! __lock__)\r\n                                    (let (value (Deque:pop! __deque__ t))\r\n                                        (case value\r\n                                            (__done-signal__ (set! __done__ t) nil)\r\n                                            (default value))))))\r\n                    has-next (lambda ()\r\n                                (if __done__ nil\r\n                                    (if __next__ t\r\n                                        (let (could-be-next (next))\r\n                                            (case could-be-next\r\n                                                (nil (not __done__))\r\n                                                (default (set! __next__ could-be-next) t)))))))\r\n                (iterable next has-next)))))\r\n\r\n(defun memoize (f)\r\n    \"Return a version of the given function that caches return values for different argument lists\"\r\n    (let (prior-args (dict))\r\n        (lambda (&rest args)\r\n            (or (dict-get prior-args args)\r\n                (let (result (apply f args))\r\n                    (dict-set! prior-args args result)\r\n                    result)))))\r\n\r\n; TODO if it's neither a list nor string, throw an error\r\n; In cases where a function name could reasonably be expected to work the same on EITHER a string or a list, Hiss should support both:\r\n(defun replace (string-or-list old new)\r\n    (cond\r\n        ((list? string-or-list)\r\n            (for elem string-or-list (if (eq old elem) new elem)))\r\n        ((string? string-or-list)\r\n            (call-haxe StringTools \"replace\" (list string-or-list old new)))\r\n        (t (error! \"replace can't be called on $string-or-list\"))))\r\n\r\n(defun index-of (string-or-list part &optional start-index)\r\n    (set-default! start-index 0)\r\n    (cond\r\n        ((list? string-or-list)\r\n            (setlocal! found-idx -1)\r\n            (do-for (idx elem) (enumerate string-or-list)\r\n                (when (and (<= start-index idx) (eq part elem))\r\n                    (set! found-idx idx)\r\n                    (break)))\r\n            found-idx)\r\n        ((string? string-or-list)\r\n            (call-haxe string-or-list \"indexOf\" (list part start-index)))\r\n        (t (error! \"index-of can't be called on $string-or-list\"))))\r\n\r\n(defun last-index-of (string-or-list part &optional start-index)\r\n    (set-default! start-index (- (length (string-or-list)) 1))\r\n    (cond\r\n        ((list? string-or-list)\r\n            (do-for (idx elem) (reverse (enumerate string-or-list))\r\n                (if (and (>= start-index idx) (eq part elem))\r\n                    (return idx)))\r\n            -1)\r\n        ((string? string-or-list)\r\n            (call-haxe string-or-list \"lastIndexOf\" (list part start-index)))\r\n        (t (error! \"last-index-of can't be called on $string-or-list\"))))\r\n\r\n\r\n(defun contains (string-or-list part)\r\n    (<= 0 (index-of string-or-list part)))\r\n\r\n; It also might make sense to have recursive versions of some of these:\r\n\r\n(defun tree-replace (tree old new)\r\n    (cond\r\n        ((list? tree)\r\n            (for subtree tree (tree-replace subtree old new)))\r\n        (t (if (eq tree old) new tree))))\r\n\r\n(defun tree-contains (tree elem)\r\n    (cond\r\n        ((list? tree)\r\n            (setlocal! found nil)\r\n            (do-for subtree tree\r\n                (when (tree-contains subtree elem)\r\n                    (set! found t)\r\n                    (break)))\r\n            found)\r\n        (t (eq tree elem))))\r\n\r\n(defvar *types* (dict))\r\n\r\n(defmacro deftype (name &rest predicates)\r\n    (let (predicate-values\r\n                (for predicate predicates (eval predicate))\r\n            combined-predicate\r\n                (lambda (val)\r\n                    (set! ret t)\r\n                    (do-for predicate predicate-values\r\n                        (when (not (predicate val))\r\n                            (set! ret nil)\r\n                            (break)))\r\n                    ret)\r\n            predicate-name (symbol \"$(symbol-name name)?\"))\r\n        `(begin\r\n            (dict-set! *types* ',name ,combined-predicate)\r\n            (set-default! ,predicate-name ,combined-predicate)  ; If a predicate with the given name is already defined, it will be kept as the global predicate\r\n            t)))\r\n\r\n(defmacro the (type var)\r\n    \"Throw an error if the given variable is not the given type, else return the variable\"\r\n    `(let (value ,var)\r\n        (if (funcall (dict-get *types* ',type) value)\r\n                value\r\n            (error! (+ \"$value is not expected type \" ',type)))))\r\n\r\n(defun bool? (v)\r\n    (case v\r\n        (t t)\r\n        (nil t)\r\n        (default nil)))\r\n\r\n(deftype bool bool?)\r\n(deftype int int?)\r\n(deftype float float?)\r\n(deftype number number?)\r\n(deftype symbol symbol?)\r\n(deftype string string?)\r\n(deftype list list?)\r\n(deftype pair list? (lambda (l) (= 2 (length l))))\r\n(deftype dict dict?)\r\n(deftype function function?)\r\n(deftype macro macro?)\r\n(deftype callable callable?)\r\n(deftype object object?)\r\n(deftype any (lambda (v) t))\r\n\r\n(defmacro defstruct (name &rest fields)\r\n    (let (make-function-name\r\n                (symbol \"make-$name\")\r\n            type-predicate-name\r\n                (symbol \"${name}?\")\r\n            field-names-and-types\r\n                (for field fields\r\n                    (cond\r\n                        ((pair? field) field)\r\n                        ((symbol? field) (list field 'any))\r\n                        (t (error! \"struct fields must either be a symbol (for any type) or a pair (for a specific type)\"))))\r\n            field-indices\r\n                (collect (range 1 (+ 1 (length fields))))\r\n            field-info\r\n                (zip field-indices field-names-and-types)\r\n            field-getters\r\n                (for (index (field-name _)) field-info\r\n                    `(defun ,(symbol \"${name}-${field-name}\") (instance) (nth instance ,index)))\r\n            all-fields-typecheck\r\n                (for (index (field-name field-type)) field-info\r\n                    `(the ,field-type (nth instance ,index)))\r\n            field-setters\r\n                (for (index (field-name field-type)) field-info\r\n                    `(defun ,(symbol \"${name}-set-${field-name}!\") (instance value) (set-nth! instance ,index (the ,field-type value)))))\r\n\r\n    `(begin\r\n        (defun ,make-function-name (&rest make-args) (the ,name (cons ',name make-args)))\r\n        (defun ,type-predicate-name (instance)\r\n            (and (eq ',name (first instance))\r\n                (not (error? (begin ,@all-fields-typecheck)))))\r\n\r\n        ,@field-getters\r\n        ,@field-setters\r\n        (deftype ,name ,type-predicate-name))))\r\n\r\n// redefine take-until to return a list instead of an object\r\n(defvar _take-until HStream:take-until)\r\n// TODO it's weird that in order to make true the default for an imported function, we need to invert the calling convention like so:\r\n(defun HStream:take-until (stream terminators &optional no-eof-terminates no-escaped-terminators no-drop-terminator)\r\n    (let (output-object (_take-until stream terminators (not no-eof-terminates) (not no-escaped-terminators) (not no-drop-terminator)))\r\n        (list (get-property output-object \"output\") (get-property output-object \"terminator\"))))\r\n// redefine peek and take to return empty string if the stream is empty\r\n(defvar _peek HStream:peek)\r\n(defun HStream:peek (stream count) (try (_peek stream count) \"\"))\r\n(defvar _take HStream:take)\r\n(defun HStream:take (stream count) (try (_take stream count) \"\"))\r\n// TODO when catch statements change, those ^ will change\r\n\r\n(defmacro def-reader-macro (str arg-names &rest body)\r\n    `(set-macro-string! ,str (lambda (,(first arg-names) ,(second arg-names)) ,@body)))\r\n\r\n(def-reader-macro \"[\" (start stream) (cons 'list (read-delimited-list! \"]\" '() nil null start stream)))\r\n\r\n(def-reader-macro \"!\" (start stream) (list 'not (read-next! \"\" stream)))\r\n\r\n(defmacro if-let ((name expression) then &optional else)\r\n    `(let (,name ,expression)\r\n        (if ,name ,then ,else)))\r\n\r\n(defmacro when-let ((name expression) &rest body)\r\n    `(if-let (,name ,expression)\r\n        (begin ,@body)))\r\n\r\n(defalias sleep! sleep @deprecated)\r\n(defalias error! error @deprecated)\r\n(when (bound? quit!) (defalias quit! quit))\r\n\r\n(defalias use-readtable! use-readtable @deprecated)\r\n(defalias set-macro-string! set-macro-string @deprecated)\r\n(defalias set-default-read-function! set-default-read-function @deprecated)\r\n(defalias HStream:next-token! next-token @deprecated)\r\n\r\n(defalias print! print @deprecated)\r\n(defalias message! message @deprecated)\r\n(defalias load! load @deprecated)\r\n\r\n(defalias enable-cc! enable-continuations @deprecated)\r\n(defalias enable-cc! disable-tail-recursion @deprecated)\r\n(defalias disable-cc! disable-continuations @deprecated)\r\n(defalias disable-cc! enable-tail-recursion @deprecated)\r\n\r\n(defalias dict-set! dict-set @deprecated)\r\n(defalias dict-erase! dict-erase @deprecated)\r\n(defalias delay! delay @deprecated)\r\n(defalias set-default! default! @deprecated)\r\n(defalias set-default! default @deprecated)\r\n\r\n(defalias clear! clear @deprecated)\r\n(defalias test! test @deprecated)");
	this.load("Stdlib.hiss");
};
hiss_CCInterp.__name__ = "hiss.CCInterp";
hiss_CCInterp.noOp = function(args,env,cc) {
};
hiss_CCInterp.noCC = function(arg) {
};
hiss_CCInterp.emptyList = function() {
	return hiss_HValue.List([]);
};
hiss_CCInterp.main = function() {
	hiss_CCInterp.run(new hiss_CCInterp());
};
hiss_CCInterp.run = function(interp,args) {
	if(args == null) {
		args = process.argv.slice(2);
	}
	var script = null;
	while(args.length > 0) {
		var nextArg = args.shift();
		if(nextArg == null) {
			if(StringTools.endsWith(nextArg,".hiss")) {
				script = nextArg;
			} else if(script != null) {
				interp.scriptArgs.push(hiss_HValue.String(nextArg));
			}
		} else {
			switch(nextArg) {
			case "--no-console-reader":case "--no-cr":case "--nocr":
				break;
			default:
				if(StringTools.endsWith(nextArg,".hiss")) {
					script = nextArg;
				} else if(script != null) {
					interp.scriptArgs.push(hiss_HValue.String(nextArg));
				}
			}
		}
	}
	if(script != null) {
		interp.load(script);
	} else {
		interp.repl(false);
	}
};
hiss_CCInterp.prototype = {
	globals: null
	,reader: null
	,tempTrace: null
	,readingProgram: null
	,maxStackDepth: null
	,errorHandler: null
	,setErrorHandler: function(handler) {
		this.errorHandler = handler;
	}
	,error: function(message) {
		if(this.errorHandler != null) {
			this.errorHandler(message);
		} else {
			throw haxe_Exception.thrown(message);
		}
	}
	,disableTrace: function() {
		if(this.tempTrace == null) {
			haxe_Log.trace("Disabling trace",{ fileName : "src/hiss/CCInterp.hx", lineNumber : 86, className : "hiss.CCInterp", methodName : "disableTrace"});
			this.tempTrace = haxe_Log.trace;
			haxe_Log.trace = function(str,posInfo) {
			};
		}
	}
	,enableTrace: function() {
		if(this.tempTrace != null) {
			haxe_Log.trace("Enabling trace",{ fileName : "src/hiss/CCInterp.hx", lineNumber : 94, className : "hiss.CCInterp", methodName : "enableTrace"});
			haxe_Log.trace = this.tempTrace;
		}
	}
	,importVar: function(value,name) {
		hiss_HissTools.put(this.globals,name,hiss_HissTools.toHValue(value));
	}
	,debugClassImports: null
	,importClass: function(clazz,meta) {
		var _gthis = this;
		if(this.debugClassImports) {
			haxe_Log.trace("Import " + meta.name,{ fileName : "src/hiss/CCInterp.hx", lineNumber : 124, className : "hiss.CCInterp", methodName : "importClass"});
		}
		hiss_HissTools.put(this.globals,meta.name,hiss_HValue.Object("Class",clazz));
		if(meta.omitMemberPrefixes == null) {
			meta.omitMemberPrefixes = false;
		}
		if(meta.omitStaticPrefixes == null) {
			meta.omitStaticPrefixes = false;
		}
		if(meta.convertNames == null) {
			meta.convertNames = hx_strings_Strings.toLowerHyphen;
		}
		if(meta.getterPrefix == null) {
			meta.getterPrefix = "get-";
		}
		if(meta.setterPrefix == null) {
			meta.setterPrefix = "set-";
		}
		if(meta.sideEffectSuffix == null) {
			meta.sideEffectSuffix = "!";
		}
		if(meta.predicateSuffix == null) {
			meta.predicateSuffix = "?";
		}
		if(meta.conversionInfix == null) {
			meta.conversionInfix = "->";
		}
		var dummyInstance = Object.create(clazz.prototype);
		var _g = 0;
		var _g1 = Type.getInstanceFields(clazz);
		while(_g < _g1.length) {
			var instanceField = [_g1[_g]];
			++_g;
			if(StringTools.startsWith(instanceField[0],"_")) {
				continue;
			}
			if(Type.typeof(Reflect.getProperty(dummyInstance,instanceField[0]))._hx_index == 5) {
				var metaSignature = "";
				var translatedName = instanceField[0];
				if(instanceField[0].indexOf("_") != -1) {
					metaSignature = instanceField[0].split("_")[1];
					translatedName = HxOverrides.substr(translatedName,0,translatedName.indexOf("_"));
				}
				var bindInterpreter = [metaSignature.indexOf("i") != -1];
				var wrapArgs = metaSignature.indexOf("h") != -1 ? hiss_HValue.T : hiss_HValue.Nil;
				var destructive = metaSignature.indexOf("d") != -1;
				var isPredicate = hx_strings_Strings.toLowerHyphen(translatedName).split("-")[0] == "is";
				if(isPredicate) {
					translatedName = HxOverrides.substr(translatedName,2,null);
				}
				translatedName = meta.convertNames(translatedName);
				if(isPredicate) {
					translatedName += meta.predicateSuffix;
				}
				if(destructive) {
					translatedName += meta.sideEffectSuffix;
				}
				if(!meta.omitMemberPrefixes) {
					translatedName = meta.name + ":" + translatedName;
				}
				if(this.debugClassImports) {
					haxe_Log.trace(translatedName,{ fileName : "src/hiss/CCInterp.hx", lineNumber : 185, className : "hiss.CCInterp", methodName : "importClass"});
				}
				hiss_HissTools.put(this.globals,translatedName,hiss_HValue.Function((function(wrapArgs,bindInterpreter,instanceField) {
					return function(args,env,cc) {
						var instance = hiss_HissTools.value(hiss_HissTools.first(args),_gthis);
						var argArray = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),_gthis,wrapArgs[0]);
						if(bindInterpreter[0]) {
							argArray.splice(0,0,_gthis);
						}
						cc(hiss_HissTools.toHValue(Reflect.getProperty(instance,instanceField[0]).apply(instance,argArray)));
					};
				})([wrapArgs],bindInterpreter,instanceField),{ name : translatedName}));
				if(destructive) {
					this.defDestructiveAlias(translatedName,meta.sideEffectSuffix);
				}
			} else {
				var getterTranslatedName = meta.convertNames(instanceField[0]);
				getterTranslatedName = meta.getterPrefix + getterTranslatedName;
				if(!meta.omitMemberPrefixes) {
					getterTranslatedName = meta.name + ":" + getterTranslatedName;
				}
				if(this.debugClassImports) {
					haxe_Log.trace(getterTranslatedName,{ fileName : "src/hiss/CCInterp.hx", lineNumber : 221, className : "hiss.CCInterp", methodName : "importClass"});
				}
				hiss_HissTools.put(this.globals,getterTranslatedName,hiss_HValue.Function((function(instanceField) {
					return function(args,env,cc) {
						cc(hiss_HissTools.toHValue(Reflect.getProperty(hiss_HissTools.value(hiss_HissTools.first(args),_gthis),instanceField[0])));
					};
				})(instanceField),{ name : getterTranslatedName}));
				var setterTranslatedName = meta.convertNames(instanceField[0]);
				setterTranslatedName = meta.setterPrefix + setterTranslatedName + meta.sideEffectSuffix;
				if(!meta.omitMemberPrefixes) {
					setterTranslatedName = meta.name + ":" + setterTranslatedName;
				}
				if(this.debugClassImports) {
					haxe_Log.trace(setterTranslatedName,{ fileName : "src/hiss/CCInterp.hx", lineNumber : 235, className : "hiss.CCInterp", methodName : "importClass"});
				}
				hiss_HissTools.put(this.globals,setterTranslatedName,hiss_HValue.Function((function(instanceField) {
					return function(args,env,cc) {
						var instance = hiss_HissTools.value(hiss_HissTools.first(args),_gthis);
						var value = hiss_HissTools.value(hiss_HissTools.second(args),_gthis);
						Reflect.setProperty(instance,instanceField[0],value);
						cc(hiss_HissTools.second(args));
					};
				})(instanceField),{ name : setterTranslatedName}));
				this.defDestructiveAlias(setterTranslatedName,meta.sideEffectSuffix);
			}
		}
		var _g = 0;
		var _g1 = Type.getClassFields(clazz);
		while(_g < _g1.length) {
			var classField = _g1[_g];
			++_g;
			if(StringTools.startsWith(classField,"_")) {
				continue;
			}
			var fieldValue = [Reflect.getProperty(clazz,classField)];
			if(Type.typeof(fieldValue[0])._hx_index == 5) {
				var metaSignature = "";
				var translatedName = classField;
				if(classField.indexOf("_") != -1) {
					metaSignature = classField.split("_")[1];
					translatedName = HxOverrides.substr(classField,0,classField.indexOf("_"));
				}
				var bindInterpreter1 = [metaSignature.indexOf("i") != -1];
				var wrapArgs = metaSignature.indexOf("h") != -1 ? hiss_HValue.T : hiss_HValue.Nil;
				var destructive = metaSignature.indexOf("d") != -1;
				var specialForm = metaSignature.indexOf("s") != -1;
				var ccFunction = !specialForm && metaSignature.indexOf("cc") != -1;
				var isPredicate = hx_strings_Strings.toLowerHyphen(translatedName).split("-")[0] == "is";
				if(isPredicate) {
					translatedName = HxOverrides.substr(translatedName,2,null);
				}
				translatedName = meta.convertNames(translatedName);
				if(isPredicate) {
					translatedName += meta.predicateSuffix;
				}
				if(destructive) {
					translatedName += meta.sideEffectSuffix;
				}
				if(!meta.omitStaticPrefixes) {
					translatedName = meta.name + ":" + translatedName;
				}
				if(this.debugClassImports) {
					haxe_Log.trace(translatedName,{ fileName : "src/hiss/CCInterp.hx", lineNumber : 279, className : "hiss.CCInterp", methodName : "importClass"});
				}
				if(ccFunction) {
					this.importCCFunction((function(fieldValue) {
						return function(args,env,cc) {
							fieldValue[0](_gthis,args,env,cc);
						};
					})(fieldValue),{ name : translatedName});
				} else if(specialForm) {
					this.importSpecialForm((function(fieldValue) {
						return function(args,env,cc) {
							fieldValue[0](_gthis,args,env,cc);
						};
					})(fieldValue),{ name : translatedName});
				} else {
					hiss_HissTools.put(this.globals,translatedName,hiss_HValue.Function((function(wrapArgs,bindInterpreter,fieldValue) {
						return function(args,env,cc) {
							var argArray = hiss_HissTools.unwrapList(args,_gthis,wrapArgs[0]);
							if(bindInterpreter[0]) {
								argArray.splice(0,0,_gthis);
							}
							cc(hiss_HissTools.toHValue(fieldValue[0].apply(clazz,argArray)));
						};
					})([wrapArgs],bindInterpreter1,fieldValue),{ name : translatedName}));
				}
				if(destructive) {
					this.defDestructiveAlias(translatedName,meta.sideEffectSuffix);
				}
			}
		}
	}
	,importFunction: function(instance,func,meta,keepArgsWrapped) {
		if(keepArgsWrapped == null) {
			keepArgsWrapped = hiss_HValue.Nil;
		}
		var _gthis = this;
		var tmp = hiss_HValue.Function(function(args,env,cc) {
			var args1 = hiss_HissTools.unwrapList(args,_gthis,keepArgsWrapped);
			cc(hiss_HissTools.toHValue(func.apply(instance,args1)));
		},meta);
		hiss_HissTools.put(this.globals,meta.name,tmp);
	}
	,importCCFunction: function(func,meta) {
		hiss_HissTools.put(this.globals,meta.name,hiss_HValue.Function(func,meta));
	}
	,importSpecialForm: function(func,meta) {
		hiss_HissTools.put(this.globals,meta.name,hiss_HValue.SpecialForm(func,meta));
	}
	,importMethod: function(method,meta,callOnReference,keepArgsWrapped,returnInstance) {
		var _gthis = this;
		var tmp = hiss_HValue.Function(function(args,env,cc) {
			var instance = hiss_HissTools.value(hiss_HissTools.first(args),_gthis,callOnReference);
			var tmp = instance.getProperty(method);
			var tmp1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),_gthis,keepArgsWrapped);
			cc(instance.callMethod(tmp,tmp1).toHValue());
		},meta);
		hiss_HissTools.put(this.globals,meta.name,tmp);
	}
	,currentBeginFunction: null
	,currentEvalAllFunction: null
	,emptyDict: function() {
		return hiss_HValue.Dict(new hiss_HDict(this));
	}
	,emptyEnv: function() {
		return hiss_HValue.List([this.emptyDict()]);
	}
	,throwsError: function(args,env,cc) {
		try {
			this.internalEval(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),args),env,function(val) {
				cc(hiss_HValue.Nil);
			});
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			cc(hiss_HValue.T);
		}
	}
	,hissTry: function(args,env,cc) {
		try {
			this.internalEval(hiss_HissTools.first(args),env,cc);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,hiss_HSignal)) {
				throw haxe_Exception.thrown(_g1);
			} else if(hiss_Stdlib.length_h(args) > 1) {
				this.internalEval(hiss_HissTools.second(args),env,cc);
			} else {
				cc(hiss_HValue.Nil);
			}
		}
	}
	,useFunctions: function(beginFunction,evalAllFunction,iterateFunction) {
		this.currentBeginFunction = beginFunction;
		this.currentEvalAllFunction = evalAllFunction;
		hiss_HissTools.put(this.globals,"begin",hiss_HValue.SpecialForm(beginFunction,{ name : "begin"}));
		var _g = iterateFunction;
		var collect = true;
		var bodyForm = true;
		this.importSpecialForm(function(args,env,cc) {
			_g(collect,bodyForm,args,env,cc);
		},{ name : "for"});
		var _g1 = iterateFunction;
		var collect1 = false;
		var bodyForm1 = true;
		this.importSpecialForm(function(args,env,cc) {
			_g1(collect1,bodyForm1,args,env,cc);
		},{ name : "do-for"});
		var _g2 = iterateFunction;
		var collect2 = true;
		var bodyForm2 = false;
		this.importSpecialForm(function(args,env,cc) {
			_g2(collect2,bodyForm2,args,env,cc);
		},{ name : "map"});
		var _g3 = iterateFunction;
		var collect3 = false;
		var bodyForm3 = false;
		this.importSpecialForm(function(args,env,cc) {
			_g3(collect3,bodyForm3,args,env,cc);
		},{ name : "do-map"});
		return hiss_HValue.Nil;
	}
	,repl: function(useConsoleReader) {
		if(useConsoleReader == null) {
			useConsoleReader = true;
		}
		hiss_StaticFiles._registerFileContent("ReplLib.hiss","// reader macro for inserting previous expressions\n(def-reader-macro \"{\" (start stream)\n    (let (placeholder \n                    start \n            expression\n                (case (HStream:peek stream 1)\n                    (\"}\" \n                        (set! placeholder (+ placeholder (HStream:take stream 1)))\n                        (nth (history) 1))\n                    (\"?\"\n                        (set! placeholder (+ placeholder (HStream:take stream 2)))\n                        (input-choice (history) \"Recent expressions:\"))\n                    (default\n                        (let (take-pair (HStream:take-until stream (list \"}\")))\n                            (set! placeholder (apply + (cons placeholder take-pair)))\n                            (nth (history) (int (first take-pair)))))))\n        (rewrite-history\n            (+ \n                (substring (last (history)) 0 (index-of (last (history)) placeholder))\n                expression \n                (substring (last (history)) (+ (index-of (last (history)) placeholder) (length placeholder)))))\n        (message \"Input expanded to $(last (history))\")\n        (read expression)))");
		this.load("ReplLib.hiss");
		var history = [];
		this.importFunction(this,function() {
			return history;
		},{ name : "history"});
		this.importFunction(this,function(str) {
			return history[history.length - 1] = str;
		},{ name : "rewrite-history"});
		var historyFile = haxe_io_Path.join([hiss_Stdlib.homeDir(),".hisstory"]);
		history = js_node_Fs.readFileSync(historyFile,{ encoding : "utf8"}).split("\n");
		var cReader = null;
		if(useConsoleReader) {
			cReader = new ihx_ConsoleReader(-1,historyFile);
		}
		this.importFunction(this,function() {
			if(useConsoleReader) {
				cReader.saveHistory();
			}
			throw haxe_Exception.thrown(hiss_HSignal.Quit);
		},{ name : "quit!"});
		var locals = this.emptyEnv();
		hiss_HaxeTools.println("Hiss version " + "master-549* (target: nodejs)");
		hiss_HaxeTools.println("Type (help) for a list of functions, or (quit) to quit the REPL");
		while(true) {
			hiss_HaxeTools.print(">>> ");
			var next = "";
			if(useConsoleReader) {
				cReader.cmd.prompt = ">>> ";
				next = cReader.readLine();
			} else {
				next = new _$Sys_FileInput(0).readLine();
			}
			history.push(next);
			var exp = null;
			try {
				exp = this.read(next);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				hiss_HaxeTools.println("Reader error: " + Std.string(haxe_Exception.caught(_g).unwrap()));
				continue;
			}
			try {
				this.internalEval(exp,locals,hiss_Stdlib.print_hd);
			} catch( _g1 ) {
				haxe_NativeStackTrace.lastError = _g1;
				var _g2 = haxe_Exception.caught(_g1).unwrap();
				if(js_Boot.__instanceof(_g2,hiss_HSignal)) {
					return;
				} else if(typeof(_g2) == "string") {
					hiss_HaxeTools.println("Error \"" + _g2 + "\" from `" + hiss_Stdlib.toPrint_h(exp) + "`");
					hiss_HaxeTools.println("Callstack depth " + haxe_CallStack.callStack().length);
				} else {
					hiss_HaxeTools.println("Error type " + Std.string(Type.typeof(_g2)) + ": " + Std.string(_g2) + " from `" + hiss_HissTools.toPrint(exp) + "`");
					hiss_HaxeTools.println("Callstack depth " + haxe_CallStack.callStack().length);
				}
			}
		}
	}
	,scriptArgs: null
	,load: function(file) {
		this._load(hiss_HValue.List([hiss_HValue.String(file)]),this.emptyEnv(),hiss_CCInterp.noCC);
	}
	,_load: function(args,env,cc) {
		this.readingProgram = true;
		var exps = this.reader.readAll(hiss_HValue.String(hiss_StaticFiles.getContent(hiss_HissTools.value(hiss_HissTools.first(args),this))));
		this.readingProgram = false;
		this.currentBeginFunction(exps,env,cc);
	}
	,envWithReturn: function(env,called) {
		var stackFrameWithReturn = this.emptyDict();
		hiss_HissTools.put(stackFrameWithReturn,"return",hiss_HValue.Function(function(args,env,cc) {
			called.b = true;
			cc(hiss_HissTools.first(args));
		},{ name : "return"}));
		return hiss_HissTools.extend(env,stackFrameWithReturn);
	}
	,envWithBreakContinue: function(env,breakCalled,continueCalled) {
		var stackFrameWithBreakContinue = this.emptyDict();
		hiss_HissTools.put(stackFrameWithBreakContinue,"continue",hiss_HValue.Function(function(_,_1,continueCC) {
			continueCalled.b = true;
			continueCC(hiss_HValue.Nil);
		},{ name : "continue"}));
		hiss_HissTools.put(stackFrameWithBreakContinue,"break",hiss_HValue.Function(function(_,_1,breakCC) {
			breakCalled.b = true;
			breakCC(hiss_HValue.Nil);
		},{ name : "break"}));
		return hiss_HissTools.extend(env,stackFrameWithBreakContinue);
	}
	,trBegin: function(exps,env,cc) {
		var returnCalled = new hiss_RefBool();
		env = this.envWithReturn(env,returnCalled);
		var value = this.eval(hiss_HissTools.first(exps),env);
		if(returnCalled.b || !this.truthy(hiss_Stdlib.rest_h(exps))) {
			cc(value);
		} else {
			this.trBegin(hiss_Stdlib.rest_h(exps),env,cc);
		}
	}
	,begin: function(exps,env,cc) {
		var _gthis = this;
		var returnCalled = new hiss_RefBool();
		env = this.envWithReturn(env,returnCalled);
		this.internalEval(hiss_HissTools.first(exps),env,function(result) {
			if(returnCalled.b || !_gthis.truthy(hiss_Stdlib.rest_h(exps))) {
				cc(result);
			} else {
				_gthis.begin(hiss_Stdlib.rest_h(exps),env,cc);
			}
		});
	}
	,specialForm: function(args,env,cc) {
		var _g = hiss_HissTools.first(args);
		switch(_g._hx_index) {
		case 11:
			var _g1 = _g.meta;
			if(_g1.deprecated) {
				hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Macro " + _g1.name + " is deprecated."));
			}
			_g.f(hiss_Stdlib.rest_h(args),env,cc);
			break;
		case 12:
			var _g1 = _g.meta;
			if(_g1.deprecated) {
				hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Macro " + _g1.name + " is deprecated."));
			}
			_g.f(hiss_Stdlib.rest_h(args),env,cc);
			break;
		default:
			throw haxe_Exception.thrown("" + Std.string(hiss_HissTools.first(args)) + " is not a macro or special form");
		}
	}
	,macroCall: function(args,env,cc) {
		var _gthis = this;
		this.specialForm(args,env,function(expansion) {
			_gthis.internalEval(expansion,env,cc);
		});
	}
	,funcall: function(callInline,args,env,cc) {
		var _gthis = this;
		this.currentEvalAllFunction(args,env,function(values) {
			var _g = hiss_HissTools.first(values);
			if(_g._hx_index == 10) {
				var _g1 = _g.meta;
				if(_g1.deprecated) {
					hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Function " + _g1.name + " is deprecated."));
				}
				_g.f(hiss_Stdlib.rest_h(values),callInline ? env : _gthis.emptyEnv(),cc);
			} else {
				throw haxe_Exception.thrown("Cannot funcall " + Std.string(hiss_HissTools.first(values)));
			}
		});
	}
	,evalAll: function(args,env,cc) {
		var _gthis = this;
		if(!this.truthy(args)) {
			cc(hiss_HValue.Nil);
		} else {
			this.internalEval(hiss_HissTools.first(args),env,function(value) {
				_gthis.evalAll(hiss_Stdlib.rest_h(args),env,function(value2) {
					cc(hiss_Stdlib.cons_h(value,value2));
				});
			});
		}
	}
	,trEvalAll: function(args,env,cc) {
		if(!this.truthy(args)) {
			cc(hiss_HValue.Nil);
		} else {
			var _g = [];
			var _g1 = 0;
			var _g2 = hiss_HissTools.toList(args);
			while(_g1 < _g2.length) _g.push(this.eval(_g2[_g1++],env));
			cc(hiss_HValue.List(_g));
		}
	}
	,set: function(type,args,env,cc) {
		var _gthis = this;
		this.internalEval(hiss_HissTools.second(args),env,function(val) {
			var scope = null;
			switch(type._hx_index) {
			case 0:
				scope = _gthis.globals;
				break;
			case 1:
				scope = hiss_HissTools.first(env);
				break;
			case 2:
				var _g = 0;
				var _g1 = hiss_HissTools.toList(env);
				while(_g < _g1.length) {
					var frame = _g1[_g];
					++_g;
					if(hiss_HissTools.toDict(frame).exists_h(hiss_HissTools.first(args))) {
						scope = frame;
						break;
					}
				}
				if(scope == null) {
					scope = _gthis.globals;
				}
				break;
			}
			hiss_HissTools.put(scope,hiss_Stdlib.symbolName_h(hiss_HissTools.first(args)),val);
			cc(val);
		});
	}
	,setCallable: function(isMacro,args,env,cc) {
		var _gthis = this;
		hiss_SpecialForms.lambda_s(this,hiss_Stdlib.rest_h(args),env,function(fun) {
			_gthis.set(hiss_SetType.Global,hiss_Stdlib.cons_h(hiss_HissTools.first(args),hiss_HValue.List([fun])),env,cc);
		},hiss_Stdlib.symbolName_h(hiss_HissTools.first(args)),isMacro);
	}
	,defAlias: function(args,env,cc) {
		var _gthis = this;
		var func = hiss_HissTools.first(args);
		var alias = hiss_HissTools.second(args);
		var _g = [];
		var _g1 = 0;
		var _g2 = hiss_HissTools.toList(args).slice(2);
		while(_g1 < _g2.length) _g.push(hiss_Stdlib.symbolName_h(_g2[_g1++]));
		var metaSymbols = _g;
		this.internalEval(func,env,function(funcVal) {
			var hFunc = hiss_HissTools.toCallable(funcVal);
			var meta = Reflect.copy(hiss_HissTools.metadata(funcVal));
			meta.name = hiss_Stdlib.symbolName_h(alias);
			if(metaSymbols.indexOf("@deprecated") != -1) {
				meta.deprecated = true;
			}
			var newFunc;
			switch(funcVal._hx_index) {
			case 10:
				newFunc = hiss_HValue.Function(hFunc,meta);
				break;
			case 11:
				newFunc = hiss_HValue.Macro(hFunc,meta);
				break;
			case 12:
				newFunc = hiss_HValue.SpecialForm(hFunc,meta);
				break;
			default:
				throw haxe_Exception.thrown("");
			}
			hiss_HissTools.put(_gthis.globals,hiss_Stdlib.symbolName_h(alias),newFunc);
			cc(newFunc);
		});
	}
	,defDestructiveAlias: function(destructiveName,suffix) {
		this.defAlias(hiss_HValue.List([hiss_HValue.Symbol(destructiveName),hiss_HValue.Symbol(HxOverrides.substr(destructiveName,0,destructiveName.length - suffix.length)),hiss_HValue.Symbol("@deprecated")]),this.emptyEnv(),hiss_CCInterp.noCC);
	}
	,getVar: function(name,env,cc) {
		var stackFrames = hiss_HissTools.toList(env);
		var g = hiss_HissTools.toDict(this.globals);
		var v = null;
		var _g = 0;
		while(_g < stackFrames.length) {
			var frameDict = hiss_HissTools.toDict(stackFrames[_g++]);
			if(frameDict.exists_h(name)) {
				v = frameDict.get_h(name);
				break;
			}
		}
		if(v != null) {
			cc(v);
		} else if(g.exists_h(name)) {
			cc(g.get_h(name));
		} else {
			this.error("" + Std.string(name) + " is undefined");
		}
	}
	,iterable: function(bodyForm,args,env,cc) {
		this.internalEval(bodyForm ? hiss_HissTools.second(args) : hiss_HissTools.first(args),env,cc);
	}
	,performIteration: function(bodyForm,args,env,cc,performFunction) {
		var _gthis = this;
		if(bodyForm) {
			var body = hiss_HValue.List(hiss_HissTools.toList(args).slice(2));
			performFunction(function(innerArgs,innerEnv,innerCC) {
				var bodyEnv = hiss_HissTools.extend(innerEnv,hiss_HissTools.destructuringBind(hiss_HissTools.first(args),_gthis,hiss_HissTools.first(innerArgs)));
				_gthis.internalEval(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),body),bodyEnv,innerCC);
			},env,cc);
		} else {
			this.internalEval(hiss_HissTools.second(args),env,function(fun) {
				performFunction(hiss_HissTools.toHFunction(fun),_gthis.emptyEnv(),cc);
			});
		}
	}
	,iterate: function(collect,bodyForm,args,env,cc) {
		var _gthis = this;
		var it = hiss_HValue.Nil;
		this.iterable(bodyForm,args,env,function(_iterable) {
			it = _iterable;
		});
		var iterable = hiss_HissTools.value(it,this,true);
		this.performIteration(bodyForm,args,env,cc,function(operation,innerEnv,outerCC) {
			var results = [];
			var continueCalled = new hiss_RefBool();
			var breakCalled = new hiss_RefBool();
			innerEnv = _gthis.envWithBreakContinue(innerEnv,breakCalled,continueCalled);
			var iterationCC = collect ? function(result) {
				if(continueCalled.b || breakCalled.b) {
					continueCalled.b = false;
					return;
				}
				results.push(result);
			} : hiss_CCInterp.noCC;
			var value = $getIterator(iterable);
			while(value.hasNext()) {
				operation(hiss_HValue.List([value.next()]),innerEnv,iterationCC);
				if(breakCalled.b) {
					break;
				}
			}
			outerCC(hiss_HValue.List(results));
		});
	}
	,iterateCC: function(collect,bodyForm,args,env,cc) {
		var _gthis = this;
		this.iterable(bodyForm,args,env,function(it) {
			var iterator = $getIterator(hiss_HissTools.value(it,_gthis,true));
			var results = [];
			var continueCalled = new hiss_RefBool();
			var breakCalled = new hiss_RefBool();
			env = _gthis.envWithBreakContinue(env,breakCalled,continueCalled);
			var asynchronousIteration = null;
			asynchronousIteration = function(operation,innerEnv,outerCC) {
				if(!iterator.hasNext()) {
					outerCC(hiss_HValue.List(results));
				} else {
					operation(hiss_HValue.List([iterator.next()]),innerEnv,function(value) {
						if(breakCalled.b) {
							outerCC(hiss_HValue.List(results));
						} else {
							if(collect && !continueCalled.b) {
								results.push(value);
							}
							continueCalled.b = false;
							asynchronousIteration(operation,innerEnv,outerCC);
						}
					});
				}
			};
			_gthis.performIteration(bodyForm,args,env,cc,asynchronousIteration);
		});
	}
	,loop: function(args,env,cc) {
		var _gthis = this;
		var bindings = hiss_HissTools.first(args);
		var body = hiss_Stdlib.rest_h(args);
		var names = hiss_Stdlib.cons_h(hiss_HValue.Symbol("recur"),hiss_HissTools.alternates(bindings,true));
		var firstValueExps = hiss_HissTools.alternates(bindings,false);
		this.currentEvalAllFunction(firstValueExps,env,function(firstValues) {
			var nextValues = hiss_HValue.Nil;
			var recurCalled = false;
			var recur = function(nextValueExps,env,cc) {
				_gthis.currentEvalAllFunction(nextValueExps,env,function(nextVals) {
					nextValues = nextVals;
				});
				recurCalled = true;
			};
			var values = firstValues;
			var result = hiss_HValue.Nil;
			while(true) {
				if(recurCalled) {
					values = nextValues;
					recurCalled = false;
				}
				_gthis.internalEval(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),body),hiss_HissTools.extend(env,hiss_HissTools.destructuringBind(names,_gthis,hiss_Stdlib.cons_h(hiss_HValue.SpecialForm(recur,{ name : "recur"}),values))),function(value) {
					result = value;
				});
				if(!recurCalled) {
					break;
				}
			}
			cc(result);
		});
	}
	,evalUnquotes: function(expr,env) {
		switch(expr._hx_index) {
		case 8:
			var copy = expr.l.slice();
			var idx = 0;
			while(idx < copy.length) {
				var _g = copy[idx];
				switch(_g._hx_index) {
				case 14:
					var _g1 = _g.exp;
					if(_g1._hx_index == 17) {
						copy.splice(idx,1);
						this.internalEval(_g1.exp,env,function(innerList) {
							var _g = 0;
							var _g1 = hiss_HissTools.toList(innerList);
							while(_g < _g1.length) {
								idx += 1;
								copy.splice(idx - 1,0,hiss_HValue.Quote(_g1[_g++]));
							}
							idx -= 1;
						});
					} else {
						var exp = copy[idx];
						copy.splice(idx,1);
						var x = this.evalUnquotes(exp,env);
						copy.splice(idx,0,x);
					}
					break;
				case 17:
					copy.splice(idx,1);
					this.internalEval(_g.exp,env,function(innerList) {
						var _g = 0;
						var _g1 = hiss_HissTools.toList(innerList);
						while(_g < _g1.length) {
							idx += 1;
							copy.splice(idx - 1,0,_g1[_g++]);
						}
						idx -= 1;
					});
					break;
				default:
					var exp1 = copy[idx];
					copy.splice(idx,1);
					var x1 = this.evalUnquotes(exp1,env);
					copy.splice(idx,0,x1);
				}
				idx += 1;
			}
			return hiss_HValue.List(copy);
		case 14:
			return hiss_HValue.Quote(this.evalUnquotes(expr.exp,env));
		case 15:
			return this.evalUnquotes(expr.exp,env);
		case 16:
			var val = hiss_HValue.Nil;
			this.internalEval(expr.exp,env,function(v) {
				val = v;
			});
			return val;
		default:
			return expr;
		}
	}
	,read: function(str) {
		return this.reader.read("",hiss_HStream.FromString(str));
	}
	,readAll: function(str) {
		return this.reader.readAll(hiss_HValue.String(str));
	}
	,_eval: function(args,env,cc) {
		var _gthis = this;
		this.internalEval(hiss_HissTools.first(args),env,function(val) {
			_gthis.internalEval(val,env,cc);
		});
	}
	,'eval': function(arg,env) {
		var value = null;
		if(env == null) {
			env = this.emptyEnv();
		}
		this.internalEval(arg,env,function(_value) {
			value = _value;
		});
		return value;
	}
	,evalCC: function(arg,cc,env) {
		if(env == null) {
			env = this.emptyEnv();
		}
		this.internalEval(arg,env,cc);
	}
	,truthy: function(cond) {
		switch(cond._hx_index) {
		case 5:
			return false;
		case 8:
			if(cond.l.length == 0) {
				return false;
			} else {
				return true;
			}
			break;
		default:
			return true;
		}
	}
	,internalEval: function(exp,env,cc) {
		var _gthis = this;
		switch(exp._hx_index) {
		case 0:
			cc(exp);
			break;
		case 1:
			cc(exp);
			break;
		case 2:
			var stackFrames = hiss_HissTools.toList(env);
			var g = hiss_HissTools.toDict(this.globals);
			var v = null;
			var _g = 0;
			while(_g < stackFrames.length) {
				var frameDict = hiss_HissTools.toDict(stackFrames[_g++]);
				if(frameDict.exists_h(exp)) {
					v = frameDict.get_h(exp);
					break;
				}
			}
			if(v != null) {
				cc(v);
			} else if(g.exists_h(exp)) {
				cc(g.get_h(exp));
			} else {
				this.error("" + Std.string(exp) + " is undefined");
			}
			break;
		case 3:
			var interpolated = exp.value;
			var idx = 0;
			while(interpolated.indexOf("$",idx) != -1) {
				idx = interpolated.indexOf("$",idx);
				if(interpolated.charAt(idx - 1) == "\\") {
					var interpolated1 = HxOverrides.substr(interpolated,0,idx - 1);
					idx += 1;
					interpolated = interpolated1 + HxOverrides.substr(interpolated,idx - 1,null);
					continue;
				}
				var expStream = hiss_HStream.FromString(HxOverrides.substr(interpolated,idx + 1,null));
				var exp1 = null;
				var expLength = [-1];
				if(expStream.peek(1) == "{") {
					expStream.drop("{");
					var _g = expStream.takeUntil(["}"],false,false,true);
					var braceContents;
					if(_g._hx_index == 0) {
						braceContents = _g.v;
					} else {
						throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(expStream.takeUntil(["}"],false,false,true)) + "`");
					}
					expStream = hiss_HStream.FromString(braceContents.output);
					expLength[0] = 2 + expStream.length();
					exp1 = this.reader.read("",expStream);
				} else {
					var startingLength = expStream.length();
					exp1 = this.reader.read("",expStream);
					expLength[0] = startingLength - expStream.length();
				}
				this.internalEval(exp1,env,(function(expLength) {
					return function(val) {
						interpolated = HxOverrides.substr(interpolated,0,idx) + hiss_HissTools.toMessage(val) + HxOverrides.substr(interpolated,idx + 1 + expLength[0],null);
						idx = idx + 1 + hiss_HissTools.toMessage(val).length;
					};
				})(expLength));
			}
			cc(hiss_HValue.String(interpolated));
			break;
		case 4:
			cc(exp);
			break;
		case 5:case 6:case 7:
			cc(exp);
			break;
		case 8:
			this.maxStackDepth = Math.floor(Math.max(this.maxStackDepth,haxe_CallStack.callStack().length));
			this.internalEval(hiss_HissTools.first(exp),env,function(callable) {
				switch(callable._hx_index) {
				case 10:
					var cc1 = cc;
					var _gthis1 = _gthis;
					_gthis.currentEvalAllFunction(exp,env,function(values) {
						var _g = hiss_HissTools.first(values);
						if(_g._hx_index == 10) {
							var _g1 = _g.meta;
							if(_g1.deprecated) {
								hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Function " + _g1.name + " is deprecated."));
							}
							_g.f(hiss_Stdlib.rest_h(values),_gthis1.emptyEnv(),cc1);
						} else {
							throw haxe_Exception.thrown("Cannot funcall " + Std.string(hiss_HissTools.first(values)));
						}
					});
					break;
				case 11:
					var args = hiss_Stdlib.cons_h(callable,hiss_Stdlib.rest_h(exp));
					var env1 = env;
					var cc2 = cc;
					var _gthis2 = _gthis;
					_gthis.specialForm(args,env1,function(expansion) {
						_gthis2.internalEval(expansion,env1,cc2);
					});
					break;
				case 12:
					var args = hiss_Stdlib.cons_h(callable,hiss_Stdlib.rest_h(exp));
					var _g = hiss_HissTools.first(args);
					switch(_g._hx_index) {
					case 11:
						var _g1 = _g.meta;
						if(_g1.deprecated) {
							hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Macro " + _g1.name + " is deprecated."));
						}
						_g.f(hiss_Stdlib.rest_h(args),env,cc);
						break;
					case 12:
						var _g1 = _g.meta;
						if(_g1.deprecated) {
							hiss_Stdlib.message_hd(hiss_HValue.String("Warning! Macro " + _g1.name + " is deprecated."));
						}
						_g.f(hiss_Stdlib.rest_h(args),env,cc);
						break;
					default:
						throw haxe_Exception.thrown("" + Std.string(hiss_HissTools.first(args)) + " is not a macro or special form");
					}
					break;
				default:
					_gthis.error("Hiss cannot call " + Std.string(callable) + " from " + hiss_HissTools.toPrint(hiss_HissTools.first(exp)));
				}
			});
			break;
		case 10:
			cc(exp);
			break;
		case 11:
			cc(exp);
			break;
		case 12:
			cc(exp);
			break;
		case 13:
			cc(exp);
			break;
		case 14:
			cc(exp.exp);
			break;
		case 15:
			var _g = exp.exp;
			var cc1 = cc;
			var tmp;
			switch(_g._hx_index) {
			case 8:
				var copy = _g.l.slice();
				var idx1 = 0;
				while(idx1 < copy.length) {
					var _g1 = copy[idx1];
					switch(_g1._hx_index) {
					case 14:
						var _g2 = _g1.exp;
						if(_g2._hx_index == 17) {
							copy.splice(idx1,1);
							this.internalEval(_g2.exp,env,function(innerList) {
								var _g = 0;
								var _g1 = hiss_HissTools.toList(innerList);
								while(_g < _g1.length) {
									idx1 += 1;
									copy.splice(idx1 - 1,0,hiss_HValue.Quote(_g1[_g++]));
								}
								idx1 -= 1;
							});
						} else {
							var exp1 = copy[idx1];
							copy.splice(idx1,1);
							var x = this.evalUnquotes(exp1,env);
							copy.splice(idx1,0,x);
						}
						break;
					case 17:
						copy.splice(idx1,1);
						this.internalEval(_g1.exp,env,function(innerList) {
							var _g = 0;
							var _g1 = hiss_HissTools.toList(innerList);
							while(_g < _g1.length) {
								idx1 += 1;
								copy.splice(idx1 - 1,0,_g1[_g++]);
							}
							idx1 -= 1;
						});
						break;
					default:
						var exp2 = copy[idx1];
						copy.splice(idx1,1);
						var x1 = this.evalUnquotes(exp2,env);
						copy.splice(idx1,0,x1);
					}
					idx1 += 1;
				}
				tmp = hiss_HValue.List(copy);
				break;
			case 14:
				tmp = hiss_HValue.Quote(this.evalUnquotes(_g.exp,env));
				break;
			case 15:
				tmp = this.evalUnquotes(_g.exp,env);
				break;
			case 16:
				var val = hiss_HValue.Nil;
				this.internalEval(_g.exp,env,function(v) {
					val = v;
				});
				tmp = val;
				break;
			default:
				tmp = _g;
			}
			cc1(tmp);
			break;
		case 16:
			this.internalEval(exp.exp,env,cc);
			break;
		default:
			this.error("Cannot evaluate " + Std.string(exp) + " yet");
		}
	}
	,nativeFunctionMaxArgs: function() {
		return 5;
	}
	,toNativeFunction: function(fun) {
		var _gthis = this;
		if(fun._hx_index == 10) {
			var _g = fun.meta;
			if(_g.argNames != null && _g.argNames.length == 0) {
				return function() {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length == 1) {
				return function(arg1) {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun,hiss_HValue.Quote(hiss_HissTools.toHValue(arg1))]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length == 2) {
				return function(arg1,arg2) {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun,hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg2))]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length == 3) {
				return function(arg1,arg2,arg3) {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun,hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg3))]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length == 4) {
				return function(arg1,arg2,arg3,arg4) {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun,hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg3)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg4))]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length == 5) {
				return function(arg1,arg2,arg3,arg4,arg5) {
					var val = null;
					_gthis.funcall(false,hiss_HValue.List([fun,hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg3)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg4)),hiss_HValue.Quote(hiss_HissTools.toHValue(arg5))]),_gthis.emptyEnv(),function(_val) {
						val = _val;
					});
					return hiss_HissTools.value(val,_gthis,true);
				};
			} else if(_g.argNames != null && _g.argNames.length > 5) {
				throw haxe_Exception.thrown("Function has too many args for conversion to native function");
			} else if(_g.argNames == null) {
				throw haxe_Exception.thrown("Function " + _g.name + " has no args specified, cannot be converted");
			} else {
				throw haxe_Exception.thrown("Cannot convert non-function " + Std.string(fun) + " to native function");
			}
		} else {
			throw haxe_Exception.thrown("Cannot convert non-function " + Std.string(fun) + " to native function");
		}
	}
	,__class__: hiss_CCInterp
};
var hiss_CompileInfo = function() { };
hiss_CompileInfo.__name__ = "hiss.CompileInfo";
var hiss_HDict = function(interp,map) {
	this._map = new haxe_ds_StringMap();
	this._interp = interp;
	if(map != null) {
		this._map = map;
	}
};
hiss_HDict.__name__ = "hiss.HDict";
hiss_HDict.makeDict_cc = function(interp,args,env,cc) {
	var dict = new hiss_HDict(interp);
	var idx = 0;
	while(idx < hiss_Stdlib.length_h(args)) {
		dict.put_hd(hiss_Stdlib.nth_h(args,hiss_HValue.Int(idx)),hiss_Stdlib.nth_h(args,hiss_HValue.Int(idx + 1)));
		idx += 2;
	}
	cc(hiss_HValue.Dict(dict));
};
hiss_HDict.prototype = {
	_map: null
	,_interp: null
	,iterator: function() {
		var kvIterator = this.keyValueIterator();
		return { next : function() {
			var pair = kvIterator.next();
			return hiss_HValue.List([pair.key,pair.value]);
		}, hasNext : function() {
			return kvIterator.hasNext();
		}};
	}
	,keyValueIterator: function() {
		return new hiss_HDictIterator(new haxe_ds__$StringMap_StringMapKeyValueIterator(this._map.h));
	}
	,copy: function() {
		return new hiss_HDict(this._interp,haxe_ds_StringMap.createCopy(this._map.h));
	}
	,get_h: function(key) {
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		if(!Object.prototype.hasOwnProperty.call(this1.h,key1)) {
			return hiss_HValue.Nil;
		}
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		var hashMatches = this1.h[key1];
		var _g = 0;
		while(_g < hashMatches.length) {
			var match = hashMatches[_g];
			++_g;
			if(this._interp.truthy(hiss_Stdlib.eq_ih(this._interp,match.key,key))) {
				return match.value;
			}
		}
		return hiss_HValue.Nil;
	}
	,put_hd: function(key,value) {
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		if(!Object.prototype.hasOwnProperty.call(this1.h,key1)) {
			var this1 = this._map;
			var k = hiss_HissTools.toPrint(key);
			this1.h[k] = [];
		}
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		var hashMatches = this1.h[key1];
		var _g = 0;
		while(_g < hashMatches.length) {
			var match = hashMatches[_g];
			++_g;
			if(this._interp.truthy(hiss_Stdlib.eq_ih(this._interp,match.key,key))) {
				match.value = value;
				return;
			}
		}
		hashMatches.push({ key : key, value : value});
	}
	,exists_h: function(key) {
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		if(!Object.prototype.hasOwnProperty.call(this1.h,key1)) {
			return false;
		}
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		var hashMatches = this1.h[key1];
		var _g = 0;
		while(_g < hashMatches.length) if(this._interp.truthy(hiss_Stdlib.eq_ih(this._interp,hashMatches[_g++].key,key))) {
			return true;
		}
		return false;
	}
	,erase_hd: function(key) {
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		if(!Object.prototype.hasOwnProperty.call(this1.h,key1)) {
			return;
		}
		var this1 = this._map;
		var key1 = hiss_HissTools.toPrint(key);
		var hashMatches = this1.h[key1];
		var idx = 0;
		while(idx < hashMatches.length) {
			if(this._interp.truthy(hiss_Stdlib.eq_ih(this._interp,hashMatches[idx].key,key))) {
				hashMatches.splice(idx,1);
				return;
			}
			++idx;
		}
	}
	,__class__: hiss_HDict
};
var hiss_HDictIterator = function(it) {
	this.hvkIterator = null;
	this.kvIterator = it;
};
hiss_HDictIterator.__name__ = "hiss.HDictIterator";
hiss_HDictIterator.prototype = {
	kvIterator: null
	,hvkIterator: null
	,next: function() {
		if(this.hvkIterator != null && this.hvkIterator.hasNext()) {
			return this.hvkIterator.next();
		}
		if(this.kvIterator.hasNext()) {
			this.hvkIterator = new haxe_iterators_ArrayIterator(this.kvIterator.next().value);
			return this.next();
		}
		return null;
	}
	,hasNext: function() {
		if(this.hvkIterator != null && this.hvkIterator.hasNext()) {
			return true;
		}
		return this.kvIterator.hasNext();
	}
	,__class__: hiss_HDictIterator
};
var hiss_HPosition = function(file,line,column) {
	this.file = file;
	this.line = line;
	this.column = column;
};
hiss_HPosition.__name__ = "hiss.HPosition";
hiss_HPosition.prototype = {
	file: null
	,line: null
	,column: null
	,equals: function(other) {
		if(this.file == other.file && this.line == other.line) {
			return this.column == other.column;
		} else {
			return false;
		}
	}
	,copy: function() {
		return new hiss_HPosition(this.file,this.line,this.column);
	}
	,toString: function() {
		return "" + this.file + ":" + this.line + ":" + this.column;
	}
	,__class__: hiss_HPosition
};
var hiss_HStream = function(path,rawString,line,column) {
	if(column == null) {
		column = 1;
	}
	if(line == null) {
		line = 1;
	}
	if(rawString == null) {
		throw haxe_Exception.thrown("Tried to create buffer of path " + path + " with null contents");
	}
	rawString = StringTools.replace(rawString,"\r","");
	this.rawString = rawString;
	this.pos = new hiss_HPosition(path,line,column);
};
hiss_HStream.__name__ = "hiss.HStream";
hiss_HStream.FromString = function(s,pos) {
	if(pos == null) {
		return new hiss_HStream("!NOTAFILE-" + hiss_HStream.dummyCount++ + "!",s);
	} else {
		return new hiss_HStream(pos.file,s,pos.line,pos.column);
	}
};
hiss_HStream.FromFile = function(path) {
	return new hiss_HStream(path,js_node_Fs.readFileSync(path,{ encoding : "utf8"}));
};
hiss_HStream.prototype = {
	rawString: null
	,pos: null
	,indexOf: function(s,start) {
		if(start == null) {
			start = 0;
		}
		return this.rawString.indexOf(s,start);
	}
	,everyIndexOf: function(s,start) {
		if(start == null) {
			start = 0;
		}
		var _g = [];
		var _g1 = start;
		var _g2 = this.rawString.length;
		while(_g1 < _g2) _g.push(_g1++);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < _g.length) {
			var v = _g[_g2];
			++_g2;
			if(this.rawString.charAt(v) == s) {
				_g1.push(v);
			}
		}
		return _g1;
	}
	,length: function() {
		return this.rawString.length;
	}
	,position: function() {
		return this.pos.copy();
	}
	,peekAhead: function(start,length) {
		return HxOverrides.substr(this.rawString,start,length);
	}
	,peekUntil: function(terminators,eofTerminates,allowEscapedTerminators,_) {
		if(_ == null) {
			_ = false;
		}
		if(allowEscapedTerminators == null) {
			allowEscapedTerminators = true;
		}
		if(eofTerminates == null) {
			eofTerminates = false;
		}
		if(this.rawString.length == 0) {
			return haxe_ds_Option.None;
		}
		var index = this.rawString.length;
		var whichTerminator = "";
		var _g = 0;
		while(_g < terminators.length) {
			var terminator = terminators[_g];
			++_g;
			var nextIndex = this.rawString.indexOf(terminator);
			while(allowEscapedTerminators && nextIndex > 0 && this.rawString.charAt(nextIndex - 1) == "\\") nextIndex = this.rawString.indexOf(terminator,nextIndex + 1);
			if(nextIndex != -1 && nextIndex < index) {
				index = nextIndex;
				whichTerminator = terminator;
			}
		}
		if(index < this.rawString.length) {
			return haxe_ds_Option.Some({ output : HxOverrides.substr(this.rawString,0,index), terminator : whichTerminator});
		} else if(eofTerminates) {
			return haxe_ds_Option.Some({ output : this.rawString, terminator : null});
		} else {
			return haxe_ds_Option.None;
		}
	}
	,toString: function() {
		return "`" + HxOverrides.substr(this.rawString,0,50) + "...`";
	}
	,copy: function() {
		return hiss_HStream.FromString(this.rawString,this.pos);
	}
	,drop: function(s) {
		var next = this.peek(s.length);
		if(next != s) {
			throw haxe_Exception.thrown("Expected to drop `" + s + "` from buffer but found `" + next + "`");
		}
		var lines = hiss_HStream.FromString(next).everyIndexOf("\n").length;
		if(lines > 0) {
			this.pos.line += lines;
			this.pos.column = next.substring(next.lastIndexOf("\n")).length;
		} else {
			this.pos.column += next.length;
		}
		this.rawString = HxOverrides.substr(this.rawString,s.length,null);
	}
	,takeUntil: function(terminators,eofTerminates,allowEscapedTerminators,dropTerminator) {
		if(dropTerminator == null) {
			dropTerminator = true;
		}
		if(allowEscapedTerminators == null) {
			allowEscapedTerminators = true;
		}
		if(eofTerminates == null) {
			eofTerminates = false;
		}
		var _g = this.peekUntil(terminators,eofTerminates,allowEscapedTerminators);
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.v;
			var _g = _g1.terminator;
			var _g2 = _g1.output;
			this.drop(_g2);
			if(dropTerminator && _g != null) {
				this.drop(_g);
			}
			return haxe_ds_Option.Some({ output : _g2, terminator : _g});
		case 1:
			return haxe_ds_Option.None;
		}
	}
	,peek: function(chars) {
		if(this.rawString.length < chars) {
			throw haxe_Exception.thrown("Not enough characters left in buffer.");
		}
		return HxOverrides.substr(this.rawString,0,chars);
	}
	,take: function(chars) {
		var data = this.peek(chars);
		this.drop(data);
		return data;
	}
	,countConsecutive: function(s) {
		var num = 0;
		while(HxOverrides.substr(this.rawString,0,s.length) == s) {
			++num;
			this.drop(s);
		}
		return num;
	}
	,getLine: function(trimmed,retriever) {
		var nextLine = retriever(["\n"],true,true,true);
		switch(nextLine._hx_index) {
		case 0:
			var _g = nextLine.v.output;
			var nextLine = _g;
			if(_g.charAt(_g.length - 1) == "\n") {
				nextLine = HxOverrides.substr(_g,0,-1);
			}
			if(trimmed.indexOf("r") != -1) {
				nextLine = StringTools.rtrim(nextLine);
			}
			if(trimmed.indexOf("l") != -1) {
				nextLine = StringTools.ltrim(nextLine);
			}
			return haxe_ds_Option.Some(nextLine);
		case 1:
			return haxe_ds_Option.None;
		}
	}
	,peekLine: function(trimmed) {
		if(trimmed == null) {
			trimmed = "";
		}
		return this.getLine(trimmed,$bind(this,this.peekUntil));
	}
	,takeLine: function(trimmed) {
		if(trimmed == null) {
			trimmed = "";
		}
		return this.getLine(trimmed,$bind(this,this.takeUntil));
	}
	,takeLineAsStream: function(trimmed) {
		if(trimmed == null) {
			trimmed = "";
		}
		var pos = this.position();
		var _g = this.takeLine(trimmed);
		var tmp;
		if(_g._hx_index == 0) {
			tmp = _g.v;
		} else {
			throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(this.takeLine(trimmed)) + "`");
		}
		return hiss_HStream.FromString(tmp,pos);
	}
	,dropWhileOneOf: function(stringsToDrop,limit) {
		if(limit == null) {
			limit = -1;
		}
		var lengths = new haxe_ds_IntMap();
		var stringsToDropMap_h = Object.create(null);
		var _g = 0;
		while(_g < stringsToDrop.length) {
			var str = stringsToDrop[_g];
			++_g;
			lengths.h[str.length] = true;
			stringsToDropMap_h[str] = true;
		}
		var _g = [];
		var l = lengths.keys();
		while(l.hasNext()) _g.push(l.next());
		_g.sort(Reflect.compare);
		_g.reverse();
		while(limit == -1 || limit-- > 0) {
			var dropped = false;
			var _g1 = 0;
			while(_g1 < _g.length) {
				var l = _g[_g1];
				++_g1;
				if(this.length() >= l) {
					var couldBeOneOf = this.peek(l);
					if(Object.prototype.hasOwnProperty.call(stringsToDropMap_h,couldBeOneOf)) {
						this.drop(couldBeOneOf);
						dropped = true;
						break;
					}
				}
			}
			if(dropped) {
				continue;
			}
			break;
		}
	}
	,dropIfOneOf: function(stringsToDrop) {
		this.dropWhileOneOf(stringsToDrop,1);
	}
	,dropWhitespace: function() {
		this.dropWhileOneOf(hiss_HStream.WHITESPACE);
	}
	,takeUntilWhitespace: function() {
		return this.takeUntil(hiss_HStream.WHITESPACE,true,false);
	}
	,peekUntilWhitespace: function() {
		return this.peekUntil(hiss_HStream.WHITESPACE,true,false);
	}
	,nextIsWhitespace: function() {
		if(this.rawString.length != 0) {
			return hiss_HStream.WHITESPACE.indexOf(this.peek(1)) != -1;
		} else {
			return true;
		}
	}
	,nextIsOneOf: function(a) {
		var _g = 0;
		while(_g < a.length) {
			var s = a[_g];
			++_g;
			if(this.rawString.length >= s.length && this.rawString.indexOf(s) == 0) {
				return true;
			}
		}
		return false;
	}
	,putBack: function(s) {
		this.rawString = s + this.rawString;
		if(s.indexOf("\n") != -1) {
			this.pos.line -= hiss_HStream.FromString(s).everyIndexOf("\n").length;
			this.pos.column = 0;
		} else {
			this.pos.column -= s.length;
		}
	}
	,peekAll: function() {
		return this.rawString;
	}
	,isEmpty: function() {
		return this.rawString.length == 0;
	}
	,__class__: hiss_HStream
};
var hiss_HValue = $hxEnums["hiss.HValue"] = { __ename__:"hiss.HValue",__constructs__:null
	,Int: ($_=function(value) { return {_hx_index:0,value:value,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Int",$_.__params__ = ["value"],$_)
	,Float: ($_=function(value) { return {_hx_index:1,value:value,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Float",$_.__params__ = ["value"],$_)
	,Symbol: ($_=function(name) { return {_hx_index:2,name:name,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Symbol",$_.__params__ = ["name"],$_)
	,InterpString: ($_=function(value) { return {_hx_index:3,value:value,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="InterpString",$_.__params__ = ["value"],$_)
	,String: ($_=function(value) { return {_hx_index:4,value:value,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="String",$_.__params__ = ["value"],$_)
	,Nil: {_hx_name:"Nil",_hx_index:5,__enum__:"hiss.HValue",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:6,__enum__:"hiss.HValue",toString:$estr}
	,T: {_hx_name:"T",_hx_index:7,__enum__:"hiss.HValue",toString:$estr}
	,List: ($_=function(l) { return {_hx_index:8,l:l,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="List",$_.__params__ = ["l"],$_)
	,Dict: ($_=function(n) { return {_hx_index:9,n:n,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Dict",$_.__params__ = ["n"],$_)
	,Function: ($_=function(f,meta) { return {_hx_index:10,f:f,meta:meta,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Function",$_.__params__ = ["f","meta"],$_)
	,Macro: ($_=function(f,meta) { return {_hx_index:11,f:f,meta:meta,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Macro",$_.__params__ = ["f","meta"],$_)
	,SpecialForm: ($_=function(f,meta) { return {_hx_index:12,f:f,meta:meta,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="SpecialForm",$_.__params__ = ["f","meta"],$_)
	,Object: ($_=function(t,v) { return {_hx_index:13,t:t,v:v,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Object",$_.__params__ = ["t","v"],$_)
	,Quote: ($_=function(exp) { return {_hx_index:14,exp:exp,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Quote",$_.__params__ = ["exp"],$_)
	,Quasiquote: ($_=function(exp) { return {_hx_index:15,exp:exp,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Quasiquote",$_.__params__ = ["exp"],$_)
	,Unquote: ($_=function(exp) { return {_hx_index:16,exp:exp,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="Unquote",$_.__params__ = ["exp"],$_)
	,UnquoteList: ($_=function(exp) { return {_hx_index:17,exp:exp,__enum__:"hiss.HValue",toString:$estr}; },$_._hx_name="UnquoteList",$_.__params__ = ["exp"],$_)
	,Comment: {_hx_name:"Comment",_hx_index:18,__enum__:"hiss.HValue",toString:$estr}
};
hiss_HValue.__constructs__ = [hiss_HValue.Int,hiss_HValue.Float,hiss_HValue.Symbol,hiss_HValue.InterpString,hiss_HValue.String,hiss_HValue.Nil,hiss_HValue.Null,hiss_HValue.T,hiss_HValue.List,hiss_HValue.Dict,hiss_HValue.Function,hiss_HValue.Macro,hiss_HValue.SpecialForm,hiss_HValue.Object,hiss_HValue.Quote,hiss_HValue.Quasiquote,hiss_HValue.Unquote,hiss_HValue.UnquoteList,hiss_HValue.Comment];
var hiss_HSignal = $hxEnums["hiss.HSignal"] = { __ename__:"hiss.HSignal",__constructs__:null
	,Quit: {_hx_name:"Quit",_hx_index:0,__enum__:"hiss.HSignal",toString:$estr}
};
hiss_HSignal.__constructs__ = [hiss_HSignal.Quit];
var hiss_RefBool = function() {
	this.b = false;
};
hiss_RefBool.__name__ = "hiss.RefBool";
hiss_RefBool.prototype = {
	b: null
	,__class__: hiss_RefBool
};
var hiss_HaxeTools = function() { };
hiss_HaxeTools.__name__ = "hiss.HaxeTools";
hiss_HaxeTools.print = function(str) {
	process.stdout.write(Std.string(str));
};
hiss_HaxeTools.println = function(str) {
	process.stdout.write(Std.string(str));
	process.stdout.write("\n");
};
hiss_HaxeTools.shellCommand = function(cmd) {
	throw haxe_Exception.thrown("Can't run shell command on non-sys platform.");
};
var hiss_HissReader = function(interp) {
	this.terminators = [")","/*",";","//"];
	this.macroLengths = [];
	this.interp = interp;
	this.readTable = new hiss_HDict(interp);
	this.setDefaultReadFunction(this.hissReadFunction($bind(this,this.readSymbol),"read-symbol"));
	this.internalSetMacroString("\"",$bind(this,this.readString));
	this.internalSetMacroString("#",$bind(this,this.readRawString));
	var numberChars = ["0","1","2","3","4","5","6","7","8","9","0x","0X"];
	var _g = 0;
	while(_g < numberChars.length) this.internalSetMacroString(numberChars[_g++],$bind(this,this.readNumber));
	this.internalSetMacroString("-",$bind(this,this.readSymbolOrSign));
	this.internalSetMacroString("+",$bind(this,this.readSymbolOrSign));
	this.internalSetMacroString(".",$bind(this,this.readSymbolOrSign));
	var _g = $bind(this,this.readDelimitedList);
	var terminator = ")";
	var delimiters = [];
	var eofTerminates = false;
	var blankElements = null;
	this.internalSetMacroString("(",function(start,stream) {
		return _g(terminator,delimiters,eofTerminates,blankElements,start,stream);
	});
	this.internalSetMacroString("`",$bind(this,this.readQuoteExpression));
	this.internalSetMacroString("'",$bind(this,this.readQuoteExpression));
	this.internalSetMacroString(",",$bind(this,this.readQuoteExpression));
	this.internalSetMacroString(",@",$bind(this,this.readQuoteExpression));
	this.internalSetMacroString("/*",$bind(this,this.readBlockComment));
	this.internalSetMacroString("//",$bind(this,this.readLineComment));
	this.internalSetMacroString(";",$bind(this,this.readLineComment));
};
hiss_HissReader.__name__ = "hiss.HissReader";
hiss_HissReader.toStream = function(interp,stringOrStream,pos) {
	var position = pos != null ? hiss_HissTools.value(pos,interp) : null;
	switch(stringOrStream._hx_index) {
	case 4:
		return hiss_HStream.FromString(stringOrStream.value,position);
	case 13:
		if(stringOrStream.t == "HStream") {
			return stringOrStream.v;
		} else {
			throw haxe_Exception.thrown("Cannot make an hstream out of " + Std.string(stringOrStream));
		}
		break;
	default:
		throw haxe_Exception.thrown("Cannot make an hstream out of " + Std.string(stringOrStream));
	}
};
hiss_HissReader.prototype = {
	readTable: null
	,macroLengths: null
	,interp: null
	,copyReadtable: function() {
		return this.readTable.copy();
	}
	,useReadtable: function(table) {
		this.readTable = table;
	}
	,setMacroString: function(s,f) {
		this.readTable.put_hd(hiss_HValue.String(s),f);
		if(this.macroLengths.indexOf(s.length) == -1) {
			this.macroLengths.push(s.length);
		}
		this.macroLengths.sort(function(a,b) {
			return b - a;
		});
		return f;
	}
	,setDefaultReadFunction: function(f) {
		this.readTable.put_hd(hiss_HValue.String(""),f);
	}
	,hissReadFunction: function(f,s) {
		var _gthis = this;
		return hiss_HValue.Function(function(args,env,cc) {
			var start = hiss_HissTools.toHaxeString(hiss_HissTools.first(args));
			var str = hiss_HissReader.toStream(_gthis.interp,hiss_HissTools.second(args));
			cc(f(start,str));
		},{ name : s, argNames : ["start","stream"]});
	}
	,internalSetMacroString: function(s,f) {
		this.readTable.put_hd(hiss_HValue.String(s),this.hissReadFunction(f,"read-" + s));
		if(this.macroLengths.indexOf(s.length) == -1) {
			this.macroLengths.push(s.length);
		}
		this.macroLengths.sort(function(a,b) {
			return b - a;
		});
	}
	,readQuoteExpression: function(start,stream) {
		var expression = this.read("",stream);
		switch(start) {
		case "'":
			return hiss_HValue.Quote(expression);
		case ",":
			return hiss_HValue.Unquote(expression);
		case ",@":
			return hiss_HValue.UnquoteList(expression);
		case "`":
			return hiss_HValue.Quasiquote(expression);
		default:
			throw haxe_Exception.thrown("Not a quote expression");
		}
	}
	,readNumber: function(start,stream) {
		stream.putBack(start);
		var token = this.nextToken(stream);
		if(token.indexOf(".") != -1) {
			return hiss_HValue.Float(parseFloat(token));
		} else {
			return hiss_HValue.Int(Std.parseInt(token));
		}
	}
	,readSymbolOrSign: function(start,stream) {
		if(stream.nextIsWhitespace() || stream.nextIsOneOf(this.terminators)) {
			stream.putBack(start);
			return this.readSymbol("",stream);
		} else {
			return this.readNumber(start,stream);
		}
	}
	,readBlockComment: function(start,stream) {
		stream.takeUntil(["*/"]);
		return hiss_HValue.Comment;
	}
	,readLineComment: function(start,stream) {
		stream.takeLine();
		return hiss_HValue.Comment;
	}
	,readRawString: function(start,str) {
		var pounds = "#";
		while(str.peek(1) == "#") pounds += str.take(1);
		str.drop("\"");
		var terminator = "\"" + pounds;
		var _g = str.takeUntil([terminator],false,false);
		switch(_g._hx_index) {
		case 0:
			return hiss_HValue.String(_g.v.output);
		case 1:
			throw haxe_Exception.thrown("Expected closing " + terminator + " for read-raw-string of " + Std.string(str));
		}
	}
	,readString: function(start,str) {
		var literal = "";
		_hx_loop1: while(true) {
			var outputInfo;
			var _g = str.takeUntil(["\"","\\$","$","\\\\"],false,true,false);
			if(_g._hx_index == 0) {
				outputInfo = _g.v;
			} else {
				throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(str.takeUntil(["\"","\\$","$","\\\\"],false,true,false)) + "`");
			}
			switch(outputInfo.terminator) {
			case "\"":
				literal += outputInfo.output;
				str.drop(outputInfo.terminator);
				break _hx_loop1;
			case "$":
				literal += outputInfo.output + outputInfo.terminator;
				str.drop(outputInfo.terminator);
				var expStream = str.copy();
				var exp = null;
				var expLength = -1;
				var startingLength = expStream.length();
				if(expStream.peek(1) == "{") {
					expStream.drop("{");
					var _g1 = expStream.takeUntil(["}"],false,false,true);
					var braceContents;
					if(_g1._hx_index == 0) {
						braceContents = _g1.v;
					} else {
						throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(expStream.takeUntil(["}"],false,false,true)) + "`");
					}
					expStream = hiss_HStream.FromString(braceContents.output);
					expLength = 2 + expStream.length();
					exp = this.read("",expStream);
				} else {
					exp = this.read("",expStream);
					expLength = startingLength - expStream.length();
				}
				if(exp._hx_index == 2) {
					var _g2 = exp.name;
					if(_g2.charAt(_g2.length - 1) == "\"") {
						--expLength;
					}
				}
				literal += str.take(expLength);
				break;
			case "\\$":
				literal += outputInfo.output + outputInfo.terminator;
				str.drop(outputInfo.terminator);
				break;
			case "\\\\":
				literal += "\\";
				str.drop(outputInfo.terminator);
				break;
			}
		}
		var escaped = literal;
		escaped = hx_strings_Strings.replaceAll(escaped,"\\t","\t");
		escaped = hx_strings_Strings.replaceAll(escaped,"\\n","\n");
		escaped = hx_strings_Strings.replaceAll(escaped,"\\r","\r");
		escaped = hx_strings_Strings.replaceAll(escaped,"\\\"","\"");
		return hiss_HValue.InterpString(escaped);
	}
	,nextToken: function(str) {
		str.dropWhitespace();
		var whitespaceOrTerminator = hiss_HStream.WHITESPACE.concat(this.terminators);
		var token;
		try {
			var _g = str.takeUntil(whitespaceOrTerminator,true,false,false);
			var token1;
			if(_g._hx_index == 0) {
				token1 = _g.v;
			} else {
				throw haxe_Exception.thrown("extraction to `" + "next token" + "` failed on `" + Std.string(str.takeUntil(whitespaceOrTerminator,true,false,false)) + "`");
			}
			token = token1.output;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			token = "";
		}
		if(token == "") {
			throw haxe_Exception.thrown("nextToken() called without a next token in the stream");
		}
		return token;
	}
	,readSymbol: function(start,str) {
		if(str.peek(1) == ")") {
			throw haxe_Exception.thrown("Unmatched closing paren");
		}
		var symbolName = this.nextToken(str);
		if(symbolName.indexOf("{") != -1 || symbolName.indexOf("}") != -1) {
			throw haxe_Exception.thrown("Cannot have braces in symbol " + symbolName);
		}
		if(symbolName == "nil") {
			return hiss_HValue.Nil;
		}
		if(symbolName == "null") {
			return hiss_HValue.Null;
		}
		if(symbolName == "t") {
			return hiss_HValue.T;
		}
		return hiss_HValue.Symbol(symbolName);
	}
	,readDelimitedList: function(terminator,delimiters,eofTerminates,blankElements,start,stream) {
		var oldTerminators = this.terminators.slice();
		var whitespaceForThesePurposes = hiss_HStream.WHITESPACE.slice();
		HxOverrides.remove(whitespaceForThesePurposes,terminator);
		if(delimiters.length == 0) {
			delimiters = hiss_HStream.WHITESPACE.slice();
		} else {
			delimiters = delimiters.slice();
			this.terminators = this.terminators.concat(delimiters);
		}
		this.terminators.push(terminator);
		var values = [];
		while(stream.length() >= terminator.length && stream.peek(terminator.length) != terminator) {
			if(stream.nextIsOneOf(delimiters) || stream.nextIsOneOf([terminator]) || eofTerminates && stream.isEmpty()) {
				if(blankElements != hiss_HValue.Null) {
					values.push(blankElements);
				}
			} else {
				values.push(this.read("",stream));
			}
			stream.dropIfOneOf(delimiters);
			stream.dropWhileOneOf(whitespaceForThesePurposes);
		}
		if(!(eofTerminates && stream.isEmpty())) {
			try {
				stream.drop(terminator);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				throw haxe_Exception.thrown("terminator " + terminator + " not found while reading " + Std.string(delimiters) + " delimited list from " + Std.string(stream));
			}
		}
		this.terminators = oldTerminators;
		return hiss_HValue.List(values);
	}
	,callReadFunction: function(func,start,stream) {
		var pos = stream.position();
		var startingStream = stream.toString();
		try {
			return this.interp.eval(hiss_Stdlib.cons_h(func,hiss_HValue.List([hiss_HValue.String(start),hiss_HValue.Object("HStream",stream)])));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			var endingStream = stream.toString();
			var consumed = HxOverrides.substr(startingStream,0,startingStream.length - endingStream.length);
			if(_g1.indexOf("Reader error") == 0) {
				throw haxe_Exception.thrown(_g1);
			}
			throw haxe_Exception.thrown("Reader error `" + Std.string(_g1) + "` after taking `" + consumed + "` at " + pos.toString());
		}
	}
	,terminators: null
	,read: function(start,stream) {
		stream.dropWhitespace();
		var _g = 0;
		var _g1 = this.macroLengths;
		while(_g < _g1.length) {
			var length = _g1[_g];
			++_g;
			if(stream.length() < length) {
				continue;
			}
			var couldBeAMacro = stream.peek(length);
			if(this.readTable.exists_h(hiss_HValue.String(couldBeAMacro))) {
				stream.drop(couldBeAMacro);
				stream.position();
				var expression = null;
				expression = this.callReadFunction(this.readTable.get_h(hiss_HValue.String(couldBeAMacro)),couldBeAMacro,stream);
				if(expression._hx_index == 18) {
					if(stream.isEmpty()) {
						return hiss_HValue.Nil;
					} else {
						return this.read("",stream);
					}
				} else {
					return expression;
				}
			}
		}
		return this.callReadFunction(this.readTable.get_h(hiss_HValue.String("")),"",stream);
	}
	,readAll: function(str,dropWhitespace,terminators,pos) {
		var stream = hiss_HissReader.toStream(this.interp,str,pos);
		if(dropWhitespace == null) {
			dropWhitespace = hiss_HValue.T;
		}
		var exprs = [];
		while(!stream.isEmpty()) {
			exprs.push(this.read("",stream));
			if(dropWhitespace != hiss_HValue.Nil) {
				stream.dropWhitespace();
			}
		}
		return hiss_HValue.List(exprs);
	}
	,__class__: hiss_HissReader
};
var utest_ui_common_IReport = function() { };
utest_ui_common_IReport.__name__ = "utest.ui.common.IReport";
utest_ui_common_IReport.__isInterface__ = true;
utest_ui_common_IReport.prototype = {
	displaySuccessResults: null
	,displayHeader: null
	,setHandler: null
	,__class__: utest_ui_common_IReport
};
var utest_ui_text_PlainTextReport = function(runner,outputHandler) {
	this.aggregator = new utest_ui_common_ResultAggregator(runner,true);
	runner.onStart.add($bind(this,this.start));
	this.aggregator.onComplete.add($bind(this,this.complete));
	if(null != outputHandler) {
		this.setHandler(outputHandler);
	}
	this.displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults;
	this.displayHeader = utest_ui_common_HeaderDisplayMode.AlwaysShowHeader;
};
utest_ui_text_PlainTextReport.__name__ = "utest.ui.text.PlainTextReport";
utest_ui_text_PlainTextReport.__interfaces__ = [utest_ui_common_IReport];
utest_ui_text_PlainTextReport.prototype = {
	displaySuccessResults: null
	,displayHeader: null
	,handler: null
	,aggregator: null
	,newline: null
	,indent: null
	,setHandler: function(handler) {
		this.handler = handler;
	}
	,startTime: null
	,start: function(e) {
		this.startTime = this.getTime();
	}
	,getTime: function() {
		var hrtime = process.hrtime();
		return hrtime[0] + hrtime[1] / 1e9;
	}
	,indents: function(c) {
		var s = "";
		while(--c >= 0) s += this.indent;
		return s;
	}
	,dumpStack: function(stack) {
		if(stack.length == 0) {
			return "";
		}
		var parts = haxe_CallStack.toString(stack).split("\n");
		var r = [];
		var _g = 0;
		while(_g < parts.length) {
			var part = parts[_g];
			++_g;
			if(part.indexOf(" utest.") >= 0) {
				continue;
			}
			r.push(part);
		}
		return r.join(this.newline);
	}
	,addHeader: function(buf,result) {
		if(!utest_ui_common_ReportTools.hasHeader(this,result.stats)) {
			return;
		}
		var time = ((this.getTime() - this.startTime) * 1000 | 0) / 1000;
		buf.b += Std.string("\nassertations: " + result.stats.assertations + this.newline);
		buf.b += Std.string("successes: " + result.stats.successes + this.newline);
		buf.b += Std.string("errors: " + result.stats.errors + this.newline);
		buf.b += Std.string("failures: " + result.stats.failures + this.newline);
		buf.b += Std.string("warnings: " + result.stats.warnings + this.newline);
		buf.b += Std.string("execution time: " + time + this.newline);
		buf.b += Std.string(this.newline);
		buf.b += Std.string("results: " + (result.stats.isOk ? "ALL TESTS OK (success: true)" : "SOME TESTS FAILURES (success: false)"));
		buf.b += Std.string(this.newline);
	}
	,result: null
	,getResults: function() {
		var buf = new StringBuf();
		this.addHeader(buf,this.result);
		var _g = 0;
		var _g1 = this.result.packageNames();
		while(_g < _g1.length) {
			var pname = _g1[_g];
			++_g;
			var pack = this.result.getPackage(pname);
			if(utest_ui_common_ReportTools.skipResult(this,pack.stats,this.result.stats.isOk)) {
				continue;
			}
			var _g2 = 0;
			var _g3 = pack.classNames();
			while(_g2 < _g3.length) {
				var cname = _g3[_g2];
				++_g2;
				var cls = pack.getClass(cname);
				if(utest_ui_common_ReportTools.skipResult(this,cls.stats,this.result.stats.isOk)) {
					continue;
				}
				buf.b += Std.string((pname == "" ? "" : pname + ".") + cname + this.newline);
				var _g4 = 0;
				var _g5 = cls.methodNames();
				while(_g4 < _g5.length) {
					var mname = _g5[_g4];
					++_g4;
					var fix = cls.get(mname);
					if(utest_ui_common_ReportTools.skipResult(this,fix.stats,this.result.stats.isOk)) {
						continue;
					}
					var x = this.indents(1) + mname + ": ";
					buf.b += Std.string(x);
					if(fix.stats.isOk) {
						buf.b += "OK ";
					} else if(fix.stats.hasErrors) {
						buf.b += "ERROR ";
					} else if(fix.stats.hasFailures) {
						buf.b += "FAILURE ";
					} else if(fix.stats.hasWarnings) {
						buf.b += "WARNING ";
					}
					var messages = "";
					var _g6 = fix.iterator();
					while(_g6.head != null) {
						var val = _g6.head.item;
						_g6.head = _g6.head.next;
						switch(val._hx_index) {
						case 0:
							buf.b += ".";
							break;
						case 1:
							buf.b += "F";
							messages += this.indents(2) + "line: " + val.pos.lineNumber + ", " + val.msg + this.newline;
							break;
						case 2:
							buf.b += "E";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 3:
							buf.b += "S";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 4:
							buf.b += "T";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 5:
							buf.b += "O";
							messages += this.indents(2) + "missed async calls: " + val.missedAsyncs + this.dumpStack(val.stack) + this.newline;
							break;
						case 6:
							buf.b += "A";
							messages += this.indents(2) + Std.string(val.e) + this.dumpStack(val.stack) + this.newline;
							break;
						case 7:
							buf.b += "W";
							messages += this.indents(2) + val.msg + this.newline;
							break;
						case 8:
							var _g7 = val.reason;
							buf.b += "I";
							if(_g7 != null && _g7 != "") {
								messages += this.indents(2) + ("With reason: " + _g7) + this.newline;
							}
							break;
						}
					}
					buf.b = (buf.b += Std.string(this.newline)) + (messages == null ? "null" : "" + messages);
				}
			}
		}
		return buf.b;
	}
	,complete: function(result) {
		this.result = result;
		if(this.handler != null) {
			this.handler(this);
		}
		if(typeof phantom != "undefined") {
			var tmp = result.stats.isOk ? 0 : 1;
			phantom.exit(tmp);
		}
		if(typeof process != "undefined") {
			var tmp = result.stats.isOk ? 0 : 1;
			process.exit(tmp);
		}
	}
	,__class__: utest_ui_text_PlainTextReport
};
var utest_ui_text_PrintReport = function(runner) {
	utest_ui_text_PlainTextReport.call(this,runner,$bind(this,this._handler));
	this.newline = "\n";
	this.indent = "  ";
};
utest_ui_text_PrintReport.__name__ = "utest.ui.text.PrintReport";
utest_ui_text_PrintReport.__super__ = utest_ui_text_PlainTextReport;
utest_ui_text_PrintReport.prototype = $extend(utest_ui_text_PlainTextReport.prototype,{
	_handler: function(report) {
		this._trace(report.getResults());
	}
	,_trace: function(s) {
		s = StringTools.replace(s,"  ",this.indent);
		s = StringTools.replace(s,"\n",this.newline);
		haxe_Log.trace(s,{ fileName : "utest/ui/text/PrintReport.hx", lineNumber : 52, className : "utest.ui.text.PrintReport", methodName : "_trace"});
	}
	,__class__: utest_ui_text_PrintReport
});
var hiss_NoExitReport = function(runner) {
	utest_ui_text_PrintReport.call(this,runner);
};
hiss_NoExitReport.__name__ = "hiss.NoExitReport";
hiss_NoExitReport.__super__ = utest_ui_text_PrintReport;
hiss_NoExitReport.prototype = $extend(utest_ui_text_PrintReport.prototype,{
	complete: function(result) {
		this.result = result;
		if(this.handler != null) {
			this.handler(this);
		}
		if(!result.stats.isOk) {
			if(typeof phantom != "undefined") {
				phantom.exit(1);
			}
			if(typeof process != "undefined") {
				process.exit(1);
			}
		}
	}
	,__class__: hiss_NoExitReport
});
var utest_ITest = function() { };
utest_ITest.__name__ = "utest.ITest";
utest_ITest.__isInterface__ = true;
var utest_Test = function() {
};
utest_Test.__name__ = "utest.Test";
utest_Test.__interfaces__ = [utest_ITest];
utest_Test.prototype = {
	__initializeUtest__: function() {
		return { tests : [], dependencies : [], accessories : { }};
	}
	,__class__: utest_Test
};
var hiss_HissTestCase = function(hissFile) {
	this.expressions = null;
	this.ignoreFunctions = [];
	utest_Test.call(this);
	this.file = hissFile;
	hiss_HissTestCase.reallyTrace = haxe_Log.trace;
};
hiss_HissTestCase.__name__ = "hiss.HissTestCase";
hiss_HissTestCase.testAtRuntime = function(interp,args,env,cc) {
	var instance = new hiss_HissTestCase(null);
	instance.interp = interp;
	instance.expressions = args;
	var runner = new utest_Runner();
	runner.addCase(instance);
	new hiss_NoExitReport(runner);
	runner.run();
	cc(hiss_HValue.Nil);
};
hiss_HissTestCase.hissTest = function(interp,args,env,cc) {
	hiss_HissTestCase.failOnTrace(interp);
	var functionsCoveredByUnit;
	var _g = hiss_HissTools.first(args);
	switch(_g._hx_index) {
	case 2:
		functionsCoveredByUnit = [_g.name];
		break;
	case 8:
		var _g1 = _g.l;
		var _g = [];
		var _g2 = 0;
		while(_g2 < _g1.length) _g.push(hiss_Stdlib.symbolName_h(_g1[_g2++]));
		functionsCoveredByUnit = _g;
		break;
	default:
		throw haxe_Exception.thrown("Bad syntax for (test) statement");
	}
	if(hiss_HissTestCase.printTestCommands) {
		var v = functionsCoveredByUnit.toString();
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
	}
	var assertions = hiss_Stdlib.rest_h(args);
	var freshEnv = interp.emptyEnv();
	var _g = 0;
	var _g1 = hiss_HissTools.toList(assertions);
	while(_g < _g1.length) {
		var ass = _g1[_g];
		++_g;
		var failureMessage = "Failure testing " + Std.string(functionsCoveredByUnit) + ": " + hiss_HissTools.toPrint(ass) + " evaluated to: ";
		var errorMessage = "Error testing " + Std.string(functionsCoveredByUnit) + ": " + hiss_HissTools.toPrint(ass) + ": ";
		try {
			var val = interp.eval(ass,freshEnv);
			utest_Assert.isTrue(interp.truthy(val),failureMessage + hiss_HissTools.toPrint(val),{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 112, className : "hiss.HissTestCase", methodName : "hissTest"});
		} catch( _g2 ) {
			haxe_NativeStackTrace.lastError = _g2;
			utest_Assert.fail(errorMessage + Std.string(haxe_Exception.caught(_g2).unwrap().toString()),{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 116, className : "hiss.HissTestCase", methodName : "hissTest"});
		}
	}
	var _g = 0;
	while(_g < functionsCoveredByUnit.length) hiss_HissTestCase.functionsTested.h[functionsCoveredByUnit[_g++]] = true;
	hiss_HissTestCase.enableTrace(interp);
	cc(hiss_HValue.Nil);
};
hiss_HissTestCase.hissPrints = function(interp,args,env,cc) {
	var expectedPrint = hiss_HissTools.toHaxeString(interp.eval(hiss_HissTools.first(args),env));
	var expression = hiss_HissTools.second(args);
	var actualPrint = "";
	interp.importFunction(hiss_HissTestCase,function(val) {
		actualPrint += hiss_HissTools.toPrint(val) + "\n";
		return actualPrint;
	},{ name : "print"},hiss_HValue.T);
	interp.importFunction(hiss_HissTestCase,function(val) {
		actualPrint += hiss_HissTools.toPrint(val) + "\n";
		return actualPrint;
	},{ name : "print!"},hiss_HValue.T);
	interp.importFunction(hiss_HissTestCase,function(val) {
		actualPrint += hiss_HissTools.toMessage(val) + "\n";
		return actualPrint;
	},{ name : "message"},hiss_HValue.T);
	interp.importFunction(hiss_HissTestCase,function(val) {
		actualPrint += hiss_HissTools.toMessage(val) + "\n";
		return actualPrint;
	},{ name : "message!"},hiss_HValue.T);
	interp.eval(expression,env);
	interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,{ name : "print"},hiss_HValue.T);
	interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,{ name : "print!"},hiss_HValue.T);
	interp.importFunction(hiss_HissTools,hiss_Stdlib.message_hd,{ name : "message"},hiss_HValue.T);
	interp.importFunction(hiss_HissTools,hiss_Stdlib.message_hd,{ name : "message!"},hiss_HValue.T);
	var tmp;
	if(expectedPrint == actualPrint || actualPrint.charAt(actualPrint.length - 1) == "\n" && expectedPrint == HxOverrides.substr(actualPrint,0,actualPrint.length - 1)) {
		tmp = hiss_HValue.T;
	} else {
		haxe_Log.trace("\"" + actualPrint + "\" != \"" + expectedPrint + "\"",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 164, className : "hiss.HissTestCase", methodName : "hissPrints"});
		tmp = hiss_HValue.Nil;
	}
	cc(tmp);
};
hiss_HissTestCase.hissPrintFail = function(v) {
	if(!hiss_HissTestCase.printTestCommands) {
		utest_Assert.fail("Tried to print " + hiss_HissTools.toPrint(v) + " unnecessarily",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 174, className : "hiss.HissTestCase", methodName : "hissPrintFail"});
	} else {
		var v1 = hiss_HissTools.toPrint(v);
		process.stdout.write(Std.string(v1));
		process.stdout.write("\n");
	}
	return v;
};
hiss_HissTestCase.failOnTrace = function(interp) {
	hiss_HissTestCase.tempTrace = haxe_Log.trace;
	haxe_Log.trace = function(str,posInfo) {
		try {
			if(!hiss_HissTestCase.printTestCommands) {
				utest_Assert.fail("Traced " + str + " to console",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 198, className : "hiss.HissTestCase", methodName : "failOnTrace"});
			} else {
				hiss_HissTestCase.tempTrace(str,posInfo);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			hiss_HissTestCase.tempTrace(str,posInfo);
		}
	};
	if(interp != null) {
		interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,{ name : "print"},hiss_HValue.T);
		interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,{ name : "print!"},hiss_HValue.T);
	}
};
hiss_HissTestCase.enableTrace = function(interp) {
	haxe_Log.trace = hiss_HissTestCase.tempTrace;
	interp.importFunction(hiss_HissTools,hiss_Stdlib.print_hd,{ name : "print"},hiss_HValue.T);
	interp.importFunction(hiss_HissTools,hiss_Stdlib.print_hd,{ name : "print!"},hiss_HValue.T);
};
hiss_HissTestCase.__super__ = utest_Test;
hiss_HissTestCase.prototype = $extend(utest_Test.prototype,{
	interp: null
	,file: null
	,ignoreFunctions: null
	,expressions: null
	,testStdlib: function() {
		var _gthis = this;
		if(this.file == null) {
			hiss_HissTestCase.hissTest(this.interp,this.expressions,this.interp.emptyEnv(),hiss_CCInterp.noCC);
		} else {
			haxe_Log.trace("Measuring time to construct the Hiss environment:",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 230, className : "hiss.HissTestCase", methodName : "testStdlib"});
			this.interp = haxe_Timer.measure(function() {
				hiss_HissTestCase.failOnTrace();
				var i = new hiss_CCInterp(hiss_HissTestCase.hissPrintFail);
				hiss_HissTestCase.enableTrace(i);
				return i;
			},{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 231, className : "hiss.HissTestCase", methodName : "testStdlib"});
			var _g = hiss_HissTools.toDict(this.interp.globals).keyValueIterator();
			while(_g.hasNext()) {
				var _g1 = _g.next();
				var v = _g1.key;
				switch(_g1.value._hx_index) {
				case 10:
					var this1 = hiss_HissTestCase.functionsTested;
					var key = hiss_Stdlib.symbolName_h(v);
					if(!Object.prototype.hasOwnProperty.call(this1.h,key)) {
						var this2 = hiss_HissTestCase.functionsTested;
						var k = hiss_Stdlib.symbolName_h(v);
						this2.h[k] = false;
					}
					break;
				case 11:
					var this3 = hiss_HissTestCase.functionsTested;
					var key1 = hiss_Stdlib.symbolName_h(v);
					if(!Object.prototype.hasOwnProperty.call(this3.h,key1)) {
						var this4 = hiss_HissTestCase.functionsTested;
						var k1 = hiss_Stdlib.symbolName_h(v);
						this4.h[k1] = false;
					}
					break;
				case 12:
					var this5 = hiss_HissTestCase.functionsTested;
					var key2 = hiss_Stdlib.symbolName_h(v);
					if(!Object.prototype.hasOwnProperty.call(this5.h,key2)) {
						var this6 = hiss_HissTestCase.functionsTested;
						var k2 = hiss_Stdlib.symbolName_h(v);
						this6.h[k2] = false;
					}
					break;
				default:
				}
			}
			var interp = this.interp;
			var tmp = hiss_HValue.SpecialForm(function(args,env,cc) {
				hiss_HissTestCase.hissTest(interp,args,env,cc);
			},{ name : "test!"});
			hiss_HissTools.put(this.interp.globals,"test!",tmp);
			this.interp.defDestructiveAlias("test!","!");
			var interp1 = this.interp;
			var tmp = hiss_HValue.SpecialForm(function(args,env,cc) {
				hiss_HissTestCase.hissPrints(interp1,args,env,cc);
			},{ name : "prints"});
			hiss_HissTools.put(this.interp.globals,"prints",tmp);
			var _g = 0;
			var _g1 = this.ignoreFunctions;
			while(_g < _g1.length) hiss_HissTestCase.functionsTested.h[_g1[_g++]] = true;
			haxe_Log.trace("Measuring time taken to run the unit tests:",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 257, className : "hiss.HissTestCase", methodName : "testStdlib"});
			haxe_Timer.measure(function() {
				_gthis.interp.load(_gthis.file);
				haxe_Log.trace("Total time to run tests:",{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 261, className : "hiss.HissTestCase", methodName : "testStdlib"});
			},{ fileName : "src/hiss/HissTestCase.hx", lineNumber : 259, className : "hiss.HissTestCase", methodName : "testStdlib"});
			var _g = [];
			var h = hiss_HissTestCase.functionsTested.h;
			var _g3_keys = Object.keys(h);
			var _g3_length = _g3_keys.length;
			var _g3_current = 0;
			while(_g3_current < _g3_length) {
				var key = _g3_keys[_g3_current++];
				if(!h[key]) {
					_g.push(key);
				}
			}
		}
	}
	,__initializeUtest__: function() {
		var _gthis = this;
		var init = utest_Test.prototype.__initializeUtest__.call(this);
		init.tests.push({ name : "testStdlib", dependencies : [], execute : function() {
			_gthis.testStdlib();
			return utest_Async.getResolved();
		}});
		return init;
	}
	,__class__: hiss_HissTestCase
});
var hiss_HissTools = $hx_exports["hiss"]["HissTools"] = function() { };
hiss_HissTools.__name__ = "hiss.HissTools";
hiss_HissTools.get = function(dict,key) {
	return hiss_HissTools.toDict(dict).get_h(hiss_HValue.Symbol(key));
};
hiss_HissTools.exists = function(dict,key) {
	return hiss_HissTools.toDict(dict).exists_h(hiss_HValue.Symbol(key));
};
hiss_HissTools.put = function(dict,key,v) {
	hiss_HissTools.toDict(dict).put_hd(hiss_HValue.Symbol(key),v);
	return dict;
};
hiss_HissTools.toList = function(list,hint) {
	if(hint == null) {
		hint = "list";
	}
	if(list._hx_index == 8) {
		return list.l;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "list" + "` failed on `" + Std.string(list) + "`");
	}
};
hiss_HissTools.toObject = function(obj,hint) {
	if(hint == null) {
		hint = "object";
	}
	if(obj._hx_index == 13) {
		return obj.v;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "object" + "` failed on `" + Std.string(obj) + "`");
	}
};
hiss_HissTools.toCallable = function(f,hint) {
	if(hint == null) {
		hint = "function";
	}
	switch(f._hx_index) {
	case 10:
		return f.f;
	case 11:
		return f.f;
	case 12:
		return f.f;
	default:
		throw haxe_Exception.thrown("extraction to `" + hint + "` failed on `" + Std.string(f) + "`");
	}
};
hiss_HissTools.toHaxeString = function(hv) {
	if(hv._hx_index == 4) {
		return hv.value;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "string" + "` failed on `" + Std.string(hv) + "`");
	}
};
hiss_HissTools.toInt = function(v) {
	if(v._hx_index == 0) {
		return v.value;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "int" + "` failed on `" + Std.string(v) + "`");
	}
};
hiss_HissTools.toFloat = function(v) {
	switch(v._hx_index) {
	case 0:
		return v.value;
	case 1:
		return v.value;
	default:
		throw haxe_Exception.thrown("can't extract float from " + Std.string(v));
	}
};
hiss_HissTools.toHFunction = function(hv) {
	if(hv._hx_index == 10) {
		return hv.f;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "function" + "` failed on `" + Std.string(hv) + "`");
	}
};
hiss_HissTools.toDict = function(dict) {
	if(dict._hx_index == 9) {
		return dict.n;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "dict" + "` failed on `" + Std.string(dict) + "`");
	}
};
hiss_HissTools.first = function(list) {
	return hiss_HissTools.toList(list)[0];
};
hiss_HissTools.second = function(list) {
	return hiss_HissTools.toList(list)[1];
};
hiss_HissTools.third = function(list) {
	return hiss_HissTools.toList(list)[2];
};
hiss_HissTools.fourth = function(list) {
	return hiss_HissTools.toList(list)[3];
};
hiss_HissTools.last = function(list) {
	return hiss_Stdlib.nth_h(list,hiss_HValue.Int(hiss_Stdlib.length_h(list) - 1));
};
hiss_HissTools.slice = function(list,idx) {
	return hiss_HValue.List(hiss_HissTools.toList(list).slice(idx));
};
hiss_HissTools.alternates = function(list,start) {
	var result = [];
	var l = hiss_HissTools.toList(list).slice();
	while(l.length > 0) {
		var next = l.shift();
		if(start) {
			result.push(next);
		}
		start = !start;
	}
	return hiss_HValue.List(result);
};
hiss_HissTools.dictExtend = function(dict,extension) {
	var extended = hiss_HissTools.toDict(dict).copy();
	var pair = hiss_HissTools.toDict(extension).keyValueIterator();
	while(pair.hasNext()) {
		var pair1 = pair.next();
		extended.put_hd(pair1.key,pair1.value);
	}
	return hiss_HValue.Dict(extended);
};
hiss_HissTools.extend = function(env,extension) {
	return hiss_Stdlib.cons_h(extension,env);
};
hiss_HissTools.destructuringBind = function(names,interp,values) {
	var bindings = interp.emptyDict();
	switch(names._hx_index) {
	case 2:
		hiss_HissTools.put(bindings,names.name,values);
		break;
	case 8:
		var _g = names.l;
		var l2 = hiss_HissTools.toList(values);
		var _g1 = 0;
		var _g2 = _g.length;
		_hx_loop1: while(_g1 < _g2) {
			var idx = _g1++;
			var _g3 = _g[idx];
			switch(_g3._hx_index) {
			case 2:
				var _g4 = _g3.name;
				switch(_g4) {
				case "&optional":
					var numOptionalValues = _g.length - idx - 1;
					var remainingValues = l2.slice(idx);
					while(remainingValues.length < numOptionalValues) remainingValues.push(hiss_HValue.Nil);
					bindings = hiss_HissTools.dictExtend(bindings,hiss_HissTools.destructuringBind(hiss_HValue.List(_g.slice(idx + 1)),interp,hiss_HValue.List(remainingValues)));
					break _hx_loop1;
				case "&rest":
					var remainingValues1 = l2.slice(idx);
					hiss_HissTools.put(bindings,hiss_Stdlib.symbolName_h(_g[idx + 1]),hiss_HValue.List(remainingValues1));
					break _hx_loop1;
				default:
					hiss_HissTools.put(bindings,_g4,l2[idx]);
				}
				break;
			case 8:
				bindings = hiss_HissTools.dictExtend(bindings,hiss_HissTools.destructuringBind(_g[idx],interp,l2[idx]));
				break;
			default:
				throw haxe_Exception.thrown("Bad element " + Std.string(_g[idx]) + " in name list for bindings");
			}
		}
		break;
	default:
		throw haxe_Exception.thrown("Cannot perform destructuring bind on " + hiss_HissTools.toPrint(names) + " and " + hiss_HissTools.toPrint(values));
	}
	return bindings;
};
hiss_HissTools.toHValue = function(v,hint) {
	if(hint == null) {
		hint = "HValue";
	}
	while(true) {
		if(v == null) {
			return hiss_HValue.Nil;
		}
		var t = Type.typeof(v);
		switch(t._hx_index) {
		case 1:
			return hiss_HValue.Int(v);
		case 2:
			return hiss_HValue.Float(v);
		case 3:
			if(v) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 4:
			return hiss_HValue.Object("!ANONYMOUS!",v);
		case 5:
			return hiss_HValue.Object("NativeFun",v);
		case 6:
			var c = t.c;
			var name = c.__name__;
			switch(name) {
			case "Array":
				var va = js_Boot.__cast(v , Array);
				var _g = [];
				var _g1 = 0;
				while(_g1 < va.length) _g.push(hiss_HissTools.toHValue(va[_g1++]));
				return hiss_HValue.List(_g);
			case "String":
				return hiss_HValue.String(v);
			case "hiss.HDict":
				return hiss_HValue.Dict(v);
			default:
				return hiss_HValue.Object(name,v);
			}
			break;
		case 7:
			var e = t.e;
			var name1 = e.__ename__;
			switch(name1) {
			case "haxe.ds.Option":
				var _g2 = js_Boot.__cast(v , haxe_ds_Option);
				switch(_g2._hx_index) {
				case 0:
					v = _g2.v;
					hint = "HValue";
					continue;
				case 1:
					return hiss_HValue.Nil;
				}
				break;
			case "hiss.HValue":
				return js_Boot.__cast(v , hiss_HValue);
			default:
				return hiss_HValue.Object(name1,e);
			}
			break;
		default:
			throw haxe_Exception.thrown("value " + Std.string(v) + " of type " + Std.string(t) + " cannot be wrapped as " + hint);
		}
	}
};
hiss_HissTools.unwrapList = function(hl,interp,keepWrapped) {
	if(keepWrapped == null) {
		keepWrapped = hiss_HValue.Nil;
	}
	var indices;
	if(keepWrapped == hiss_HValue.Nil) {
		indices = [];
	} else if(keepWrapped == hiss_HValue.T) {
		var _g = [];
		var _g1 = 0;
		var _g2 = hiss_HissTools.toList(hl).length;
		while(_g1 < _g2) _g.push(_g1++);
		indices = _g;
	} else {
		indices = hiss_HissTools.unwrapList(keepWrapped,interp);
	}
	var idx = 0;
	var _g = [];
	var _g1 = 0;
	var _g2 = hiss_HissTools.toList(hl);
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(indices.indexOf(idx++) != -1) {
			_g.push(v);
		} else {
			_g.push(hiss_HissTools.value(v,interp));
		}
	}
	return _g;
};
hiss_HissTools.toHList = function(l) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < l.length) _g.push(hiss_HissTools.toHValue(l[_g1++]));
	return hiss_HValue.List(_g);
};
hiss_HissTools.value = function(hv,interp,reference) {
	if(reference == null) {
		reference = false;
	}
	if(interp == null) {
		haxe_Log.trace(hv,{ fileName : "src/hiss/HissTools.hx", lineNumber : 249, className : "hiss.HissTools", methodName : "value"});
	}
	if(hv == null) {
		return hiss_HValue.Nil;
	}
	switch(hv._hx_index) {
	case 0:
		return hv.value;
	case 1:
		return hv.value;
	case 4:
		return hv.value;
	case 5:case 7:
		return interp.truthy(hv);
	case 6:
		return null;
	case 8:
		var _g = hv.l;
		if(reference) {
			return _g;
		} else {
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < _g.length) _g1.push(hiss_HissTools.value(_g[_g2++],interp,true));
			return _g1;
		}
		break;
	case 9:
		return hv.n;
	case 10:
		return interp.toNativeFunction(hv);
	case 13:
		return hv.v;
	default:
		return hv;
	}
};
hiss_HissTools.metadata = function(callable) {
	switch(callable._hx_index) {
	case 10:
		return callable.meta;
	case 11:
		return callable.meta;
	case 12:
		return callable.meta;
	default:
		throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(callable) + "`");
	}
};
hiss_HissTools.toPrint = function(v) {
	return hiss_Stdlib.toPrint_h(v);
};
hiss_HissTools.toMessage = function(v) {
	return hiss_Stdlib.toMessage_h(v);
};
var hiss_NativeFunctions = function() { };
hiss_NativeFunctions.__name__ = "hiss.NativeFunctions";
var hiss_SpecialForms = function() { };
hiss_SpecialForms.__name__ = "hiss.SpecialForms";
hiss_SpecialForms.if_s = function(interp,args,env,cc) {
	if(hiss_Stdlib.length_h(args) > 3) {
		interp.error("(if) called with too many arguments. Try wrapping the cases in (begin)");
	}
	interp.evalCC(hiss_HissTools.first(args),function(val) {
		if(interp.truthy(val)) {
			interp.evalCC(hiss_HissTools.second(args),cc,env);
		} else if(hiss_Stdlib.length_h(args) > 2) {
			interp.evalCC(hiss_HissTools.third(args),cc,env);
		} else {
			cc(hiss_HValue.Nil);
		}
	},env);
};
hiss_SpecialForms.lambda_s = function(interp,args,env,cc,name,isMacro) {
	if(isMacro == null) {
		isMacro = false;
	}
	if(name == null) {
		name = "[anonymous lambda]";
	}
	var params = hiss_HissTools.first(args);
	var _g = [];
	var _g1 = 0;
	var _g2 = hiss_HissTools.toList(params);
	while(_g1 < _g2.length) {
		var paramSymbol = _g2[_g1++];
		var meta;
		try {
			meta = hiss_Stdlib.symbolName_h(paramSymbol);
		} catch( _g3 ) {
			haxe_NativeStackTrace.lastError = _g3;
			meta = "[nested list]";
		}
		_g.push(meta);
	}
	var meta = { name : name, argNames : _g, docstring : "", deprecated : false, async : false};
	var body = hiss_HissTools.toList(hiss_Stdlib.rest_h(args));
	var _g = 0;
	_hx_loop2: while(_g < body.length) {
		var exp = body[_g];
		++_g;
		switch(exp._hx_index) {
		case 2:
			switch(exp.name) {
			case "@async":
				meta.async = true;
				body.shift();
				break;
			case "@deprecated":
				meta.deprecated = true;
				body.shift();
				break;
			default:
				break _hx_loop2;
			}
			break;
		case 3:
			meta.docstring = exp.value;
			body.shift();
			break;
		case 4:
			meta.docstring = exp.value;
			body.shift();
			break;
		default:
			break _hx_loop2;
		}
	}
	var hFun = function(fArgs,innerEnv,fCC) {
		var callEnv = hiss_HValue.List(hiss_HissTools.toList(env).concat(hiss_HissTools.toList(innerEnv)));
		callEnv = hiss_HissTools.extend(callEnv,hiss_HissTools.destructuringBind(params,interp,fArgs));
		interp.evalCC(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),hiss_HValue.List(body)),fCC,callEnv);
	};
	cc(isMacro ? hiss_HValue.Macro(hFun,meta) : hiss_HValue.Function(hFun,meta));
};
hiss_SpecialForms.and_s = function(interp,args,env,cc) {
	var argVal = hiss_HValue.T;
	var _g = 0;
	var _g1 = hiss_HissTools.toList(args);
	while(_g < _g1.length) {
		interp.evalCC(_g1[_g++],function(val) {
			argVal = val;
		},env);
		if(!interp.truthy(argVal)) {
			cc(hiss_HValue.Nil);
			return;
		}
	}
	cc(argVal);
};
hiss_SpecialForms.or_s = function(interp,args,env,cc) {
	var _g = 0;
	var _g1 = hiss_HissTools.toList(args);
	while(_g < _g1.length) {
		var argVal = [hiss_HValue.Nil];
		interp.evalCC(_g1[_g++],(function(argVal) {
			return function(val) {
				argVal[0] = val;
			};
		})(argVal),env);
		if(interp.truthy(argVal[0])) {
			cc(argVal[0]);
			return;
		}
	}
	cc(hiss_HValue.Nil);
};
hiss_SpecialForms.callCC_s = function(interp,args,env,cc) {
	hiss_SpecialForms._ccNum++;
	var functionToCall = null;
	if(hiss_Stdlib.length_h(args) > 1) {
		hiss_HissTools.toHaxeString(interp.eval(hiss_HissTools.first(args),env));
		functionToCall = hiss_HissTools.second(args);
	} else {
		functionToCall = hiss_HissTools.first(args);
	}
	var ccHFunction = hiss_HValue.Function(function(innerArgs,innerEnv,innerCC) {
		var arg = !interp.truthy(innerArgs) ? hiss_HValue.Nil : hiss_HissTools.first(innerArgs);
		cc(arg);
	},{ name : "cc", argNames : ["result"]});
	interp.evalCC(hiss_HValue.List([hiss_HValue.Symbol("funcall-inline"),functionToCall,ccHFunction]),cc,env);
};
hiss_SpecialForms.quote_s = function(interp,args,env,cc) {
	cc(hiss_HissTools.first(args));
};
var hiss_StaticFiles = function() { };
hiss_StaticFiles.__name__ = "hiss.StaticFiles";
hiss_StaticFiles._registerFileContent = function(path,content) {
	hiss_StaticFiles.files.h[path] = content;
};
hiss_StaticFiles._registerFileWithGroup = function(path,group) {
	if(!Object.prototype.hasOwnProperty.call(hiss_StaticFiles.groups.h,group)) {
		hiss_StaticFiles.groups.h[group] = [];
	}
	hiss_StaticFiles.groups.h[group].push(path);
};
hiss_StaticFiles.getContent = function(path) {
	if(Object.prototype.hasOwnProperty.call(hiss_StaticFiles.files.h,path)) {
		return hiss_StaticFiles.files.h[path];
	} else {
		return js_node_Fs.readFileSync(path,{ encoding : "utf8"});
	}
};
hiss_StaticFiles.getDirectoryFiles = function(directory) {
	return hiss_StaticFiles.groups.h[directory];
};
hiss_StaticFiles.recursiveLoop = function(directory,files) {
	if(files == null) {
		files = [];
	}
	return files;
};
var hiss_Stdlib = function() { };
hiss_Stdlib.__name__ = "hiss.Stdlib";
hiss_Stdlib.sort = function(list,fun) {
	if(fun == null) {
		fun = Reflect.compare;
	}
	var sorted = list.slice();
	sorted.sort(fun);
	return sorted;
};
hiss_Stdlib.reverse = function(list) {
	var reversed = list.slice();
	reversed.reverse();
	return reversed;
};
hiss_Stdlib.not_ih = function(interp,v) {
	if(interp.truthy(v)) {
		return hiss_HValue.Nil;
	} else {
		return hiss_HValue.T;
	}
};
hiss_Stdlib.nth_h = function(list,idx) {
	return hiss_HissTools.toList(list)[hiss_HissTools.toInt(idx)];
};
hiss_Stdlib.setNth_hd = function(arr,idx,val) {
	hiss_HissTools.toList(arr)[hiss_HissTools.toInt(idx)] = val;
	return arr;
};
hiss_Stdlib.symbolName_h = function(v) {
	if(v._hx_index == 2) {
		return v.name;
	} else {
		throw haxe_Exception.thrown("extraction to `" + "symbol name" + "` failed on `" + Std.string(v) + "`");
	}
};
hiss_Stdlib.symbol = function(name) {
	if(name == null) {
		return hiss_HValue.Symbol("_" + uuid_Uuid.v4());
	}
	return hiss_HValue.Symbol(name);
};
hiss_Stdlib.iterable = function(next,hasNext) {
	return { iterator : function() {
		return { next : function() {
			return hiss_HissTools.toHValue(next());
		}, hasNext : hasNext};
	}};
};
hiss_Stdlib.iteratorToIterable = function(iterator) {
	return hiss_Stdlib.iterable($bind(iterator,iterator.next),$bind(iterator,iterator.hasNext));
};
hiss_Stdlib.clear_hd = function(l) {
	var arr = hiss_HissTools.toList(l);
	arr.splice(0,arr.length);
	return l;
};
hiss_Stdlib.range = function(a,b) {
	return hiss_Stdlib.iteratorToIterable(new IntIterator(b == null ? 0 : a,b == null ? a : b));
};
hiss_Stdlib.length_h = function(v) {
	switch(v._hx_index) {
	case 4:
		return v.value.length;
	case 8:
		return v.l.length;
	default:
		throw haxe_Exception.thrown("" + Std.string(v) + " has no length");
	}
};
hiss_Stdlib.isInt_h = function(hv) {
	if(hv._hx_index == 0) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isFloat_h = function(hv) {
	if(hv._hx_index == 1) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isNumber_h = function(hv) {
	switch(hv._hx_index) {
	case 0:
		return hiss_HValue.T;
	case 1:
		return hiss_HValue.T;
	default:
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isSymbol_h = function(hv) {
	if(hv._hx_index == 2) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isString_h = function(hv) {
	if(hv._hx_index == 4) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isList_h = function(hv) {
	if(hv._hx_index == 8) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isDict_h = function(hv) {
	if(hv._hx_index == 9) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isFunction_h = function(hv) {
	if(hv._hx_index == 10) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isMacro_h = function(hv) {
	switch(hv._hx_index) {
	case 11:
		return hiss_HValue.T;
	case 12:
		return hiss_HValue.T;
	default:
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isCallable_h = function(hv) {
	switch(hv._hx_index) {
	case 10:
		return hiss_HValue.T;
	case 11:
		return hiss_HValue.T;
	case 12:
		return hiss_HValue.T;
	default:
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.isObject_h = function(hv) {
	if(hv._hx_index == 13) {
		return hiss_HValue.T;
	} else {
		return hiss_HValue.Nil;
	}
};
hiss_Stdlib.rest_h = function(list) {
	return hiss_HValue.List(hiss_HissTools.toList(list).slice(1));
};
hiss_Stdlib.cons_h = function(hv,hl) {
	if(hl == hiss_HValue.Nil || hiss_Stdlib.length_h(hl) == 0) {
		return hiss_HValue.List([hv]);
	}
	var l = hiss_HissTools.toList(hl).slice();
	l.splice(0,0,hv);
	return hiss_HValue.List(l);
};
hiss_Stdlib.eq_ih = function(interp,a,b) {
	while(true) {
		if(a._hx_index == 3) {
			a = interp.eval(a);
		}
		if(b._hx_index == 3) {
			b = interp.eval(b);
		}
		if(a._hx_index != b._hx_index) {
			return hiss_HValue.Nil;
		}
		switch(a._hx_index) {
		case 0:
			if(Type.enumEq(a,b)) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 1:
			if(Type.enumEq(a,b)) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 2:
			if(Type.enumEq(a,b)) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 4:
			if(Type.enumEq(a,b)) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 5:case 7:
			if(Type.enumEq(a,b)) {
				return hiss_HValue.T;
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 8:
			var l1 = hiss_HissTools.toList(a);
			var l2 = hiss_HissTools.toList(b);
			if(l1.length != l2.length) {
				return hiss_HValue.Nil;
			}
			var i = 0;
			while(i < l1.length) {
				if(!interp.truthy(hiss_Stdlib.eq_ih(interp,l1[i],l2[i]))) {
					return hiss_HValue.Nil;
				}
				++i;
			}
			return hiss_HValue.T;
		case 12:
			if(b._hx_index == 12) {
				if(a.f == b.f) {
					return hiss_HValue.T;
				} else {
					return hiss_HValue.Nil;
				}
			} else {
				return hiss_HValue.Nil;
			}
			break;
		case 14:
			var _g = a.exp;
			var bb;
			switch(b._hx_index) {
			case 14:
				bb = b.exp;
				break;
			case 15:
				bb = b.exp;
				break;
			case 16:
				bb = b.exp;
				break;
			case 17:
				bb = b.exp;
				break;
			default:
				throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(b) + "`");
			}
			a = _g;
			b = bb;
			continue;
		case 15:
			var _g1 = a.exp;
			var bb1;
			switch(b._hx_index) {
			case 14:
				bb1 = b.exp;
				break;
			case 15:
				bb1 = b.exp;
				break;
			case 16:
				bb1 = b.exp;
				break;
			case 17:
				bb1 = b.exp;
				break;
			default:
				throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(b) + "`");
			}
			a = _g1;
			b = bb1;
			continue;
		case 16:
			var _g2 = a.exp;
			var bb2;
			switch(b._hx_index) {
			case 14:
				bb2 = b.exp;
				break;
			case 15:
				bb2 = b.exp;
				break;
			case 16:
				bb2 = b.exp;
				break;
			case 17:
				bb2 = b.exp;
				break;
			default:
				throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(b) + "`");
			}
			a = _g2;
			b = bb2;
			continue;
		case 17:
			var _g3 = a.exp;
			var bb3;
			switch(b._hx_index) {
			case 14:
				bb3 = b.exp;
				break;
			case 15:
				bb3 = b.exp;
				break;
			case 16:
				bb3 = b.exp;
				break;
			case 17:
				bb3 = b.exp;
				break;
			default:
				throw haxe_Exception.thrown("extraction to `" + null + "` failed on `" + Std.string(b) + "`");
			}
			a = _g3;
			b = bb3;
			continue;
		default:
			throw haxe_Exception.thrown("eq is not implemented for " + Std.string(a) + " and " + Std.string(b));
		}
	}
};
hiss_Stdlib.toMessage_h = function(v) {
	if(v._hx_index == 4) {
		return v.value;
	} else {
		return hiss_Stdlib.toPrint_h(v);
	}
};
hiss_Stdlib.toPrint_h = function(v,recursiveCall) {
	if(recursiveCall == null) {
		recursiveCall = 0;
	}
	switch(v._hx_index) {
	case 0:
		var _g = v.value;
		if(_g == null) {
			return "null";
		} else {
			return "" + _g;
		}
		break;
	case 1:
		var _g = v.value;
		if(_g == null) {
			return "null";
		} else {
			return "" + _g;
		}
		break;
	case 2:
		return v.name;
	case 3:
		return "\"" + v.value + "\"";
	case 4:
		return "\"" + v.value + "\"";
	case 5:
		return "nil";
	case 6:
		return "null";
	case 7:
		return "t";
	case 8:
		var _g = v.l;
		if(recursiveCall > hiss_Stdlib.recursivePrintDepth) {
			return "STACK OVERFLOW DANGER";
		} else {
			var valueStr = "";
			var _g1 = 0;
			while(_g1 < _g.length) valueStr += hiss_Stdlib.toPrint_h(_g[_g1++],recursiveCall + 1) + " ";
			valueStr = HxOverrides.substr(valueStr,0,valueStr.length - 1);
			return "(" + valueStr + ")";
		}
		break;
	case 9:
		if(recursiveCall > hiss_Stdlib.recursivePrintDepth) {
			return "STACK OVERFLOW DANGER";
		} else {
			var _g = [];
			var _g1 = v.n.keyValueIterator();
			while(_g1.hasNext()) {
				var _g2 = _g1.next();
				_g.push("" + Std.string(_g2.key) + " => " + hiss_Stdlib.toPrint_h(_g2.value,recursiveCall + 1) + ", ");
			}
			return "" + Std.string(_g);
		}
		break;
	case 10:
		var _g = v.meta;
		return "" + _g.name + "(" + Std.string(_g.argNames) + ")";
	case 11:
		var _g = v.meta;
		return "" + _g.name + "(" + Std.string(_g.argNames) + ")";
	case 12:
		var _g = v.meta;
		return "" + _g.name + "(" + Std.string(_g.argNames) + ")";
	case 13:
		return "[" + v.t + ": " + Std.string(v.v) + "]";
	case 14:
		return "'" + hiss_Stdlib.toPrint_h(v.exp,recursiveCall + 1);
	case 15:
		return "`" + hiss_Stdlib.toPrint_h(v.exp,recursiveCall + 1);
	case 16:
		return "," + hiss_Stdlib.toPrint_h(v.exp,recursiveCall + 1);
	case 17:
		return ",@" + hiss_Stdlib.toPrint_h(v.exp,recursiveCall + 1);
	default:
		throw haxe_Exception.thrown("Not clear why " + Std.string(v) + " is being converted to string");
	}
};
hiss_Stdlib.print_hd = function(exp) {
	hiss_HaxeTools.println(hiss_Stdlib.toPrint_h(exp));
	return exp;
};
hiss_Stdlib.message_hd = function(exp) {
	hiss_HaxeTools.println(hiss_Stdlib.toMessage_h(exp));
	return exp;
};
hiss_Stdlib.version = function() {
	return hiss_HValue.String("master-549* (target: nodejs)");
};
hiss_Stdlib.homeDir = function() {
	var s = Sys.systemName() == "Windows" ? "UserProfile" : "HOME";
	var path = process.env[s];
	if(path != null) {
		return haxe_io_Path.normalize(path);
	} else {
		return "";
	}
};
hiss_Stdlib.docs_h = function(func) {
	return hiss_HissTools.metadata(func).docstring;
};
hiss_Stdlib.help_i = function(interp,showDeprecated) {
	if(showDeprecated == null) {
		showDeprecated = false;
	}
	var functionMessages = [];
	var _g = hiss_HissTools.toDict(interp.globals).keyValueIterator();
	while(_g.hasNext()) {
		var _g1 = _g.next();
		var value = _g1.value;
		var functionHelp = hiss_Stdlib.symbolName_h(_g1.key);
		if(StringTools.startsWith(functionHelp,"_")) {
			continue;
		}
		try {
			var meta = hiss_HissTools.metadata(value);
			if(meta.deprecated) {
				if(showDeprecated) {
					functionHelp += " @deprecated";
				} else {
					continue;
				}
			}
			if(meta.async) {
				functionHelp += " @async";
			}
			var docs = hiss_Stdlib.docs_h(value);
			if(docs != null && docs.length > 0) {
				functionHelp += ": " + docs;
			}
		} catch( _g2 ) {
			haxe_NativeStackTrace.lastError = _g2;
			continue;
		}
		functionMessages.push(functionHelp);
	}
	functionMessages.sort(function(a,b) {
		return Reflect.compare(a.toLowerCase(),b.toLowerCase());
	});
	var _g = 0;
	while(_g < functionMessages.length) hiss_Stdlib.message_hd(hiss_HValue.String(functionMessages[_g++]));
};
hiss_Stdlib.readLine_d = function() {
	return new _$Sys_FileInput(0).readLine();
};
hiss_Stdlib.sleep_ccda = function(interp,args,env,cc) {
	var _g = cc;
	var a1 = hiss_HValue.Nil;
	haxe_Timer.delay(function() {
		_g(a1);
	},Math.round(hiss_HissTools.toFloat(hiss_HissTools.first(args)) * 1000));
};
hiss_Stdlib.getProperty_cc = function(interp,args,env,cc) {
	cc(hiss_HissTools.toHValue(Reflect.getProperty(hiss_HissTools.value(hiss_HissTools.first(args),interp,true),hiss_HissTools.toHaxeString(hiss_HissTools.second(args)))));
};
hiss_Stdlib.setProperty_cc = function(interp,args,env,cc) {
	var object = hiss_HissTools.value(hiss_HissTools.first(args),interp,true);
	var propertyName = hiss_HissTools.toHaxeString(hiss_HissTools.second(args));
	var newValueHiss = hiss_HissTools.third(args);
	Reflect.setProperty(object,propertyName,hiss_HissTools.value(newValueHiss,interp,true));
	cc(newValueHiss);
};
hiss_Stdlib.callHaxe_cc = function(interp,args,env,cc) {
	var callOnReference = hiss_Stdlib.length_h(args) < 4 ? false : interp.truthy(hiss_Stdlib.nth_h(args,hiss_HValue.Int(3)));
	var keepArgsWrapped = hiss_Stdlib.length_h(args) < 5 ? hiss_HValue.Nil : hiss_Stdlib.nth_h(args,hiss_HValue.Int(4));
	var haxeCallArgs = hiss_Stdlib.length_h(args) < 3 ? [] : hiss_HissTools.unwrapList(hiss_HissTools.third(args),interp,keepArgsWrapped);
	var caller = hiss_HissTools.value(hiss_HissTools.first(args),interp,callOnReference);
	var methodName = hiss_HissTools.toHaxeString(hiss_HissTools.second(args));
	var method = Reflect.getProperty(caller,methodName);
	if(method == null) {
		interp.error("There is no haxe method called " + methodName + " on " + hiss_HissTools.toPrint(hiss_HissTools.first(args)));
	} else {
		cc(hiss_HissTools.toHValue(method.apply(caller,haxeCallArgs)));
	}
};
hiss_Stdlib.new_cc = function(interp,args,env,cc) {
	cc(hiss_HissTools.toHValue(Type.createInstance(hiss_HissTools.value(hiss_HissTools.first(args),interp),hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp))));
};
hiss_Stdlib.mod = function(a,b) {
	return a % b;
};
hiss_Stdlib.listCopy = function(v) {
	return v.slice();
};
hiss_Stdlib.isBound_s = function(interp,args,env,cc) {
	var stackFrames = hiss_HissTools.toList(env);
	var g = hiss_HissTools.toDict(interp.globals);
	var name = hiss_HissTools.first(args);
	var _g = 0;
	while(_g < stackFrames.length) if(hiss_HissTools.toDict(stackFrames[_g++]).exists_h(name)) {
		cc(hiss_HValue.T);
		return;
	}
	cc(g.exists_h(name) ? hiss_HValue.T : hiss_HValue.Nil);
};
hiss_Stdlib.delay_sd = function(interp,args,env,cc) {
	haxe_Timer.delay(function() {
		interp.eval(hiss_HValue.List([hiss_HissTools.first(args)]),env);
	},Math.round(hiss_HissTools.toFloat(hiss_HissTools.second(args)) * 1000));
};
var hiss_Comparison = $hxEnums["hiss.Comparison"] = { __ename__:"hiss.Comparison",__constructs__:null
	,Lesser: {_hx_name:"Lesser",_hx_index:0,__enum__:"hiss.Comparison",toString:$estr}
	,LesserEqual: {_hx_name:"LesserEqual",_hx_index:1,__enum__:"hiss.Comparison",toString:$estr}
	,Greater: {_hx_name:"Greater",_hx_index:2,__enum__:"hiss.Comparison",toString:$estr}
	,GreaterEqual: {_hx_name:"GreaterEqual",_hx_index:3,__enum__:"hiss.Comparison",toString:$estr}
	,Equal: {_hx_name:"Equal",_hx_index:4,__enum__:"hiss.Comparison",toString:$estr}
};
hiss_Comparison.__constructs__ = [hiss_Comparison.Lesser,hiss_Comparison.LesserEqual,hiss_Comparison.Greater,hiss_Comparison.GreaterEqual,hiss_Comparison.Equal];
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	while(true) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		var intf = cc.__interfaces__;
		if(intf != null) {
			var _g = 0;
			var _g1 = intf.length;
			while(_g < _g1) {
				var i = intf[_g++];
				if(i == cl || js_Boot.__interfLoop(i,cl)) {
					return true;
				}
			}
		}
		cc = cc.__super__;
	}
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__implements = function(o,iface) {
	return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__toStr = null;
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hiss_VariadicFunctions = function() { };
hiss_VariadicFunctions.__name__ = "hiss.VariadicFunctions";
hiss_VariadicFunctions.append_cc = function(interp,args,env,cc) {
	var result = hiss_HissTools.toList(hiss_HissTools.first(args));
	var _g = 0;
	var _g1 = hiss_HissTools.toList(hiss_Stdlib.rest_h(args));
	while(_g < _g1.length) result = result.concat(hiss_HissTools.toList(_g1[_g++]));
	cc(hiss_HValue.List(result));
};
hiss_VariadicFunctions.add_cc = function(interp,args,env,cc) {
	var sum;
	switch(hiss_HissTools.first(args)._hx_index) {
	case 0:
		sum = 0;
		break;
	case 1:
		sum = 0;
		break;
	case 4:
		sum = "";
		break;
	case 8:
		sum = [];
		break;
	default:
		var sum1 = "Cannot perform addition with operands: " + hiss_HissTools.toPrint(args) + " because first element is  ";
		var e = hiss_HissTools.first(args);
		throw haxe_Exception.thrown(sum1 + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
	}
	var addNext;
	switch(hiss_HissTools.first(args)._hx_index) {
	case 0:
		addNext = function(i) {
			sum += i;
		};
		break;
	case 1:
		addNext = function(i) {
			sum += i;
		};
		break;
	case 4:
		addNext = function(i) {
			sum += i;
		};
		break;
	case 8:
		addNext = function(i) {
			sum = sum.concat(i);
		};
		break;
	default:
		addNext = null;
	}
	var _g = 0;
	var _g1 = hiss_HissTools.unwrapList(args,interp);
	while(_g < _g1.length) addNext(_g1[_g++]);
	cc(hiss_HissTools.toHValue(sum));
};
hiss_VariadicFunctions.subtract_cc = function(interp,args,env,cc) {
	switch(hiss_Stdlib.length_h(args)) {
	case 0:
		cc(hiss_HValue.Int(0));
		break;
	case 1:
		cc(hiss_HissTools.toHValue(0 - hiss_HissTools.value(hiss_HissTools.first(args),interp)));
		break;
	default:
		var first = hiss_HissTools.value(hiss_HissTools.first(args),interp);
		var _g = 0;
		var _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp);
		while(_g < _g1.length) first -= _g1[_g++];
		cc(hiss_HissTools.toHValue(first));
	}
};
hiss_VariadicFunctions.divide_cc = function(interp,args,env,cc) {
	switch(hiss_Stdlib.length_h(args)) {
	case 0:
		throw haxe_Exception.thrown("Can't divide without operands");
	case 1:
		cc(hiss_HissTools.toHValue(1 / hiss_HissTools.value(hiss_HissTools.first(args),interp)));
		break;
	default:
		var first = hiss_HissTools.value(hiss_HissTools.first(args),interp);
		var _g = 0;
		var _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp);
		while(_g < _g1.length) first /= _g1[_g++];
		cc(hiss_HissTools.toHValue(first));
	}
};
hiss_VariadicFunctions.multiply_cc = function(interp,args,env,cc) {
	while(true) {
		switch(hiss_HissTools.first(args)._hx_index) {
		case 0:
			var product = 1;
			var operands = hiss_HissTools.unwrapList(args,interp);
			switch(hiss_HissTools.last(args)._hx_index) {
			case 4:
				args = hiss_Stdlib.cons_h(hiss_HissTools.toHValue(operands[operands.length - 1]),hiss_HissTools.toHList(operands.slice(0,operands.length - 1)));
				continue;
			case 8:
				args = hiss_Stdlib.cons_h(hiss_HissTools.toHValue(operands[operands.length - 1]),hiss_HissTools.toHList(operands.slice(0,operands.length - 1)));
				continue;
			default:
			}
			var _g = 0;
			while(_g < operands.length) product *= operands[_g++];
			cc(hiss_HissTools.toHValue(product));
			break;
		case 1:
			var product1 = 1;
			var operands1 = hiss_HissTools.unwrapList(args,interp);
			switch(hiss_HissTools.last(args)._hx_index) {
			case 4:
				args = hiss_Stdlib.cons_h(hiss_HissTools.toHValue(operands1[operands1.length - 1]),hiss_HissTools.toHList(operands1.slice(0,operands1.length - 1)));
				continue;
			case 8:
				args = hiss_Stdlib.cons_h(hiss_HissTools.toHValue(operands1[operands1.length - 1]),hiss_HissTools.toHList(operands1.slice(0,operands1.length - 1)));
				continue;
			default:
			}
			var _g1 = 0;
			while(_g1 < operands1.length) product1 *= operands1[_g1++];
			cc(hiss_HissTools.toHValue(product1));
			break;
		case 4:
			var product2 = "";
			var toRepeat = hiss_HissTools.toHaxeString(hiss_HissTools.first(args));
			var times = hiss_HissTools.toInt(hiss_HissTools.second(args));
			var _g2 = 0;
			while(_g2 < times) {
				++_g2;
				product2 += toRepeat;
			}
			if(hiss_Stdlib.length_h(args) == 2) {
				cc(hiss_HValue.String(product2));
			} else {
				args = hiss_Stdlib.cons_h(hiss_HValue.String(product2),hiss_HissTools.slice(args,2));
				continue;
			}
			break;
		case 8:
			var product3 = [];
			var toRepeat1 = hiss_HissTools.toList(hiss_HissTools.first(args));
			var times1 = hiss_HissTools.toInt(hiss_HissTools.second(args));
			var _g3 = 0;
			while(_g3 < times1) {
				++_g3;
				product3 = product3.concat(toRepeat1);
			}
			if(hiss_Stdlib.length_h(args) == 2) {
				cc(hiss_HValue.List(product3));
			} else {
				args = hiss_Stdlib.cons_h(hiss_HValue.List(product3),hiss_HissTools.slice(args,2));
				continue;
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot multiply with first operand " + hiss_HissTools.toPrint(hiss_HissTools.first(args)));
		}
		return;
	}
};
hiss_VariadicFunctions._numCompare = function(type,interp,args,env,cc) {
	switch(hiss_Stdlib.length_h(args)) {
	case 0:
		throw haxe_Exception.thrown("Can't compare without operands");
	case 1:
		cc(hiss_HValue.T);
		break;
	default:
		var leftSide = hiss_HissTools.value(hiss_HissTools.first(args),interp);
		var _g = 0;
		var _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp);
		while(_g < _g1.length) {
			var val = _g1[_g];
			++_g;
			var pass;
			switch(type._hx_index) {
			case 0:
				pass = leftSide < val;
				break;
			case 1:
				pass = leftSide <= val;
				break;
			case 2:
				pass = leftSide > val;
				break;
			case 3:
				pass = leftSide >= val;
				break;
			case 4:
				pass = leftSide == val;
				break;
			}
			if(pass) {
				leftSide = val;
			} else {
				cc(hiss_HValue.Nil);
				return;
			}
		}
		cc(hiss_HValue.T);
	}
};
var hiss_wrappers_HDate = function(year,month,day,hour,min,sec) {
	this._instance = new Date(year,month,day,hour,min,sec);
};
hiss_wrappers_HDate.__name__ = "hiss.wrappers.HDate";
hiss_wrappers_HDate._fromHaxeDate = function(date) {
	var hd = new hiss_wrappers_HDate(2020,0,0,0,0,0);
	hd._instance = date;
	return hd;
};
hiss_wrappers_HDate.fromString = function(s) {
	return hiss_wrappers_HDate._fromHaxeDate(HxOverrides.strDate(s));
};
hiss_wrappers_HDate.fromTime = function(t) {
	return hiss_wrappers_HDate._fromHaxeDate(new Date(t));
};
hiss_wrappers_HDate.now = function() {
	return hiss_wrappers_HDate._fromHaxeDate(new Date());
};
hiss_wrappers_HDate.getDate = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getDate();
};
hiss_wrappers_HDate.getDay = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getDay();
};
hiss_wrappers_HDate.getYear = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getFullYear();
};
hiss_wrappers_HDate.getHours = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getHours();
};
hiss_wrappers_HDate.getMinutes = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getMinutes();
};
hiss_wrappers_HDate.getMonth = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getMonth();
};
hiss_wrappers_HDate.getSeconds = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getSeconds();
};
hiss_wrappers_HDate.getTime = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getTime();
};
hiss_wrappers_HDate.getTimezoneOffset = function(date) {
	if(date == null) {
		date = hiss_wrappers_HDate.now();
	}
	return date._instance.getTimezoneOffset();
};
hiss_wrappers_HDate.prototype = {
	_instance: null
	,__class__: hiss_wrappers_HDate
};
var hiss_wrappers_HFile = function() { };
hiss_wrappers_HFile.__name__ = "hiss.wrappers.HFile";
hiss_wrappers_HFile.getContent = function(path) {
	return js_node_Fs.readFileSync(path,{ encoding : "utf8"});
};
hiss_wrappers_HFile.saveContent_d = function(path,content) {
	js_node_Fs.writeFileSync(path,content);
};
var hiss_wrappers_HHttp = function(url) {
	this._instance = new haxe_http_HttpNodeJs(url);
};
hiss_wrappers_HHttp.__name__ = "hiss.wrappers.HHttp";
hiss_wrappers_HHttp.request_dcc = function(interp,args,env,cc) {
	var http = hiss_HissTools.value(hiss_HissTools.first(args),interp)._instance;
	var post = hiss_Stdlib.length_h(args) > 1 && hiss_HissTools.value(hiss_HissTools.second(args),interp);
	http.onData = function(dataString) {
		cc(hiss_HissTools.toHValue(dataString));
	};
	http.onError = $bind(interp,interp.error);
	http.request(post);
};
hiss_wrappers_HHttp.prototype = {
	_instance: null
	,setHeader_d: function(name,value) {
		this._instance.setHeader(name,value);
	}
	,setParameter_d: function(name,value) {
		this._instance.setParameter(name,value);
	}
	,setPostData_d: function(data) {
		this._instance.setPostData(data);
	}
	,__class__: hiss_wrappers_HHttp
};
var hiss_wrappers_HStringTools = function() { };
hiss_wrappers_HStringTools.__name__ = "hiss.wrappers.HStringTools";
var hiss_wrappers_HType = function() { };
hiss_wrappers_HType.__name__ = "hiss.wrappers.HType";
hiss_wrappers_HType.createInstance = function(cl,args) {
	return Type.createInstance(cl,args);
};
var hx_strings_AnyAsString = {};
hx_strings_AnyAsString.fromBool = function(value) {
	if(value) {
		return "true";
	} else {
		return "false";
	}
};
hx_strings_AnyAsString.fromAny = function(value) {
	return Std.string(value);
};
var hx_strings__$Char_CharCaseMapper = function() {
	this.mapL2U = new haxe_ds_IntMap();
	this.mapU2L = new haxe_ds_IntMap();
	this._addCaseMapping(97,65);
	this._addCaseMapping(98,66);
	this._addCaseMapping(99,67);
	this._addCaseMapping(100,68);
	this._addCaseMapping(101,69);
	this._addCaseMapping(102,70);
	this._addCaseMapping(103,71);
	this._addCaseMapping(104,72);
	this._addCaseMapping(105,73);
	this._addCaseMapping(106,74);
	this._addCaseMapping(107,75);
	this._addCaseMapping(108,76);
	this._addCaseMapping(109,77);
	this._addCaseMapping(110,78);
	this._addCaseMapping(111,79);
	this._addCaseMapping(112,80);
	this._addCaseMapping(113,81);
	this._addCaseMapping(114,82);
	this._addCaseMapping(115,83);
	this._addCaseMapping(116,84);
	this._addCaseMapping(117,85);
	this._addCaseMapping(118,86);
	this._addCaseMapping(119,87);
	this._addCaseMapping(120,88);
	this._addCaseMapping(121,89);
	this._addCaseMapping(122,90);
	this._addCaseMapping(224,192);
	this._addCaseMapping(225,193);
	this._addCaseMapping(226,194);
	this._addCaseMapping(227,195);
	this._addCaseMapping(228,196);
	this._addCaseMapping(229,197);
	this._addCaseMapping(230,198);
	this._addCaseMapping(231,199);
	this._addCaseMapping(232,200);
	this._addCaseMapping(233,201);
	this._addCaseMapping(234,202);
	this._addCaseMapping(235,203);
	this._addCaseMapping(236,204);
	this._addCaseMapping(237,205);
	this._addCaseMapping(238,206);
	this._addCaseMapping(239,207);
	this._addCaseMapping(240,208);
	this._addCaseMapping(241,209);
	this._addCaseMapping(242,210);
	this._addCaseMapping(243,211);
	this._addCaseMapping(244,212);
	this._addCaseMapping(245,213);
	this._addCaseMapping(246,214);
	this._addCaseMapping(248,216);
	this._addCaseMapping(249,217);
	this._addCaseMapping(250,218);
	this._addCaseMapping(251,219);
	this._addCaseMapping(252,220);
	this._addCaseMapping(253,221);
	this._addCaseMapping(254,222);
	this._addCaseMapping(255,376);
	this._addCaseMapping(257,256);
	this._addCaseMapping(259,258);
	this._addCaseMapping(261,260);
	this._addCaseMapping(263,262);
	this._addCaseMapping(265,264);
	this._addCaseMapping(267,266);
	this._addCaseMapping(269,268);
	this._addCaseMapping(271,270);
	this._addCaseMapping(273,272);
	this._addCaseMapping(275,274);
	this._addCaseMapping(277,276);
	this._addCaseMapping(279,278);
	this._addCaseMapping(281,280);
	this._addCaseMapping(283,282);
	this._addCaseMapping(285,284);
	this._addCaseMapping(287,286);
	this._addCaseMapping(289,288);
	this._addCaseMapping(291,290);
	this._addCaseMapping(293,292);
	this._addCaseMapping(295,294);
	this._addCaseMapping(297,296);
	this._addCaseMapping(299,298);
	this._addCaseMapping(301,300);
	this._addCaseMapping(303,302);
	this._addCaseMapping(305,73);
	this._addCaseMapping(307,306);
	this._addCaseMapping(309,308);
	this._addCaseMapping(311,310);
	this._addCaseMapping(314,313);
	this._addCaseMapping(316,315);
	this._addCaseMapping(318,317);
	this._addCaseMapping(320,319);
	this._addCaseMapping(322,321);
	this._addCaseMapping(324,323);
	this._addCaseMapping(326,325);
	this._addCaseMapping(328,327);
	this._addCaseMapping(331,330);
	this._addCaseMapping(333,332);
	this._addCaseMapping(335,334);
	this._addCaseMapping(337,336);
	this._addCaseMapping(339,338);
	this._addCaseMapping(341,340);
	this._addCaseMapping(343,342);
	this._addCaseMapping(345,344);
	this._addCaseMapping(347,346);
	this._addCaseMapping(349,348);
	this._addCaseMapping(351,350);
	this._addCaseMapping(353,352);
	this._addCaseMapping(355,354);
	this._addCaseMapping(357,356);
	this._addCaseMapping(359,358);
	this._addCaseMapping(361,360);
	this._addCaseMapping(363,362);
	this._addCaseMapping(365,364);
	this._addCaseMapping(367,366);
	this._addCaseMapping(369,368);
	this._addCaseMapping(371,370);
	this._addCaseMapping(373,372);
	this._addCaseMapping(375,374);
	this._addCaseMapping(378,377);
	this._addCaseMapping(380,379);
	this._addCaseMapping(382,381);
	this._addCaseMapping(387,386);
	this._addCaseMapping(389,388);
	this._addCaseMapping(392,391);
	this._addCaseMapping(396,395);
	this._addCaseMapping(402,401);
	this._addCaseMapping(409,408);
	this._addCaseMapping(417,416);
	this._addCaseMapping(419,418);
	this._addCaseMapping(421,420);
	this._addCaseMapping(424,423);
	this._addCaseMapping(429,428);
	this._addCaseMapping(432,431);
	this._addCaseMapping(436,435);
	this._addCaseMapping(438,437);
	this._addCaseMapping(441,440);
	this._addCaseMapping(445,444);
	this._addCaseMapping(454,452);
	this._addCaseMapping(457,455);
	this._addCaseMapping(460,458);
	this._addCaseMapping(462,461);
	this._addCaseMapping(464,463);
	this._addCaseMapping(466,465);
	this._addCaseMapping(468,467);
	this._addCaseMapping(470,469);
	this._addCaseMapping(472,471);
	this._addCaseMapping(474,473);
	this._addCaseMapping(476,475);
	this._addCaseMapping(479,478);
	this._addCaseMapping(481,480);
	this._addCaseMapping(483,482);
	this._addCaseMapping(485,484);
	this._addCaseMapping(487,486);
	this._addCaseMapping(489,488);
	this._addCaseMapping(491,490);
	this._addCaseMapping(493,492);
	this._addCaseMapping(495,494);
	this._addCaseMapping(499,497);
	this._addCaseMapping(501,500);
	this._addCaseMapping(507,506);
	this._addCaseMapping(509,508);
	this._addCaseMapping(511,510);
	this._addCaseMapping(513,512);
	this._addCaseMapping(515,514);
	this._addCaseMapping(517,516);
	this._addCaseMapping(519,518);
	this._addCaseMapping(521,520);
	this._addCaseMapping(523,522);
	this._addCaseMapping(525,524);
	this._addCaseMapping(527,526);
	this._addCaseMapping(529,528);
	this._addCaseMapping(531,530);
	this._addCaseMapping(533,532);
	this._addCaseMapping(535,534);
	this._addCaseMapping(595,385);
	this._addCaseMapping(596,390);
	this._addCaseMapping(599,394);
	this._addCaseMapping(600,398);
	this._addCaseMapping(601,399);
	this._addCaseMapping(603,400);
	this._addCaseMapping(608,403);
	this._addCaseMapping(611,404);
	this._addCaseMapping(616,407);
	this._addCaseMapping(617,406);
	this._addCaseMapping(623,412);
	this._addCaseMapping(626,413);
	this._addCaseMapping(629,415);
	this._addCaseMapping(643,425);
	this._addCaseMapping(648,430);
	this._addCaseMapping(650,433);
	this._addCaseMapping(651,434);
	this._addCaseMapping(658,439);
	this._addCaseMapping(924,181);
	this._addCaseMapping(940,902);
	this._addCaseMapping(941,904);
	this._addCaseMapping(942,905);
	this._addCaseMapping(943,906);
	this._addCaseMapping(945,913);
	this._addCaseMapping(946,914);
	this._addCaseMapping(947,915);
	this._addCaseMapping(948,916);
	this._addCaseMapping(949,917);
	this._addCaseMapping(950,918);
	this._addCaseMapping(951,919);
	this._addCaseMapping(952,920);
	this._addCaseMapping(953,921);
	this._addCaseMapping(954,922);
	this._addCaseMapping(955,923);
	this._addCaseMapping(956,924);
	this._addCaseMapping(957,925);
	this._addCaseMapping(958,926);
	this._addCaseMapping(959,927);
	this._addCaseMapping(960,928);
	this._addCaseMapping(961,929);
	this._addCaseMapping(963,931);
	this._addCaseMapping(964,932);
	this._addCaseMapping(965,933);
	this._addCaseMapping(966,934);
	this._addCaseMapping(967,935);
	this._addCaseMapping(968,936);
	this._addCaseMapping(969,937);
	this._addCaseMapping(970,938);
	this._addCaseMapping(971,939);
	this._addCaseMapping(972,908);
	this._addCaseMapping(973,910);
	this._addCaseMapping(974,911);
	this._addCaseMapping(995,994);
	this._addCaseMapping(997,996);
	this._addCaseMapping(999,998);
	this._addCaseMapping(1001,1000);
	this._addCaseMapping(1003,1002);
	this._addCaseMapping(1005,1004);
	this._addCaseMapping(1007,1006);
	this._addCaseMapping(1072,1040);
	this._addCaseMapping(1073,1041);
	this._addCaseMapping(1074,1042);
	this._addCaseMapping(1075,1043);
	this._addCaseMapping(1076,1044);
	this._addCaseMapping(1077,1045);
	this._addCaseMapping(1078,1046);
	this._addCaseMapping(1079,1047);
	this._addCaseMapping(1080,1048);
	this._addCaseMapping(1081,1049);
	this._addCaseMapping(1082,1050);
	this._addCaseMapping(1083,1051);
	this._addCaseMapping(1084,1052);
	this._addCaseMapping(1085,1053);
	this._addCaseMapping(1086,1054);
	this._addCaseMapping(1087,1055);
	this._addCaseMapping(1088,1056);
	this._addCaseMapping(1089,1057);
	this._addCaseMapping(1090,1058);
	this._addCaseMapping(1091,1059);
	this._addCaseMapping(1092,1060);
	this._addCaseMapping(1093,1061);
	this._addCaseMapping(1094,1062);
	this._addCaseMapping(1095,1063);
	this._addCaseMapping(1096,1064);
	this._addCaseMapping(1097,1065);
	this._addCaseMapping(1098,1066);
	this._addCaseMapping(1099,1067);
	this._addCaseMapping(1100,1068);
	this._addCaseMapping(1101,1069);
	this._addCaseMapping(1102,1070);
	this._addCaseMapping(1103,1071);
	this._addCaseMapping(1105,1025);
	this._addCaseMapping(1106,1026);
	this._addCaseMapping(1107,1027);
	this._addCaseMapping(1108,1028);
	this._addCaseMapping(1109,1029);
	this._addCaseMapping(1110,1030);
	this._addCaseMapping(1111,1031);
	this._addCaseMapping(1112,1032);
	this._addCaseMapping(1113,1033);
	this._addCaseMapping(1114,1034);
	this._addCaseMapping(1115,1035);
	this._addCaseMapping(1116,1036);
	this._addCaseMapping(1118,1038);
	this._addCaseMapping(1119,1039);
	this._addCaseMapping(1121,1120);
	this._addCaseMapping(1123,1122);
	this._addCaseMapping(1125,1124);
	this._addCaseMapping(1127,1126);
	this._addCaseMapping(1129,1128);
	this._addCaseMapping(1131,1130);
	this._addCaseMapping(1133,1132);
	this._addCaseMapping(1135,1134);
	this._addCaseMapping(1137,1136);
	this._addCaseMapping(1139,1138);
	this._addCaseMapping(1141,1140);
	this._addCaseMapping(1143,1142);
	this._addCaseMapping(1145,1144);
	this._addCaseMapping(1147,1146);
	this._addCaseMapping(1149,1148);
	this._addCaseMapping(1151,1150);
	this._addCaseMapping(1153,1152);
	this._addCaseMapping(1169,1168);
	this._addCaseMapping(1171,1170);
	this._addCaseMapping(1173,1172);
	this._addCaseMapping(1175,1174);
	this._addCaseMapping(1177,1176);
	this._addCaseMapping(1179,1178);
	this._addCaseMapping(1181,1180);
	this._addCaseMapping(1183,1182);
	this._addCaseMapping(1185,1184);
	this._addCaseMapping(1187,1186);
	this._addCaseMapping(1189,1188);
	this._addCaseMapping(1191,1190);
	this._addCaseMapping(1193,1192);
	this._addCaseMapping(1195,1194);
	this._addCaseMapping(1197,1196);
	this._addCaseMapping(1199,1198);
	this._addCaseMapping(1201,1200);
	this._addCaseMapping(1203,1202);
	this._addCaseMapping(1205,1204);
	this._addCaseMapping(1207,1206);
	this._addCaseMapping(1209,1208);
	this._addCaseMapping(1211,1210);
	this._addCaseMapping(1213,1212);
	this._addCaseMapping(1215,1214);
	this._addCaseMapping(1218,1217);
	this._addCaseMapping(1220,1219);
	this._addCaseMapping(1224,1223);
	this._addCaseMapping(1228,1227);
	this._addCaseMapping(1233,1232);
	this._addCaseMapping(1235,1234);
	this._addCaseMapping(1237,1236);
	this._addCaseMapping(1239,1238);
	this._addCaseMapping(1241,1240);
	this._addCaseMapping(1243,1242);
	this._addCaseMapping(1245,1244);
	this._addCaseMapping(1247,1246);
	this._addCaseMapping(1249,1248);
	this._addCaseMapping(1251,1250);
	this._addCaseMapping(1253,1252);
	this._addCaseMapping(1255,1254);
	this._addCaseMapping(1257,1256);
	this._addCaseMapping(1259,1258);
	this._addCaseMapping(1263,1262);
	this._addCaseMapping(1265,1264);
	this._addCaseMapping(1267,1266);
	this._addCaseMapping(1269,1268);
	this._addCaseMapping(1273,1272);
	this._addCaseMapping(1377,1329);
	this._addCaseMapping(1378,1330);
	this._addCaseMapping(1379,1331);
	this._addCaseMapping(1380,1332);
	this._addCaseMapping(1381,1333);
	this._addCaseMapping(1382,1334);
	this._addCaseMapping(1383,1335);
	this._addCaseMapping(1384,1336);
	this._addCaseMapping(1385,1337);
	this._addCaseMapping(1386,1338);
	this._addCaseMapping(1387,1339);
	this._addCaseMapping(1388,1340);
	this._addCaseMapping(1389,1341);
	this._addCaseMapping(1390,1342);
	this._addCaseMapping(1391,1343);
	this._addCaseMapping(1392,1344);
	this._addCaseMapping(1393,1345);
	this._addCaseMapping(1394,1346);
	this._addCaseMapping(1395,1347);
	this._addCaseMapping(1396,1348);
	this._addCaseMapping(1397,1349);
	this._addCaseMapping(1398,1350);
	this._addCaseMapping(1399,1351);
	this._addCaseMapping(1400,1352);
	this._addCaseMapping(1401,1353);
	this._addCaseMapping(1402,1354);
	this._addCaseMapping(1403,1355);
	this._addCaseMapping(1404,1356);
	this._addCaseMapping(1405,1357);
	this._addCaseMapping(1406,1358);
	this._addCaseMapping(1407,1359);
	this._addCaseMapping(1408,1360);
	this._addCaseMapping(1409,1361);
	this._addCaseMapping(1410,1362);
	this._addCaseMapping(1411,1363);
	this._addCaseMapping(1412,1364);
	this._addCaseMapping(1413,1365);
	this._addCaseMapping(1414,1366);
	this._addCaseMapping(4304,4256);
	this._addCaseMapping(4305,4257);
	this._addCaseMapping(4306,4258);
	this._addCaseMapping(4307,4259);
	this._addCaseMapping(4308,4260);
	this._addCaseMapping(4309,4261);
	this._addCaseMapping(4310,4262);
	this._addCaseMapping(4311,4263);
	this._addCaseMapping(4312,4264);
	this._addCaseMapping(4313,4265);
	this._addCaseMapping(4314,4266);
	this._addCaseMapping(4315,4267);
	this._addCaseMapping(4316,4268);
	this._addCaseMapping(4317,4269);
	this._addCaseMapping(4318,4270);
	this._addCaseMapping(4319,4271);
	this._addCaseMapping(4320,4272);
	this._addCaseMapping(4321,4273);
	this._addCaseMapping(4322,4274);
	this._addCaseMapping(4323,4275);
	this._addCaseMapping(4324,4276);
	this._addCaseMapping(4325,4277);
	this._addCaseMapping(4326,4278);
	this._addCaseMapping(4327,4279);
	this._addCaseMapping(4328,4280);
	this._addCaseMapping(4329,4281);
	this._addCaseMapping(4330,4282);
	this._addCaseMapping(4331,4283);
	this._addCaseMapping(4332,4284);
	this._addCaseMapping(4333,4285);
	this._addCaseMapping(4334,4286);
	this._addCaseMapping(4335,4287);
	this._addCaseMapping(4336,4288);
	this._addCaseMapping(4337,4289);
	this._addCaseMapping(4338,4290);
	this._addCaseMapping(4339,4291);
	this._addCaseMapping(4340,4292);
	this._addCaseMapping(4341,4293);
	this._addCaseMapping(7681,7680);
	this._addCaseMapping(7683,7682);
	this._addCaseMapping(7685,7684);
	this._addCaseMapping(7687,7686);
	this._addCaseMapping(7689,7688);
	this._addCaseMapping(7691,7690);
	this._addCaseMapping(7693,7692);
	this._addCaseMapping(7695,7694);
	this._addCaseMapping(7697,7696);
	this._addCaseMapping(7699,7698);
	this._addCaseMapping(7701,7700);
	this._addCaseMapping(7703,7702);
	this._addCaseMapping(7705,7704);
	this._addCaseMapping(7707,7706);
	this._addCaseMapping(7709,7708);
	this._addCaseMapping(7711,7710);
	this._addCaseMapping(7713,7712);
	this._addCaseMapping(7715,7714);
	this._addCaseMapping(7717,7716);
	this._addCaseMapping(7719,7718);
	this._addCaseMapping(7721,7720);
	this._addCaseMapping(7723,7722);
	this._addCaseMapping(7725,7724);
	this._addCaseMapping(7727,7726);
	this._addCaseMapping(7729,7728);
	this._addCaseMapping(7731,7730);
	this._addCaseMapping(7733,7732);
	this._addCaseMapping(7735,7734);
	this._addCaseMapping(7737,7736);
	this._addCaseMapping(7739,7738);
	this._addCaseMapping(7741,7740);
	this._addCaseMapping(7743,7742);
	this._addCaseMapping(7745,7744);
	this._addCaseMapping(7747,7746);
	this._addCaseMapping(7749,7748);
	this._addCaseMapping(7751,7750);
	this._addCaseMapping(7753,7752);
	this._addCaseMapping(7755,7754);
	this._addCaseMapping(7757,7756);
	this._addCaseMapping(7759,7758);
	this._addCaseMapping(7761,7760);
	this._addCaseMapping(7763,7762);
	this._addCaseMapping(7765,7764);
	this._addCaseMapping(7767,7766);
	this._addCaseMapping(7769,7768);
	this._addCaseMapping(7771,7770);
	this._addCaseMapping(7773,7772);
	this._addCaseMapping(7775,7774);
	this._addCaseMapping(7777,7776);
	this._addCaseMapping(7779,7778);
	this._addCaseMapping(7781,7780);
	this._addCaseMapping(7783,7782);
	this._addCaseMapping(7785,7784);
	this._addCaseMapping(7787,7786);
	this._addCaseMapping(7789,7788);
	this._addCaseMapping(7791,7790);
	this._addCaseMapping(7793,7792);
	this._addCaseMapping(7795,7794);
	this._addCaseMapping(7797,7796);
	this._addCaseMapping(7799,7798);
	this._addCaseMapping(7801,7800);
	this._addCaseMapping(7803,7802);
	this._addCaseMapping(7805,7804);
	this._addCaseMapping(7807,7806);
	this._addCaseMapping(7809,7808);
	this._addCaseMapping(7811,7810);
	this._addCaseMapping(7813,7812);
	this._addCaseMapping(7815,7814);
	this._addCaseMapping(7817,7816);
	this._addCaseMapping(7819,7818);
	this._addCaseMapping(7821,7820);
	this._addCaseMapping(7823,7822);
	this._addCaseMapping(7825,7824);
	this._addCaseMapping(7827,7826);
	this._addCaseMapping(7829,7828);
	this._addCaseMapping(7841,7840);
	this._addCaseMapping(7843,7842);
	this._addCaseMapping(7845,7844);
	this._addCaseMapping(7847,7846);
	this._addCaseMapping(7849,7848);
	this._addCaseMapping(7851,7850);
	this._addCaseMapping(7853,7852);
	this._addCaseMapping(7855,7854);
	this._addCaseMapping(7857,7856);
	this._addCaseMapping(7859,7858);
	this._addCaseMapping(7861,7860);
	this._addCaseMapping(7863,7862);
	this._addCaseMapping(7865,7864);
	this._addCaseMapping(7867,7866);
	this._addCaseMapping(7869,7868);
	this._addCaseMapping(7871,7870);
	this._addCaseMapping(7873,7872);
	this._addCaseMapping(7875,7874);
	this._addCaseMapping(7877,7876);
	this._addCaseMapping(7879,7878);
	this._addCaseMapping(7881,7880);
	this._addCaseMapping(7883,7882);
	this._addCaseMapping(7885,7884);
	this._addCaseMapping(7887,7886);
	this._addCaseMapping(7889,7888);
	this._addCaseMapping(7891,7890);
	this._addCaseMapping(7893,7892);
	this._addCaseMapping(7895,7894);
	this._addCaseMapping(7897,7896);
	this._addCaseMapping(7899,7898);
	this._addCaseMapping(7901,7900);
	this._addCaseMapping(7903,7902);
	this._addCaseMapping(7905,7904);
	this._addCaseMapping(7907,7906);
	this._addCaseMapping(7909,7908);
	this._addCaseMapping(7911,7910);
	this._addCaseMapping(7913,7912);
	this._addCaseMapping(7915,7914);
	this._addCaseMapping(7917,7916);
	this._addCaseMapping(7919,7918);
	this._addCaseMapping(7921,7920);
	this._addCaseMapping(7923,7922);
	this._addCaseMapping(7925,7924);
	this._addCaseMapping(7927,7926);
	this._addCaseMapping(7929,7928);
	this._addCaseMapping(7936,7944);
	this._addCaseMapping(7937,7945);
	this._addCaseMapping(7938,7946);
	this._addCaseMapping(7939,7947);
	this._addCaseMapping(7940,7948);
	this._addCaseMapping(7941,7949);
	this._addCaseMapping(7942,7950);
	this._addCaseMapping(7943,7951);
	this._addCaseMapping(7952,7960);
	this._addCaseMapping(7953,7961);
	this._addCaseMapping(7954,7962);
	this._addCaseMapping(7955,7963);
	this._addCaseMapping(7956,7964);
	this._addCaseMapping(7957,7965);
	this._addCaseMapping(7968,7976);
	this._addCaseMapping(7969,7977);
	this._addCaseMapping(7970,7978);
	this._addCaseMapping(7971,7979);
	this._addCaseMapping(7972,7980);
	this._addCaseMapping(7973,7981);
	this._addCaseMapping(7974,7982);
	this._addCaseMapping(7975,7983);
	this._addCaseMapping(7984,7992);
	this._addCaseMapping(7985,7993);
	this._addCaseMapping(7986,7994);
	this._addCaseMapping(7987,7995);
	this._addCaseMapping(7988,7996);
	this._addCaseMapping(7989,7997);
	this._addCaseMapping(7990,7998);
	this._addCaseMapping(7991,7999);
	this._addCaseMapping(8000,8008);
	this._addCaseMapping(8001,8009);
	this._addCaseMapping(8002,8010);
	this._addCaseMapping(8003,8011);
	this._addCaseMapping(8004,8012);
	this._addCaseMapping(8005,8013);
	this._addCaseMapping(8017,8025);
	this._addCaseMapping(8019,8027);
	this._addCaseMapping(8021,8029);
	this._addCaseMapping(8023,8031);
	this._addCaseMapping(8032,8040);
	this._addCaseMapping(8033,8041);
	this._addCaseMapping(8034,8042);
	this._addCaseMapping(8035,8043);
	this._addCaseMapping(8036,8044);
	this._addCaseMapping(8037,8045);
	this._addCaseMapping(8038,8046);
	this._addCaseMapping(8039,8047);
	this._addCaseMapping(8064,8072);
	this._addCaseMapping(8065,8073);
	this._addCaseMapping(8066,8074);
	this._addCaseMapping(8067,8075);
	this._addCaseMapping(8068,8076);
	this._addCaseMapping(8069,8077);
	this._addCaseMapping(8070,8078);
	this._addCaseMapping(8071,8079);
	this._addCaseMapping(8080,8088);
	this._addCaseMapping(8081,8089);
	this._addCaseMapping(8082,8090);
	this._addCaseMapping(8083,8091);
	this._addCaseMapping(8084,8092);
	this._addCaseMapping(8085,8093);
	this._addCaseMapping(8086,8094);
	this._addCaseMapping(8087,8095);
	this._addCaseMapping(8096,8104);
	this._addCaseMapping(8097,8105);
	this._addCaseMapping(8098,8106);
	this._addCaseMapping(8099,8107);
	this._addCaseMapping(8100,8108);
	this._addCaseMapping(8101,8109);
	this._addCaseMapping(8102,8110);
	this._addCaseMapping(8103,8111);
	this._addCaseMapping(8112,8120);
	this._addCaseMapping(8113,8121);
	this._addCaseMapping(8144,8152);
	this._addCaseMapping(8145,8153);
	this._addCaseMapping(8160,8168);
	this._addCaseMapping(8161,8169);
	this._addCaseMapping(9424,9398);
	this._addCaseMapping(9425,9399);
	this._addCaseMapping(9426,9400);
	this._addCaseMapping(9427,9401);
	this._addCaseMapping(9428,9402);
	this._addCaseMapping(9429,9403);
	this._addCaseMapping(9430,9404);
	this._addCaseMapping(9431,9405);
	this._addCaseMapping(9432,9406);
	this._addCaseMapping(9433,9407);
	this._addCaseMapping(9434,9408);
	this._addCaseMapping(9435,9409);
	this._addCaseMapping(9436,9410);
	this._addCaseMapping(9437,9411);
	this._addCaseMapping(9438,9412);
	this._addCaseMapping(9439,9413);
	this._addCaseMapping(9440,9414);
	this._addCaseMapping(9441,9415);
	this._addCaseMapping(9442,9416);
	this._addCaseMapping(9443,9417);
	this._addCaseMapping(9444,9418);
	this._addCaseMapping(9445,9419);
	this._addCaseMapping(9446,9420);
	this._addCaseMapping(9447,9421);
	this._addCaseMapping(9448,9422);
	this._addCaseMapping(9449,9423);
	this._addCaseMapping(65345,65313);
	this._addCaseMapping(65346,65314);
	this._addCaseMapping(65347,65315);
	this._addCaseMapping(65348,65316);
	this._addCaseMapping(65349,65317);
	this._addCaseMapping(65350,65318);
	this._addCaseMapping(65351,65319);
	this._addCaseMapping(65352,65320);
	this._addCaseMapping(65353,65321);
	this._addCaseMapping(65354,65322);
	this._addCaseMapping(65355,65323);
	this._addCaseMapping(65356,65324);
	this._addCaseMapping(65357,65325);
	this._addCaseMapping(65358,65326);
	this._addCaseMapping(65359,65327);
	this._addCaseMapping(65360,65328);
	this._addCaseMapping(65361,65329);
	this._addCaseMapping(65362,65330);
	this._addCaseMapping(65363,65331);
	this._addCaseMapping(65364,65332);
	this._addCaseMapping(65365,65333);
	this._addCaseMapping(65366,65334);
	this._addCaseMapping(65367,65335);
	this._addCaseMapping(65368,65336);
	this._addCaseMapping(65369,65337);
	this._addCaseMapping(65370,65338);
};
hx_strings__$Char_CharCaseMapper.__name__ = "hx.strings._Char.CharCaseMapper";
hx_strings__$Char_CharCaseMapper.prototype = {
	mapU2L: null
	,mapL2U: null
	,_addCaseMapping: function(lowerChar,upperChar) {
		if(!this.mapU2L.h.hasOwnProperty(upperChar)) {
			this.mapU2L.h[upperChar] = lowerChar;
		}
		if(!this.mapL2U.h.hasOwnProperty(lowerChar)) {
			this.mapL2U.h[lowerChar] = upperChar;
		}
	}
	,isLowerCase: function(ch) {
		return this.mapL2U.h.hasOwnProperty(ch);
	}
	,isUpperCase: function(ch) {
		return this.mapU2L.h.hasOwnProperty(ch);
	}
	,toLowerCase: function(ch) {
		var lowerChar = this.mapU2L.h[ch];
		if(lowerChar == null) {
			return ch;
		} else {
			return lowerChar;
		}
	}
	,toUpperCase: function(ch) {
		var upperChar = this.mapL2U.h[ch];
		if(upperChar == null) {
			return ch;
		} else {
			return upperChar;
		}
	}
	,__class__: hx_strings__$Char_CharCaseMapper
};
var hx_strings_Char = {};
hx_strings_Char.fromString = function(str) {
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0 || 0 >= strLen) {
		return -1;
	} else {
		return HxOverrides.cca(str,0);
	}
};
hx_strings_Char.of = function(ch) {
	return ch;
};
hx_strings_Char.op_plus_string = function(ch,other) {
	return String.fromCodePoint(ch) + other;
};
hx_strings_Char.op_plus_string2 = function(str,ch) {
	return str + String.fromCodePoint(ch);
};
hx_strings_Char.op_plus = function(ch,other) {
	return ch + other;
};
hx_strings_Char.isAscii = function(this1) {
	if(this1 > -1) {
		return this1 < 128;
	} else {
		return false;
	}
};
hx_strings_Char.isAsciiAlpha = function(this1) {
	if(!(this1 > 64 && this1 < 91)) {
		if(this1 > 96) {
			return this1 < 123;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hx_strings_Char.isAsciiAlphanumeric = function(this1) {
	if(!(this1 > 64 && this1 < 91 || this1 > 96 && this1 < 123)) {
		if(this1 > 47) {
			return this1 < 58;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hx_strings_Char.isAsciiControl = function(this1) {
	if(!(this1 > -1 && this1 < 32)) {
		return this1 == 127;
	} else {
		return true;
	}
};
hx_strings_Char.isAsciiPrintable = function(this1) {
	if(this1 > 31) {
		return this1 < 127;
	} else {
		return false;
	}
};
hx_strings_Char.isDigit = function(this1) {
	if(this1 > 47) {
		return this1 < 58;
	} else {
		return false;
	}
};
hx_strings_Char.isEOF = function(this1) {
	return this1 != this1;
};
hx_strings_Char.isSpace = function(this1) {
	return this1 == 32;
};
hx_strings_Char.isUTF8 = function(this1) {
	if(this1 > -1) {
		return this1 < 1114112;
	} else {
		return false;
	}
};
hx_strings_Char.isWhitespace = function(this1) {
	if(!(this1 > 8 && this1 < 14)) {
		return this1 == 32;
	} else {
		return true;
	}
};
hx_strings_Char.isLowerCase = function(this1) {
	return hx_strings_Char.CHAR_CASE_MAPPER.mapL2U.h.hasOwnProperty(this1);
};
hx_strings_Char.isUpperCase = function(this1) {
	return hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h.hasOwnProperty(this1);
};
hx_strings_Char.toLowerCase = function(this1) {
	var lowerChar = hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h[this1];
	if(lowerChar == null) {
		return this1;
	} else {
		return lowerChar;
	}
};
hx_strings_Char.toUpperCase = function(this1) {
	var upperChar = hx_strings_Char.CHAR_CASE_MAPPER.mapL2U.h[this1];
	if(upperChar == null) {
		return this1;
	} else {
		return upperChar;
	}
};
hx_strings_Char.toInt = function(this1) {
	return this1;
};
hx_strings_Char.toString = function(this1) {
	return String.fromCodePoint(this1);
};
var hx_strings_CharIterator = function(prevBufferSize) {
	this.prevBufferNextIdx = -1;
	this.prevBufferPrevIdx = -1;
	this.currChar = -1;
	this.col = 0;
	this.line = 0;
	this.index = -1;
	this.prevBuffer = prevBufferSize > 0 ? new hx_strings_internal__$RingBuffer_RingBufferImpl(prevBufferSize + 1) : null;
};
hx_strings_CharIterator.__name__ = "hx.strings.CharIterator";
hx_strings_CharIterator.fromString = function(chars,prevBufferSize) {
	if(prevBufferSize == null) {
		prevBufferSize = 0;
	}
	if(chars == null) {
		return hx_strings__$CharIterator_NullCharIterator.INSTANCE;
	}
	return new hx_strings__$CharIterator_StringCharIterator(chars,prevBufferSize);
};
hx_strings_CharIterator.fromArray = function(chars,prevBufferSize) {
	if(prevBufferSize == null) {
		prevBufferSize = 0;
	}
	if(chars == null) {
		return hx_strings__$CharIterator_NullCharIterator.INSTANCE;
	}
	return new hx_strings__$CharIterator_ArrayCharIterator(chars,prevBufferSize);
};
hx_strings_CharIterator.fromInput = function(chars,prevBufferSize) {
	if(prevBufferSize == null) {
		prevBufferSize = 0;
	}
	if(chars == null) {
		return hx_strings__$CharIterator_NullCharIterator.INSTANCE;
	}
	return new hx_strings__$CharIterator_InputCharIterator(chars,prevBufferSize);
};
hx_strings_CharIterator.fromIterator = function(chars,prevBufferSize) {
	if(prevBufferSize == null) {
		prevBufferSize = 0;
	}
	if(chars == null) {
		return hx_strings__$CharIterator_NullCharIterator.INSTANCE;
	}
	return new hx_strings__$CharIterator_IteratorCharIterator(chars,prevBufferSize);
};
hx_strings_CharIterator.prototype = {
	index: null
	,line: null
	,col: null
	,currChar: null
	,prevBuffer: null
	,prevBufferPrevIdx: null
	,prevBufferNextIdx: null
	,get_current: function() {
		if(this.index > -1) {
			return this.currChar;
		} else {
			return null;
		}
	}
	,get_pos: function() {
		return new hx_strings_CharPos(this.index,this.line,this.col);
	}
	,hasPrev: function() {
		return this.prevBufferPrevIdx > -1;
	}
	,prev: function() {
		if(this.prevBufferPrevIdx <= -1) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		var prevChar = this.prevBuffer.get(this.prevBufferPrevIdx);
		this.currChar = prevChar.char;
		this.index = prevChar.index;
		this.line = prevChar.line;
		this.col = prevChar.col;
		this.prevBufferNextIdx = this.prevBufferPrevIdx + 1 < this.prevBuffer.length ? this.prevBufferPrevIdx + 1 : -1;
		this.prevBufferPrevIdx--;
		return this.currChar;
	}
	,hasNext: function() {
		if(this.prevBufferNextIdx > -1) {
			return true;
		} else {
			return !this.isEOF();
		}
	}
	,next: function() {
		if(this.prevBufferNextIdx > -1) {
			var prevChar = this.prevBuffer.get(this.prevBufferNextIdx);
			this.currChar = prevChar.char;
			this.index = prevChar.index;
			this.line = prevChar.line;
			this.col = prevChar.col;
			this.prevBufferPrevIdx = this.prevBufferNextIdx - 1;
			this.prevBufferNextIdx = this.prevBufferNextIdx + 1 < this.prevBuffer.length ? this.prevBufferNextIdx + 1 : -1;
			return this.currChar;
		}
		if(this.isEOF()) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.currChar == 10 || this.currChar < 0) {
			this.line++;
			this.col = 0;
		}
		this.index++;
		this.col++;
		this.currChar = this.getChar();
		if(this.prevBuffer != null) {
			this.prevBuffer.add(new hx_strings__$CharIterator_CharWithPos(this.currChar,this.index,this.col,this.line));
			this.prevBufferPrevIdx = this.prevBuffer.length - 2;
			this.prevBufferNextIdx = -1;
		}
		return this.currChar;
	}
	,getChar: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,isEOF: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: hx_strings_CharIterator
	,__properties__: {get_pos:"get_pos",get_current:"get_current"}
};
var hx_strings_CharPos = function(index,line,col) {
	this.index = index;
	this.line = line;
	this.col = col;
};
hx_strings_CharPos.__name__ = "hx.strings.CharPos";
hx_strings_CharPos.prototype = {
	index: null
	,line: null
	,col: null
	,toString: function() {
		return "CharPos[index=" + this.index + ", line=" + this.line + ", col=" + this.col + "]";
	}
	,__class__: hx_strings_CharPos
};
var hx_strings__$CharIterator_CharWithPos = function(char,index,line,col) {
	hx_strings_CharPos.call(this,index,line,col);
	this.char = char;
};
hx_strings__$CharIterator_CharWithPos.__name__ = "hx.strings._CharIterator.CharWithPos";
hx_strings__$CharIterator_CharWithPos.__super__ = hx_strings_CharPos;
hx_strings__$CharIterator_CharWithPos.prototype = $extend(hx_strings_CharPos.prototype,{
	char: null
	,__class__: hx_strings__$CharIterator_CharWithPos
});
var hx_strings_internal__$RingBuffer_RingBufferImpl = function(size) {
	this.length = 0;
	this.bufferEndIdx = -1;
	this.bufferStartIdx = 0;
	if(size < 1) {
		throw haxe_Exception.thrown("[size] must be > 0");
	}
	this.buffer = new Array(size);
	this.size = size;
	this.bufferMaxIdx = size - 1;
};
hx_strings_internal__$RingBuffer_RingBufferImpl.__name__ = "hx.strings.internal._RingBuffer.RingBufferImpl";
hx_strings_internal__$RingBuffer_RingBufferImpl.prototype = {
	buffer: null
	,bufferStartIdx: null
	,bufferEndIdx: null
	,bufferMaxIdx: null
	,length: null
	,size: null
	,add: function(item) {
		if(this.length == this.size) {
			this.bufferEndIdx = this.bufferStartIdx;
			this.bufferStartIdx++;
			if(this.bufferStartIdx > this.bufferMaxIdx) {
				this.bufferStartIdx = 0;
			}
		} else {
			this.bufferEndIdx++;
			this.length++;
		}
		this.buffer[this.bufferEndIdx] = item;
	}
	,get: function(index) {
		if(index < 0 || index > this.bufferMaxIdx) {
			throw haxe_Exception.thrown("[index] " + index + " is out of bound");
		}
		var realIdx = this.bufferStartIdx + index;
		if(realIdx > this.bufferMaxIdx) {
			realIdx -= this.length;
		}
		return this.buffer[realIdx];
	}
	,iterator: function() {
		return new hx_strings_internal__$RingBuffer_RingBufferIterator(this);
	}
	,toArray: function() {
		var arr = [];
		var i = this.iterator();
		while(i.hasNext()) arr.push(i.next());
		return arr;
	}
	,__class__: hx_strings_internal__$RingBuffer_RingBufferImpl
};
var hx_strings__$CharIterator_NullCharIterator = function() {
	hx_strings_CharIterator.call(this,0);
};
hx_strings__$CharIterator_NullCharIterator.__name__ = "hx.strings._CharIterator.NullCharIterator";
hx_strings__$CharIterator_NullCharIterator.__super__ = hx_strings_CharIterator;
hx_strings__$CharIterator_NullCharIterator.prototype = $extend(hx_strings_CharIterator.prototype,{
	isEOF: function() {
		return true;
	}
	,__class__: hx_strings__$CharIterator_NullCharIterator
});
var hx_strings__$CharIterator_ArrayCharIterator = function(chars,prevBufferSize) {
	hx_strings_CharIterator.call(this,prevBufferSize);
	this.chars = chars;
	this.charsMaxIndex = chars.length - 1;
};
hx_strings__$CharIterator_ArrayCharIterator.__name__ = "hx.strings._CharIterator.ArrayCharIterator";
hx_strings__$CharIterator_ArrayCharIterator.__super__ = hx_strings_CharIterator;
hx_strings__$CharIterator_ArrayCharIterator.prototype = $extend(hx_strings_CharIterator.prototype,{
	chars: null
	,charsMaxIndex: null
	,isEOF: function() {
		return this.index >= this.charsMaxIndex;
	}
	,getChar: function() {
		return this.chars[this.index];
	}
	,__class__: hx_strings__$CharIterator_ArrayCharIterator
});
var hx_strings__$CharIterator_IteratorCharIterator = function(chars,prevBufferSize) {
	hx_strings_CharIterator.call(this,prevBufferSize);
	this.chars = chars;
};
hx_strings__$CharIterator_IteratorCharIterator.__name__ = "hx.strings._CharIterator.IteratorCharIterator";
hx_strings__$CharIterator_IteratorCharIterator.__super__ = hx_strings_CharIterator;
hx_strings__$CharIterator_IteratorCharIterator.prototype = $extend(hx_strings_CharIterator.prototype,{
	chars: null
	,isEOF: function() {
		return !this.chars.hasNext();
	}
	,getChar: function() {
		return this.chars.next();
	}
	,__class__: hx_strings__$CharIterator_IteratorCharIterator
});
var hx_strings__$CharIterator_InputCharIterator = function(chars,prevBufferSize) {
	this.nextCharAvailable = null;
	this.currCharIndex = -1;
	this.byteIndex = 0;
	hx_strings_CharIterator.call(this,prevBufferSize);
	this.input = chars;
};
hx_strings__$CharIterator_InputCharIterator.__name__ = "hx.strings._CharIterator.InputCharIterator";
hx_strings__$CharIterator_InputCharIterator.__super__ = hx_strings_CharIterator;
hx_strings__$CharIterator_InputCharIterator.prototype = $extend(hx_strings_CharIterator.prototype,{
	byteIndex: null
	,input: null
	,currCharIndex: null
	,nextChar: null
	,nextCharAvailable: null
	,isEOF: function() {
		if(this.nextCharAvailable == null) {
			try {
				var byte1 = this.input.readByte();
				this.byteIndex++;
				var tmp;
				if(byte1 <= 127) {
					tmp = byte1;
				} else {
					byte1 &= -129;
					byte1 &= -65;
					var totalBytes = 2;
					var isBit6Set = 1 == (byte1 >> 5 & 1);
					var isBit5Set = false;
					if(isBit6Set) {
						byte1 &= -33;
						totalBytes = 3;
						isBit5Set = 1 == (byte1 >> 4 & 1);
						if(isBit5Set) {
							byte1 &= -17;
							totalBytes = 4;
							if(1 == (byte1 >> 3 & 1)) {
								throw haxe_Exception.thrown("Valid UTF-8 byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte1 + "]!");
							}
						}
					}
					var result = byte1 << 6 * (totalBytes - 1);
					var byte = this.input.readByte();
					this.byteIndex++;
					if(1 != (byte >> 7 & 1)) {
						throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
					}
					if(1 == (byte >> 6 & 1)) {
						throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
					}
					result += (byte & -129) << 6 * (totalBytes - 2);
					if(isBit6Set) {
						var byte = this.input.readByte();
						this.byteIndex++;
						if(1 != (byte >> 7 & 1)) {
							throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
						}
						if(1 == (byte >> 6 & 1)) {
							throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
						}
						result += (byte & -129) << 6 * (totalBytes - 3);
						if(isBit5Set) {
							var byte = this.input.readByte();
							this.byteIndex++;
							if(1 != (byte >> 7 & 1)) {
								throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
							}
							if(1 == (byte >> 6 & 1)) {
								throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
							}
							result += (byte & -129) << 6 * (totalBytes - 4);
						}
					}
					if(this.index == 0 && result == 65279) {
						var byte1 = this.input.readByte();
						this.byteIndex++;
						if(byte1 <= 127) {
							tmp = byte1;
						} else {
							byte1 &= -129;
							byte1 &= -65;
							var totalBytes = 2;
							var isBit6Set = 1 == (byte1 >> 5 & 1);
							var isBit5Set = false;
							if(isBit6Set) {
								byte1 &= -33;
								totalBytes = 3;
								isBit5Set = 1 == (byte1 >> 4 & 1);
								if(isBit5Set) {
									byte1 &= -17;
									totalBytes = 4;
									if(1 == (byte1 >> 3 & 1)) {
										throw haxe_Exception.thrown("Valid UTF-8 byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte1 + "]!");
									}
								}
							}
							var result1 = byte1 << 6 * (totalBytes - 1);
							var byte = this.input.readByte();
							this.byteIndex++;
							if(1 != (byte >> 7 & 1)) {
								throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
							}
							if(1 == (byte >> 6 & 1)) {
								throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
							}
							result1 += (byte & -129) << 6 * (totalBytes - 2);
							if(isBit6Set) {
								var byte = this.input.readByte();
								this.byteIndex++;
								if(1 != (byte >> 7 & 1)) {
									throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
								}
								if(1 == (byte >> 6 & 1)) {
									throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
								}
								result1 += (byte & -129) << 6 * (totalBytes - 3);
								if(isBit5Set) {
									var byte = this.input.readByte();
									this.byteIndex++;
									if(1 != (byte >> 7 & 1)) {
										throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
									}
									if(1 == (byte >> 6 & 1)) {
										throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
									}
									result1 += (byte & -129) << 6 * (totalBytes - 4);
								}
							}
							tmp = this.index == 0 && result1 == 65279 ? this.readUtf8Char() : result1;
						}
					} else {
						tmp = result;
					}
				}
				this.nextChar = tmp;
				this.nextCharAvailable = true;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
					this.nextCharAvailable = false;
				} else {
					throw _g;
				}
			}
		}
		return this.nextCharAvailable != true;
	}
	,getChar: function() {
		if(this.index != this.currCharIndex) {
			this.currCharIndex = this.index;
			this.nextCharAvailable = null;
			return this.nextChar;
		}
		return this.currChar;
	}
	,readUtf8Char: function() {
		var byte1 = this.input.readByte();
		this.byteIndex++;
		if(byte1 <= 127) {
			return byte1;
		}
		byte1 &= -129;
		byte1 &= -65;
		var totalBytes = 2;
		var isBit6Set = 1 == (byte1 >> 5 & 1);
		var isBit5Set = false;
		if(isBit6Set) {
			byte1 &= -33;
			totalBytes = 3;
			isBit5Set = 1 == (byte1 >> 4 & 1);
			if(isBit5Set) {
				byte1 &= -17;
				totalBytes = 4;
				if(1 == (byte1 >> 3 & 1)) {
					throw haxe_Exception.thrown("Valid UTF-8 byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte1 + "]!");
				}
			}
		}
		var result = byte1 << 6 * (totalBytes - 1);
		var byte = this.input.readByte();
		this.byteIndex++;
		if(1 != (byte >> 7 & 1)) {
			throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
		}
		if(1 == (byte >> 6 & 1)) {
			throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
		}
		result += (byte & -129) << 6 * (totalBytes - 2);
		if(isBit6Set) {
			var byte = this.input.readByte();
			this.byteIndex++;
			if(1 != (byte >> 7 & 1)) {
				throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
			}
			if(1 == (byte >> 6 & 1)) {
				throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
			}
			result += (byte & -129) << 6 * (totalBytes - 3);
			if(isBit5Set) {
				var byte = this.input.readByte();
				this.byteIndex++;
				if(1 != (byte >> 7 & 1)) {
					throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
				}
				if(1 == (byte >> 6 & 1)) {
					throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
				}
				result += (byte & -129) << 6 * (totalBytes - 4);
			}
		}
		if(this.index == 0 && result == 65279) {
			return this.readUtf8Char();
		}
		return result;
	}
	,readUtf8MultiSequenceByte: function() {
		var byte = this.input.readByte();
		this.byteIndex++;
		if(1 != (byte >> 7 & 1)) {
			throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
		}
		if(1 == (byte >> 6 & 1)) {
			throw haxe_Exception.thrown("Valid UTF-8 multi-sequence byte expected at position [" + this.byteIndex + "] but found byte with value [" + byte + "]!");
		}
		return byte & -129;
	}
	,__class__: hx_strings__$CharIterator_InputCharIterator
});
var hx_strings__$CharIterator_StringCharIterator = function(chars,prevBufferSize) {
	hx_strings_CharIterator.call(this,prevBufferSize);
	this.chars = chars;
	this.charsMaxIndex = (chars == null ? 0 : chars.length) - 1;
};
hx_strings__$CharIterator_StringCharIterator.__name__ = "hx.strings._CharIterator.StringCharIterator";
hx_strings__$CharIterator_StringCharIterator.__super__ = hx_strings_CharIterator;
hx_strings__$CharIterator_StringCharIterator.prototype = $extend(hx_strings_CharIterator.prototype,{
	chars: null
	,charsMaxIndex: null
	,isEOF: function() {
		return this.index >= this.charsMaxIndex;
	}
	,getChar: function() {
		return HxOverrides.cca(this.chars,this.index);
	}
	,__class__: hx_strings__$CharIterator_StringCharIterator
});
var hx_strings_Pattern = function(pattern,options) {
	this.pattern = pattern;
	this.options = options;
	this.ereg = new EReg(pattern,options);
	this.options += "u";
};
hx_strings_Pattern.__name__ = "hx.strings.Pattern";
hx_strings_Pattern.compile = function(pattern,options) {
	if(options == null) {
		return new hx_strings_Pattern(pattern,"");
	}
	var _g = options;
	var tmp;
	switch(_g._hx_index) {
	case 0:
		var str = hx_strings_Strings.toLowerCase8(_g.v);
		if(str == null || str.length == 0) {
			tmp = str;
		} else {
			var _g1 = [];
			var _g2 = 0;
			var _g3 = hx_strings_Strings.toChars(str);
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				var tmp1;
				var tmp2;
				var strLen = "i".length;
				if(v != (strLen == 0 || 0 >= strLen ? -1 : HxOverrides.cca("i",0))) {
					var strLen1 = "m".length;
					tmp2 = v == (strLen1 == 0 || 0 >= strLen1 ? -1 : HxOverrides.cca("m",0));
				} else {
					tmp2 = true;
				}
				if(!tmp2) {
					var strLen2 = "g".length;
					tmp1 = v == (strLen2 == 0 || 0 >= strLen2 ? -1 : HxOverrides.cca("g",0));
				} else {
					tmp1 = true;
				}
				if(tmp1) {
					_g1.push(v);
				}
			}
			var _this = _g1;
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = String.fromCodePoint(_this[i]);
			}
			tmp = result.join("");
		}
		break;
	case 1:
		tmp = Std.string(_g.v);
		break;
	case 2:
		var _g1 = [];
		var _g2 = 0;
		var _g3 = _g.v;
		while(_g2 < _g3.length) {
			var v = _g3[_g2];
			++_g2;
			if(v != null) {
				_g1.push(v);
			}
		}
		tmp = _g1.join("");
		break;
	}
	return new hx_strings_Pattern(pattern,tmp);
};
hx_strings_Pattern.prototype = {
	pattern: null
	,options: null
	,ereg: null
	,matcher: function(str) {
		return new hx_strings__$Pattern_MatcherImpl(this.ereg,this.pattern,this.options,str);
	}
	,replace: function(str,replaceWith) {
		return str.replace(this.ereg.r,replaceWith);
	}
	,remove: function(str) {
		return str.replace(this.ereg.r,"");
	}
	,split: function(str) {
		return this.ereg.split(str);
	}
	,__class__: hx_strings_Pattern
};
var hx_strings_Matcher = function() { };
hx_strings_Matcher.__name__ = "hx.strings.Matcher";
hx_strings_Matcher.__isInterface__ = true;
hx_strings_Matcher.prototype = {
	iterate: null
	,map: null
	,matched: null
	,matchedPos: null
	,matches: null
	,matchesInRegion: null
	,reset: null
	,substringAfterMatch: null
	,substringBeforeMatch: null
	,__class__: hx_strings_Matcher
};
var hx_strings__$Pattern_MatcherImpl = function(ereg,pattern,options,str) {
	this.ereg = this._cloneEReg(ereg,pattern,options);
	this.str = str;
	this.isMatch = null;
};
hx_strings__$Pattern_MatcherImpl.__name__ = "hx.strings._Pattern.MatcherImpl";
hx_strings__$Pattern_MatcherImpl.__interfaces__ = [hx_strings_Matcher];
hx_strings__$Pattern_MatcherImpl.prototype = {
	ereg: null
	,isMatch: null
	,str: null
	,reset: function(str) {
		this.str = str;
		this.isMatch = null;
		return this;
	}
	,iterate: function(onMatch) {
		var startAt = 0;
		while(this.ereg.matchSub(this.str,startAt)) {
			this.isMatch = true;
			var matchedPos = this.ereg.matchedPos();
			onMatch(this);
			startAt = matchedPos.pos + matchedPos.len;
		}
		this.isMatch = false;
	}
	,map: function(mapper) {
		var _gthis = this;
		return this.ereg.map(this.str,function(ereg) {
			_gthis.isMatch = true;
			return mapper(_gthis);
		});
	}
	,matched: function(n) {
		if(n == null) {
			n = 0;
		}
		if(this.isMatch == null) {
			this.isMatch = this.ereg.match(this.str);
		}
		if(!this.isMatch) {
			throw haxe_Exception.thrown("No string matched");
		}
		return this.ereg.matched(n);
	}
	,matches: function() {
		return this.isMatch = this.ereg.match(this.str);
	}
	,matchesInRegion: function(pos,len) {
		if(len == null) {
			len = -1;
		}
		return this.isMatch = this.ereg.matchSub(this.str,pos,len);
	}
	,matchedPos: function() {
		if(this.isMatch == null) {
			this.isMatch = this.ereg.match(this.str);
		}
		if(!this.isMatch) {
			throw haxe_Exception.thrown("No string matched");
		}
		return this.ereg.matchedPos();
	}
	,substringAfterMatch: function() {
		if(this.isMatch == null) {
			this.isMatch = this.ereg.match(this.str);
		}
		if(!this.isMatch) {
			return "";
		}
		return this.ereg.matchedRight();
	}
	,substringBeforeMatch: function() {
		if(this.isMatch == null) {
			this.isMatch = this.ereg.match(this.str);
		}
		if(!this.isMatch) {
			return "";
		}
		return this.ereg.matchedLeft();
	}
	,_cloneEReg: function(from,pattern,options) {
		return new EReg(pattern,options);
	}
	,__class__: hx_strings__$Pattern_MatcherImpl
};
var hx_strings_StringBuilder = function(initialContent) {
	this.len = 0;
	this.pre = null;
	this.sb = new StringBuf();
	if(initialContent != null) {
		this.add(initialContent);
	}
};
hx_strings_StringBuilder.__name__ = "hx.strings.StringBuilder";
hx_strings_StringBuilder.prototype = {
	sb: null
	,pre: null
	,len: null
	,length: null
	,get_length: function() {
		return this.len;
	}
	,add: function(item) {
		this.sb.b += Std.string(item);
		this.len += item == null ? 0 : item.length;
		return this;
	}
	,addChar: function(ch) {
		if(ch > -1 && ch < 128) {
			this.sb.b += String.fromCodePoint(ch);
		} else {
			var _this = this.sb;
			var x = String.fromCodePoint(ch);
			_this.b += Std.string(x);
		}
		this.len++;
		return this;
	}
	,addAll: function(items) {
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			this.sb.b += Std.string(item);
			this.len += item == null ? 0 : item.length;
		}
		return this;
	}
	,clear: function() {
		this.pre = null;
		this.sb = new StringBuf();
		this.len = 0;
		return this;
	}
	,isEmpty: function() {
		return this.len == 0;
	}
	,newLine: function() {
		this.sb.b += "\n";
		this.len++;
		return this;
	}
	,insert: function(pos,item) {
		if(pos < 0) {
			throw haxe_Exception.thrown("[pos] must not be negative");
		}
		if(pos > this.len) {
			throw haxe_Exception.thrown("[pos] must not be greater than this.length");
		}
		if(pos == this.len) {
			this.add(item);
			return this;
		}
		if(pos == 0) {
			if(this.pre == null) {
				this.pre = [];
			}
			this.pre.unshift(item);
			this.len += item == null ? 0 : item.length;
			return this;
		}
		var pre_len = 0;
		if(this.pre != null) {
			var _g = 0;
			var _g1 = this.pre.length;
			while(_g < _g1) {
				var i = _g++;
				var str = this.pre[i];
				var next_pre_len = pre_len + (str == null ? 0 : str.length);
				if(next_pre_len == pos) {
					this.pre.splice(i + 1,0,item);
					this.len += item == null ? 0 : item.length;
					return this;
				}
				if(next_pre_len > pos) {
					var preSplitted = hx_strings_Strings.splitAt(this.pre[i],[pos - pre_len]);
					this.pre[i] = preSplitted[0];
					this.pre.splice(i + 1,0,item);
					this.pre.splice(i + 2,0,preSplitted[1]);
					this.len += item == null ? 0 : item.length;
					return this;
				}
				pre_len = next_pre_len;
			}
		}
		if(this.sb.b.length == 0) {
			this.add(item);
			return this;
		}
		var sbSplitted = hx_strings_Strings.splitAt(this.sb.b,[pos - pre_len]);
		this.sb = new StringBuf();
		this.sb.b += Std.string(sbSplitted[0]);
		this.sb.b += Std.string(item);
		this.len += item == null ? 0 : item.length;
		this.sb.b += Std.string(sbSplitted[1]);
		return this;
	}
	,insertChar: function(pos,ch) {
		if(pos < 0) {
			throw haxe_Exception.thrown("[pos] must not be negative");
		}
		if(pos > this.len) {
			throw haxe_Exception.thrown("[pos] must not be greater than this.length");
		}
		if(pos == this.len) {
			this.addChar(ch);
			return this;
		}
		if(pos == 0) {
			if(this.pre == null) {
				this.pre = [];
			}
			this.pre.unshift(String.fromCodePoint(ch));
			this.len++;
			return this;
		}
		var pre_len = 0;
		if(this.pre != null) {
			var _g = 0;
			var _g1 = this.pre.length;
			while(_g < _g1) {
				var i = _g++;
				var str = this.pre[i];
				var next_pre_len = pre_len + (str == null ? 0 : str.length);
				if(next_pre_len == pos) {
					var _this = this.pre;
					var x = String.fromCodePoint(ch);
					_this.splice(i + 1,0,x);
					this.len++;
					return this;
				}
				if(next_pre_len > pos) {
					var preSplitted = hx_strings_Strings.splitAt(this.pre[i],[pos - pre_len]);
					this.pre[i] = preSplitted[0];
					var _this1 = this.pre;
					var x1 = String.fromCodePoint(ch);
					_this1.splice(i + 1,0,x1);
					this.pre.splice(i + 2,0,preSplitted[1]);
					this.len++;
					return this;
				}
				pre_len = next_pre_len;
			}
		}
		if(this.sb.b.length == 0) {
			this.addChar(ch);
			return this;
		}
		var sbSplitted = hx_strings_Strings.splitAt(this.sb.b,[pos - pre_len]);
		this.sb = new StringBuf();
		this.sb.b += Std.string(sbSplitted[0]);
		this.addChar(ch);
		this.sb.b += Std.string(sbSplitted[1]);
		return this;
	}
	,insertAll: function(pos,items) {
		if(pos < 0) {
			throw haxe_Exception.thrown("[pos] must not be negative");
		}
		if(pos > this.len) {
			throw haxe_Exception.thrown("[pos] must not be greater than this.length");
		}
		if(pos == this.len) {
			this.addAll(items);
			return this;
		}
		if(pos == 0) {
			if(this.pre == null) {
				this.pre = [];
			}
			var i = items.length;
			while(i-- > 0) {
				var item = items[i];
				this.pre.unshift(item);
				this.len += item == null ? 0 : item.length;
			}
			return this;
		}
		var pre_len = 0;
		if(this.pre != null) {
			var _g = 0;
			var _g1 = this.pre.length;
			while(_g < _g1) {
				var i = _g++;
				var str = this.pre[i];
				var next_pre_len = pre_len + (str == null ? 0 : str.length);
				if(next_pre_len == pos) {
					var j = items.length;
					while(j-- > 0) {
						var item = items[j];
						this.pre.splice(i + 1,0,item);
						this.len += item == null ? 0 : item.length;
					}
					return this;
				}
				if(next_pre_len > pos) {
					var preSplitted = hx_strings_Strings.splitAt(this.pre[i],[pos - pre_len]);
					this.pre[i] = preSplitted[0];
					this.pre.splice(i + 1,0,preSplitted[1]);
					var j1 = items.length;
					while(j1-- > 0) {
						var item1 = items[j1];
						this.pre.splice(i + 1,0,item1);
						this.len += item1 == null ? 0 : item1.length;
					}
					return this;
				}
				pre_len = next_pre_len;
			}
		}
		if(this.sb.b.length == 0) {
			var _g = 0;
			while(_g < items.length) this.add(items[_g++]);
			return this;
		}
		var sbSplitted = hx_strings_Strings.splitAt(this.sb.b,[pos - pre_len]);
		this.sb = new StringBuf();
		this.sb.b += Std.string(sbSplitted[0]);
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			this.sb.b += Std.string(item);
			this.len += item == null ? 0 : item.length;
		}
		this.sb.b += Std.string(sbSplitted[1]);
		return this;
	}
	,asOutput: function() {
		return new hx_strings__$StringBuilder_OutputWrapper(this);
	}
	,toString: function() {
		if(this.pre == null) {
			return this.sb.b;
		}
		var str = this.pre.join("") + this.sb.b;
		this.clear();
		this.add(str);
		return str;
	}
	,__class__: hx_strings_StringBuilder
	,__properties__: {get_length:"get_length"}
};
var hx_strings__$StringBuilder_OutputWrapper = function(sb) {
	this.sb = sb;
};
hx_strings__$StringBuilder_OutputWrapper.__name__ = "hx.strings._StringBuilder.OutputWrapper";
hx_strings__$StringBuilder_OutputWrapper.__super__ = haxe_io_Output;
hx_strings__$StringBuilder_OutputWrapper.prototype = $extend(haxe_io_Output.prototype,{
	sb: null
	,bo: null
	,flush: function() {
		if(this.bo != null && this.bo.b.pos > 0) {
			this.sb.add(this.bo.getBytes().toString());
		}
	}
	,writeByte: function(c) {
		if(this.bo == null) {
			this.bo = new haxe_io_BytesOutput();
		}
		this.bo.writeByte(c);
	}
	,writeString: function(str,encoding) {
		this.flush();
		this.sb.add(str);
	}
	,__class__: hx_strings__$StringBuilder_OutputWrapper
});
var hx_strings_internal_OS = function() { };
hx_strings_internal_OS.__name__ = "hx.strings.internal.OS";
var hx_strings_internal__$Either3__$Either3 = $hxEnums["hx.strings.internal._Either3._Either3"] = { __ename__:"hx.strings.internal._Either3._Either3",__constructs__:null
	,a: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hx.strings.internal._Either3._Either3",toString:$estr}; },$_._hx_name="a",$_.__params__ = ["v"],$_)
	,b: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hx.strings.internal._Either3._Either3",toString:$estr}; },$_._hx_name="b",$_.__params__ = ["v"],$_)
	,c: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hx.strings.internal._Either3._Either3",toString:$estr}; },$_._hx_name="c",$_.__params__ = ["v"],$_)
};
hx_strings_internal__$Either3__$Either3.__constructs__ = [hx_strings_internal__$Either3__$Either3.a,hx_strings_internal__$Either3__$Either3.b,hx_strings_internal__$Either3__$Either3.c];
var hx_strings_Strings = function() { };
hx_strings_Strings.__name__ = "hx.strings.Strings";
hx_strings_Strings._getNotFoundDefault = function(str,notFoundDefault) {
	switch(notFoundDefault) {
	case 1:
		return null;
	case 2:
		return "";
	case 3:
		return str;
	}
};
hx_strings_Strings._charCodeAt8Unsafe = function(str,pos) {
	return HxOverrides.cca(str,pos);
};
hx_strings_Strings._splitAsciiWordsUnsafe = function(str) {
	var words = [];
	var currentWord = new hx_strings_StringBuilder();
	var chars = hx_strings_Strings.toChars(str);
	var len = chars.length;
	var lastIndex = len - 1;
	var _g = 0;
	while(_g < len) {
		var i = _g++;
		var ch = chars[i];
		if(ch > 64 && ch < 91 || ch > 96 && ch < 123) {
			var chNext = i < lastIndex ? chars[i + 1] : -1;
			currentWord.addChar(ch);
			if(chNext > 47 && chNext < 58) {
				words.push(currentWord.toString());
				currentWord.clear();
			} else if(hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h.hasOwnProperty(ch)) {
				if(hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h.hasOwnProperty(chNext) && chars.length > i + 2) {
					if(!hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h.hasOwnProperty(chars[i + 2])) {
						words.push(currentWord.toString());
						currentWord.clear();
					}
				}
			} else if(hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h.hasOwnProperty(chNext)) {
				words.push(currentWord.toString());
				currentWord.clear();
			}
		} else if(ch > 47 && ch < 58) {
			currentWord.addChar(ch);
			var chNext1 = i < lastIndex ? chars[i + 1] : -1;
			if(!(chNext1 > 47 && chNext1 < 58)) {
				words.push(currentWord.toString());
				currentWord.clear();
			}
		} else if(currentWord.len > 0) {
			words.push(currentWord.toString());
			currentWord.clear();
		}
	}
	if(currentWord.len > 0) {
		words.push(currentWord.toString());
	}
	return words;
};
hx_strings_Strings.ansiToHtml = function(str,renderMethod,initialState) {
	if(str == null || str.length == 0) {
		return str;
	}
	if(renderMethod == null) {
		renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes;
	}
	var styleOrClassAttribute;
	switch(renderMethod._hx_index) {
	case 0:
		styleOrClassAttribute = "style";
		break;
	case 1:
		styleOrClassAttribute = "class";
		break;
	case 2:
		styleOrClassAttribute = "class";
		break;
	}
	var sb = new hx_strings_StringBuilder();
	if(initialState != null && (initialState.fgcolor != null || initialState.bgcolor != null || initialState.bold || initialState.underline || initialState.blink)) {
		sb.add("<span " + styleOrClassAttribute + "=\"").add(initialState.toCSS(renderMethod)).add("\">");
	}
	var effectiveState = new hx_strings_AnsiState(initialState);
	var strLenMinus1 = (str == null ? 0 : str.length) - 1;
	var i = -1;
	var lookAhead = new hx_strings_StringBuilder();
	while(i < strLenMinus1) {
		++i;
		var ch = HxOverrides.cca(str,i);
		if(ch == 27 && i < strLenMinus1 && HxOverrides.cca(str,i + 1) == 91) {
			lookAhead.clear();
			var currentState = new hx_strings_AnsiState(effectiveState);
			var currentGraphicModeParam = 0;
			var isValidEscapeSequence = false;
			++i;
			_hx_loop2: while(i < strLenMinus1) {
				++i;
				var ch2 = HxOverrides.cca(str,i);
				lookAhead.addChar(ch2);
				switch(ch2) {
				case 48:
					currentGraphicModeParam *= 10;
					break;
				case 49:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 1;
					break;
				case 50:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 2;
					break;
				case 51:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 3;
					break;
				case 52:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 4;
					break;
				case 53:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 5;
					break;
				case 54:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 6;
					break;
				case 55:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 7;
					break;
				case 56:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 8;
					break;
				case 57:
					currentGraphicModeParam = currentGraphicModeParam * 10 + 9;
					break;
				case 59:
					currentState.setGraphicModeParameter(currentGraphicModeParam);
					currentGraphicModeParam = 0;
					break;
				case 109:
					currentState.setGraphicModeParameter(currentGraphicModeParam);
					if(effectiveState.fgcolor != null || effectiveState.bgcolor != null || effectiveState.bold || effectiveState.underline || effectiveState.blink) {
						sb.add("</span>");
					}
					if(currentState.fgcolor != null || currentState.bgcolor != null || currentState.bold || currentState.underline || currentState.blink) {
						sb.add("<span " + styleOrClassAttribute + "=\"").add(currentState.toCSS(renderMethod)).add("\">");
					}
					effectiveState = currentState;
					isValidEscapeSequence = true;
					break _hx_loop2;
				default:
					break _hx_loop2;
				}
			}
			if(!isValidEscapeSequence) {
				sb.addChar(27).add("[").add(Std.string(lookAhead));
			}
		} else {
			sb.addChar(ch);
		}
	}
	if(effectiveState.fgcolor != null || effectiveState.bgcolor != null || effectiveState.bold || effectiveState.underline || effectiveState.blink) {
		sb.add("</span>");
	}
	return sb.toString();
};
hx_strings_Strings.appendIfMissing = function(str,suffix) {
	if(str == null) {
		return null;
	}
	if(str.length == 0) {
		return str + suffix;
	}
	if(hx_strings_Strings.endsWith(str,suffix)) {
		return str;
	}
	return str + suffix;
};
hx_strings_Strings.base64Encode = function(plain) {
	if(plain == null) {
		return null;
	}
	return haxe_crypto_Base64.encode(plain == null ? null : haxe_io_Bytes.ofString(plain));
};
hx_strings_Strings.base64Decode = function(encoded) {
	if(encoded == null) {
		return null;
	}
	return haxe_crypto_Base64.decode(encoded).toString();
};
hx_strings_Strings.charAt8 = function(str,pos,resultIfOutOfBound) {
	if(resultIfOutOfBound == null) {
		resultIfOutOfBound = "";
	}
	if(str == null || str.length == 0 || pos < 0 || pos >= (str == null ? 0 : str.length)) {
		return resultIfOutOfBound;
	}
	return str.charAt(pos);
};
hx_strings_Strings.charCodeAt8 = function(str,pos,resultIfOutOfBound) {
	if(resultIfOutOfBound == null) {
		resultIfOutOfBound = -1;
	}
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0 || pos < 0 || pos >= strLen) {
		return resultIfOutOfBound;
	}
	return HxOverrides.cca(str,pos);
};
hx_strings_Strings.compact = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	var needWhiteSpace = false;
	var _g = 0;
	var _g1 = hx_strings_Strings.toChars(str);
	while(_g < _g1.length) {
		var char = _g1[_g];
		++_g;
		if(char > 8 && char < 14 || char == 32) {
			if(sb.len != 0) {
				needWhiteSpace = true;
			}
			continue;
		} else if(needWhiteSpace) {
			sb.addChar(32);
			needWhiteSpace = false;
		}
		sb.addChar(char);
	}
	return sb.toString();
};
hx_strings_Strings.contains = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	if(searchFor == "") {
		return true;
	}
	return searchIn.indexOf(searchFor) > -1;
};
hx_strings_Strings.containsOnly = function(searchIn,allowedChars) {
	if(searchIn == null || searchIn.length == 0) {
		return true;
	}
	if(allowedChars == null) {
		return false;
	}
	var allowedCharsArray;
	var _g = allowedChars;
	switch(_g._hx_index) {
	case 0:
		allowedCharsArray = hx_strings_Strings.toChars(_g.v);
		break;
	case 1:
		allowedCharsArray = _g.v;
		break;
	}
	var _g = 0;
	var _g1 = hx_strings_Strings.toChars(searchIn);
	while(_g < _g1.length) if(allowedCharsArray.indexOf(_g1[_g++]) < 0) {
		return false;
	}
	return true;
};
hx_strings_Strings.containsAll = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(!(searchIn == null || candidate == null ? false : candidate == "" ? true : searchIn.indexOf(candidate) > -1)) {
			return false;
		}
	}
	return true;
};
hx_strings_Strings.containsAllIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	searchIn = searchIn.toLowerCase();
	var _g = 0;
	while(_g < searchFor.length) {
		var searchFor1 = searchFor[_g++].toLowerCase();
		if(!(searchIn == null || searchFor1 == null ? false : searchFor1 == "" ? true : searchIn.indexOf(searchFor1) > -1)) {
			return false;
		}
	}
	return true;
};
hx_strings_Strings.containsAny = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(searchIn == null || candidate == null ? false : candidate == "" ? true : searchIn.indexOf(candidate) > -1) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.containsAnyIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	searchIn = searchIn.toLowerCase();
	var _g = 0;
	while(_g < searchFor.length) {
		var searchFor1 = searchFor[_g++].toLowerCase();
		if(searchIn == null || searchFor1 == null ? false : searchFor1 == "" ? true : searchIn.indexOf(searchFor1) > -1) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.containsNone = function(searchIn,searchFor) {
	return !hx_strings_Strings.containsAny(searchIn,searchFor);
};
hx_strings_Strings.containsNoneIgnoreCase = function(searchIn,searchFor) {
	return !hx_strings_Strings.containsAnyIgnoreCase(searchIn,searchFor);
};
hx_strings_Strings.containsWhitespaces = function(searchIn) {
	if(searchIn == null) {
		return false;
	}
	var _g = 0;
	var _g1 = hx_strings_Strings.toChars(searchIn);
	while(_g < _g1.length) {
		var ch = _g1[_g];
		++_g;
		if(ch > 8 && ch < 14 || ch == 32) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.countMatches = function(searchIn,searchFor,startAt) {
	if(startAt == null) {
		startAt = 0;
	}
	if(searchIn == null || searchIn.length == 0 || (searchFor == null || searchFor.length == 0) || startAt >= searchIn.length) {
		return 0;
	}
	if(startAt < 0) {
		startAt = 0;
	}
	var count = 0;
	var foundAt = startAt > -1 ? startAt - 1 : 0;
	while(true) {
		foundAt = searchIn.indexOf(searchFor,foundAt + 1);
		if(!(foundAt > -1)) {
			break;
		}
		++count;
	}
	return count;
};
hx_strings_Strings.countMatchesIgnoreCase = function(searchIn,searchFor,startAt) {
	if(startAt == null) {
		startAt = 0;
	}
	if(searchIn == null || searchIn.length == 0 || (searchFor == null || searchFor.length == 0) || startAt >= searchIn.length) {
		return 0;
	}
	if(startAt < 0) {
		startAt = 0;
	}
	searchIn = searchIn.toLowerCase();
	searchFor = searchFor.toLowerCase();
	var count = 0;
	var foundAt = startAt > -1 ? startAt - 1 : 0;
	while(true) {
		foundAt = searchIn.indexOf(searchFor,foundAt + 1);
		if(!(foundAt > -1)) {
			break;
		}
		++count;
	}
	return count;
};
hx_strings_Strings.compare = function(str,other) {
	if(str == null) {
		if(other == null) {
			return 0;
		} else {
			return -1;
		}
	}
	if(other == null) {
		if(str == null) {
			return 0;
		} else {
			return 1;
		}
	}
	if(str > other) {
		return 1;
	} else if(str == other) {
		return 0;
	} else {
		return -1;
	}
};
hx_strings_Strings.compareIgnoreCase = function(str,other) {
	if(str == null) {
		if(other == null) {
			return 0;
		} else {
			return -1;
		}
	}
	if(other == null) {
		if(str == null) {
			return 0;
		} else {
			return 1;
		}
	}
	str = hx_strings_Strings.toLowerCase8(str);
	other = hx_strings_Strings.toLowerCase8(other);
	if(str > other) {
		return 1;
	} else if(str == other) {
		return 0;
	} else {
		return -1;
	}
};
hx_strings_Strings.diff = function(left,right) {
	var diff = new hx_strings_StringDiff();
	diff.at = hx_strings_Strings.diffAt(left,right);
	diff.left = hx_strings_Strings.substr8(left,diff.at);
	diff.right = hx_strings_Strings.substr8(right,diff.at);
	return diff;
};
hx_strings_Strings.diffAt = function(str,other) {
	if(str == other) {
		return -1;
	}
	var strLen = str == null ? 0 : str.length;
	var otherLen = other == null ? 0 : other.length;
	if(strLen == 0 || otherLen == 0) {
		return 0;
	}
	var checkLen = strLen > otherLen ? otherLen : strLen;
	var _g = 0;
	var _g1 = checkLen;
	while(_g < _g1) {
		var i = _g++;
		if(HxOverrides.cca(str,i) != HxOverrides.cca(other,i)) {
			return i;
		}
	}
	return checkLen;
};
hx_strings_Strings.ellipsizeLeft = function(str,maxLength,ellipsis) {
	if(ellipsis == null) {
		ellipsis = "...";
	}
	if((str == null ? 0 : str.length) <= maxLength) {
		return str;
	}
	var ellipsisLen = ellipsis == null ? 0 : ellipsis.length;
	if(maxLength < ellipsisLen) {
		throw haxe_Exception.thrown("[maxLength] must not be smaller than " + ellipsisLen);
	}
	return ellipsis + hx_strings_Strings.right(str,maxLength - ellipsisLen);
};
hx_strings_Strings.ellipsizeMiddle = function(str,maxLength,ellipsis) {
	if(ellipsis == null) {
		ellipsis = "...";
	}
	if((str == null ? 0 : str.length) <= maxLength) {
		return str;
	}
	var ellipsisLen = ellipsis == null ? 0 : ellipsis.length;
	if(maxLength < ellipsisLen) {
		throw haxe_Exception.thrown("[maxLength] must not be smaller than " + ellipsisLen);
	}
	var maxStrLen = maxLength - ellipsisLen;
	var leftLen = Math.round(maxStrLen / 2);
	return ((str == null ? 0 : str.length) <= leftLen ? str : hx_strings_Strings.substring8(str,0,leftLen)) + ellipsis + hx_strings_Strings.right(str,maxStrLen - leftLen);
};
hx_strings_Strings.ellipsizeRight = function(str,maxLength,ellipsis) {
	if(ellipsis == null) {
		ellipsis = "...";
	}
	if((str == null ? 0 : str.length) <= maxLength) {
		return str;
	}
	var ellipsisLen = ellipsis == null ? 0 : ellipsis.length;
	if(maxLength < ellipsisLen) {
		throw haxe_Exception.thrown("[maxLength] must not be smaller than " + ellipsisLen);
	}
	var len = maxLength - ellipsisLen;
	return ((str == null ? 0 : str.length) <= len ? str : hx_strings_Strings.substring8(str,0,len)) + ellipsis;
};
hx_strings_Strings.endsWith = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	return StringTools.endsWith(searchIn,searchFor);
};
hx_strings_Strings.endsWithAny = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(candidate != null && hx_strings_Strings.endsWith(searchIn,candidate)) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.endsWithAnyIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	searchIn = hx_strings_Strings.toLowerCase8(searchIn);
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(candidate != null && hx_strings_Strings.endsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.endsWithIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	return hx_strings_Strings.endsWith(searchIn.toLowerCase(),searchFor.toLowerCase());
};
hx_strings_Strings.equals = function(str,other) {
	return str == other;
};
hx_strings_Strings.equalsIgnoreCase = function(str,other) {
	return hx_strings_Strings.toLowerCase8(str) == hx_strings_Strings.toLowerCase8(other);
};
hx_strings_Strings.filter = function(str,filter,separator) {
	if(separator == null) {
		separator = "";
	}
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings.split8(str,[separator]);
	var _g = [];
	var _g1 = 0;
	while(_g1 < _this.length) {
		var v = _this[_g1];
		++_g1;
		if(filter(v)) {
			_g.push(v);
		}
	}
	return _g.join(separator);
};
hx_strings_Strings.filterChars = function(str,filter) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = hx_strings_Strings.toChars(str);
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(filter(v)) {
			_g.push(v);
		}
	}
	var _this = _g;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = String.fromCodePoint(_this[i]);
	}
	return result.join("");
};
hx_strings_Strings.getFuzzyDistance = function(left,right) {
	if(left == null || left.length == 0 || (right == null || right.length == 0)) {
		return 0;
	}
	left = hx_strings_Strings.toLowerCase8(left);
	right = hx_strings_Strings.toLowerCase8(right);
	var leftChars = hx_strings_Strings.toChars(left);
	var rightChars = hx_strings_Strings.toChars(right);
	var leftLastMatchAt = -100;
	var rightLastMatchAt = -100;
	var score = 0;
	var _g = 0;
	var _g1 = leftChars.length;
	while(_g < _g1) {
		var leftIdx = _g++;
		var leftChar = leftChars[leftIdx];
		var _g2 = rightLastMatchAt > -1 ? rightLastMatchAt + 1 : 0;
		var _g3 = rightChars.length;
		while(_g2 < _g3) {
			var rightIdx = _g2++;
			if(leftChar == rightChars[rightIdx]) {
				++score;
				if(leftLastMatchAt == leftIdx - 1 && rightLastMatchAt == rightIdx - 1) {
					score += 2;
				}
				leftLastMatchAt = leftIdx;
				rightLastMatchAt = rightIdx;
				break;
			}
		}
	}
	return score;
};
hx_strings_Strings.getLevenshteinDistance = function(left,right) {
	var leftLen = left == null ? 0 : left.length;
	var rightLen = right == null ? 0 : right.length;
	if(leftLen == 0) {
		return rightLen;
	}
	if(rightLen == 0) {
		return leftLen;
	}
	if(leftLen > rightLen) {
		var tmp = left;
		left = right;
		right = tmp;
		var tmpLen = leftLen;
		leftLen = rightLen;
		rightLen = tmpLen;
	}
	var prevCosts = [];
	var costs = [];
	var _g = 0;
	var _g1 = leftLen + 1;
	while(_g < _g1) {
		prevCosts.push(_g++);
		costs.push(0);
	}
	var leftChars = hx_strings_Strings.toChars(left);
	var rightChars = hx_strings_Strings.toChars(right);
	var min = function(a,b) {
		if(a > b) {
			return b;
		} else {
			return a;
		}
	};
	var _g = 1;
	var _g1 = rightLen + 1;
	while(_g < _g1) {
		var rightIdx = _g++;
		var rightChar = rightChars[rightIdx - 1];
		costs[0] = rightIdx;
		var _g2 = 1;
		var _g3 = leftLen + 1;
		while(_g2 < _g3) {
			var leftIdx = _g2++;
			var leftIdxMinus1 = leftIdx - 1;
			var cost = leftChars[leftIdxMinus1] == rightChar ? 0 : 1;
			costs[leftIdx] = min(min(costs[leftIdxMinus1] + 1,prevCosts[leftIdx] + 1),prevCosts[leftIdxMinus1] + cost);
		}
		var tmp = prevCosts;
		prevCosts = costs;
		costs = tmp;
	}
	return prevCosts[leftLen];
};
hx_strings_Strings.getLongestCommonSubstring = function(left,right) {
	if(left == null || right == null) {
		return null;
	}
	var leftLen = left == null ? 0 : left.length;
	var rightLen = right == null ? 0 : right.length;
	if(leftLen == 0 || rightLen == 0) {
		return "";
	}
	var leftChars = hx_strings_Strings.toChars(left);
	var rightChars = hx_strings_Strings.toChars(right);
	var leftSubStartAt = 0;
	var leftSubLen = 0;
	var _g = 0;
	var _g1 = leftLen;
	while(_g < _g1) {
		var leftIdx = _g++;
		var _g2 = 0;
		var _g3 = rightLen;
		while(_g2 < _g3) {
			var rightIdx = _g2++;
			var currLen = 0;
			while(leftChars[leftIdx + currLen] == rightChars[rightIdx + currLen]) {
				++currLen;
				if(leftIdx + currLen >= leftLen || rightIdx + currLen >= rightLen) {
					break;
				}
			}
			if(currLen > leftSubLen) {
				leftSubLen = currLen;
				leftSubStartAt = leftIdx;
			}
		}
	}
	return hx_strings_Strings.substr8(left,leftSubStartAt,leftSubLen);
};
hx_strings_Strings.hashCode = function(str,algo) {
	if(str == null || str.length == 0) {
		return 0;
	}
	if(algo == null) {
		algo = hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC;
	}
	if(algo == null) {
		return haxe_crypto_Crc32.make(str == null ? null : haxe_io_Bytes.ofString(str));
	} else {
		switch(algo._hx_index) {
		case 1:
			return haxe_crypto_Adler32.make(str == null ? null : haxe_io_Bytes.ofString(str));
		case 2:
			return haxe_crypto_Crc32.make(str == null ? null : haxe_io_Bytes.ofString(str));
		case 3:
			var hc = 5381;
			var _g = 0;
			var _g1 = hx_strings_Strings.toChars(str);
			while(_g < _g1.length) hc = ((hc << 5) + hc | 0) ^ _g1[_g++];
			return hc;
		case 4:
			var hc = 0;
			var _g = 0;
			var _g1 = hx_strings_Strings.toChars(str);
			while(_g < _g1.length) hc = ((hc << 5) - hc | 0) + _g1[_g++] | 0;
			return hc;
		case 5:
			var hc = 0;
			var _g = 0;
			var _g1 = hx_strings_Strings.toChars(str);
			while(_g < _g1.length) hc = (((hc << 6) + (hc << 16) | 0) - hc | 0) + _g1[_g++] | 0;
			return hc;
		default:
			return haxe_crypto_Crc32.make(str == null ? null : haxe_io_Bytes.ofString(str));
		}
	}
};
hx_strings_Strings.htmlDecode = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings.REGEX_HTML_UNESCAPE;
	return new hx_strings__$Pattern_MatcherImpl(_this.ereg,_this.pattern,_this.options,str).map(function(m) {
		var match = m.matched();
		switch(match) {
		case "&amp;":
			return "&";
		case "&apos;":
			return "'";
		case "&gt;":
			return ">";
		case "&lt;":
			return "<";
		case "&nbsp;":
			return " ";
		case "&quot;":
			return "\"";
		default:
			var this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(match == null ? 0 : match.length) - 3));
			return String.fromCodePoint(this1);
		}
	});
};
hx_strings_Strings.htmlEncode = function(str,escapeQuotes) {
	if(escapeQuotes == null) {
		escapeQuotes = false;
	}
	if(str == null || str.length == 0) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	var isFirstSpace = true;
	var _g = 0;
	var _g1 = str == null ? 0 : str.length;
	while(_g < _g1) {
		var ch = HxOverrides.cca(str,_g++);
		switch(ch) {
		case 32:
			if(isFirstSpace) {
				sb.add(" ");
				isFirstSpace = false;
			} else {
				sb.add("&nbsp;");
			}
			break;
		case 34:
			sb.add(escapeQuotes ? "&quot;" : "\"");
			break;
		case 38:
			sb.add("&amp;");
			break;
		case 39:
			sb.add(escapeQuotes ? "&#039;" : "'");
			break;
		case 60:
			sb.add("&lt;");
			break;
		case 62:
			sb.add("&gt;");
			break;
		default:
			if(ch > 127) {
				sb.add("&#").add(Std.string(ch)).add(";");
			} else {
				sb.addChar(ch);
			}
		}
		if(ch != 32) {
			isFirstSpace = true;
		}
	}
	return sb.toString();
};
hx_strings_Strings.insertAt = function(str,pos,insertion) {
	if(str == null) {
		return null;
	}
	var strLen = str == null ? 0 : str.length;
	if(pos < 0) {
		pos = strLen + pos;
	}
	if(pos < 0 || pos > strLen) {
		throw haxe_Exception.thrown("Absolute value of [pos] must be <= str.length");
	}
	if(insertion == null || insertion.length == 0) {
		return str;
	}
	return hx_strings_Strings.substring8(str,0,pos) + insertion + hx_strings_Strings.substring8(str,pos);
};
hx_strings_Strings.ifBlank = function(str,fallback) {
	if(str == null ? true : StringTools.trim(str).length == 0) {
		return fallback;
	} else {
		return str;
	}
};
hx_strings_Strings.ifEmpty = function(str,fallback) {
	if(str == null || str.length == 0) {
		return fallback;
	} else {
		return str;
	}
};
hx_strings_Strings.ifNull = function(str,fallback) {
	if(str == null) {
		return fallback;
	} else {
		return str;
	}
};
hx_strings_Strings.indentLines = function(str,indentWith) {
	if(str == null) {
		return null;
	}
	if(str.length == 0 || (indentWith == null || indentWith.length == 0)) {
		return str;
	}
	var isFirstLine = true;
	var sb = new hx_strings_StringBuilder();
	var _g = 0;
	var _g1 = hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(str);
	while(_g < _g1.length) {
		var line = _g1[_g++];
		if(isFirstLine) {
			isFirstLine = false;
		} else {
			sb.newLine();
		}
		sb.add(indentWith);
		sb.add(line);
	}
	return sb.toString();
};
hx_strings_Strings.indexOf8 = function(str,searchFor,startAt) {
	if(startAt == null) {
		startAt = 0;
	}
	if(str == null || searchFor == null) {
		return -1;
	}
	var strLen = str == null ? 0 : str.length;
	if(startAt < 0) {
		startAt = 0;
	}
	if((searchFor == null ? 0 : searchFor.length) == 0) {
		if(startAt == 0) {
			return 0;
		}
		if(startAt > 0 && startAt < strLen) {
			return startAt;
		}
		return strLen;
	}
	if(startAt >= strLen) {
		return -1;
	}
	return str.indexOf(searchFor,startAt);
};
hx_strings_Strings.isBlank = function(str) {
	if(str == null) {
		return true;
	} else {
		return StringTools.trim(str).length == 0;
	}
};
hx_strings_Strings.isDigits = function(str) {
	if(str == null || str.length == 0) {
		return false;
	}
	var _g = 0;
	var _g1 = str == null ? 0 : str.length;
	while(_g < _g1) {
		var this1 = HxOverrides.cca(str,_g++);
		if(!(this1 > 47 && this1 < 58)) {
			return false;
		}
	}
	return true;
};
hx_strings_Strings.isEmpty = function(str) {
	if(str != null) {
		return str.length == 0;
	} else {
		return true;
	}
};
hx_strings_Strings.isNotBlank = function(str) {
	if(str != null) {
		return StringTools.trim(str).length > 0;
	} else {
		return false;
	}
};
hx_strings_Strings.isNotEmpty = function(str) {
	if(str != null) {
		return str.length > 0;
	} else {
		return false;
	}
};
hx_strings_Strings.isLowerCase = function(str) {
	if(str == null || str.length == 0) {
		return false;
	}
	return str == hx_strings_Strings.toLowerCase8(str);
};
hx_strings_Strings.isUpperCase = function(str) {
	if(str == null || str.length == 0) {
		return false;
	}
	return str == hx_strings_Strings.toUpperCase8(str);
};
hx_strings_Strings.iterate = function(str,callback,separator) {
	if(separator == null) {
		separator = "";
	}
	if(str == null || str.length == 0) {
		return;
	}
	var _g = 0;
	var _g1 = hx_strings_Strings.split8(str,[separator]);
	while(_g < _g1.length) callback(_g1[_g++]);
};
hx_strings_Strings.iterateChars = function(str,callback) {
	if(str == null || str.length == 0) {
		return;
	}
	var _g = 0;
	var _g1 = str == null ? 0 : str.length;
	while(_g < _g1) callback(HxOverrides.cca(str,_g++));
};
hx_strings_Strings.lastIndexOf8 = function(str,searchFor,startAt) {
	if(str == null || searchFor == null) {
		return -1;
	}
	var strLen = str == null ? 0 : str.length;
	var searchForLen = searchFor == null ? 0 : searchFor.length;
	if(startAt == null) {
		startAt = strLen;
	}
	if(searchForLen == 0) {
		if(startAt < 0) {
			return 0;
		}
		if(startAt > strLen) {
			return strLen;
		}
		return startAt;
	}
	if(startAt < 0) {
		return -1;
	} else if(startAt >= strLen) {
		startAt = strLen - 1;
	}
	var strNeedsUTF8Workaround = str.length != strLen;
	var searchForNeedsUTF8Workaround = searchFor.length != searchForLen;
	if(!strNeedsUTF8Workaround && !searchForNeedsUTF8Workaround) {
		return str.lastIndexOf(searchFor,startAt);
	}
	if(searchForNeedsUTF8Workaround && !strNeedsUTF8Workaround) {
		return -1;
	}
	var searchForChars = hx_strings_Strings.toChars(searchFor);
	startAt += searchForLen - 1;
	var searchForPosToCheck = searchForLen - 1;
	var strPos = strLen;
	while(strPos-- > 0) {
		if(strPos > startAt) {
			continue;
		}
		if(HxOverrides.cca(str,strPos) == searchForChars[searchForPosToCheck]) {
			if(searchForPosToCheck == 0) {
				return strPos;
			}
			--searchForPosToCheck;
		} else {
			searchForPosToCheck = searchForLen - 1;
		}
	}
	return -1;
};
hx_strings_Strings.length8 = function(str) {
	if(str == null) {
		return 0;
	}
	return str.length;
};
hx_strings_Strings.left = function(str,len) {
	if((str == null ? 0 : str.length) <= len) {
		return str;
	}
	return hx_strings_Strings.substring8(str,0,len);
};
hx_strings_Strings.lpad = function(str,targetLength,padStr,canOverflow) {
	if(canOverflow == null) {
		canOverflow = true;
	}
	if(padStr == null) {
		padStr = " ";
	}
	var strLen = str == null ? 0 : str.length;
	if(str == null || strLen > targetLength) {
		return str;
	}
	if(padStr == null || padStr.length == 0) {
		padStr = " ";
	}
	var sb = [str];
	var padLen = padStr == null ? 0 : padStr.length;
	while(strLen < targetLength) {
		sb.unshift(padStr);
		strLen += padLen;
	}
	if(canOverflow) {
		return sb.join("");
	}
	return hx_strings_Strings.right(sb.join(""),targetLength);
};
hx_strings_Strings.map = function(str,mapper,separator) {
	if(separator == null) {
		separator = "";
	}
	if(str == null) {
		return null;
	}
	if(separator == null) {
		throw haxe_Exception.thrown("[separator] must not be null");
	}
	var _this = hx_strings_Strings.split8(str,[separator]);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = mapper(_this[i]);
	}
	return result;
};
hx_strings_Strings.prependIfMissing = function(str,suffix) {
	if(str == null) {
		return null;
	}
	if(str.length == 0) {
		return suffix + str;
	}
	if(hx_strings_Strings.startsWith(str,suffix)) {
		return str;
	}
	return suffix + str;
};
hx_strings_Strings.quoteDouble = function(str) {
	if(str == null) {
		return str;
	}
	if(str.length == 0) {
		return "\"\"";
	}
	if(!(str == null ? false : str.indexOf("\"") > -1)) {
		return "\"" + str + "\"";
	}
	return "\"" + hx_strings_Strings.replaceAll(str,"\"","\\\"") + "\"";
};
hx_strings_Strings.quoteSingle = function(str) {
	if(str == null) {
		return str;
	}
	if(str.length == 0) {
		return "''";
	}
	if(!(str == null ? false : str.indexOf("'") > -1)) {
		return "'" + str + "'";
	}
	return "'" + hx_strings_Strings.replaceAll(str,"'","\\'") + "'";
};
hx_strings_Strings.removeAfter = function(str,searchFor) {
	return hx_strings_Strings.substringBefore(str,searchFor);
};
hx_strings_Strings.removeAfterLast = function(str,searchFor) {
	return hx_strings_Strings.substringBeforeLast(str,searchFor);
};
hx_strings_Strings.removeAfterIgnoreCase = function(str,searchFor) {
	return hx_strings_Strings.substringBeforeIgnoreCase(str,searchFor);
};
hx_strings_Strings.removeAfterLastIgnoreCase = function(str,searchFor) {
	return hx_strings_Strings.substringBeforeLastIgnoreCase(str,searchFor);
};
hx_strings_Strings.removeAt = function(str,pos,length) {
	if(str == null || str.length == 0 || length < 1) {
		return str;
	}
	var strLen = str == null ? 0 : str.length;
	if(pos < 0) {
		pos = strLen + pos;
	}
	if(pos < 0) {
		throw haxe_Exception.thrown("[pos] must be smaller than -1 * str.length");
	}
	if(pos + length >= strLen) {
		return hx_strings_Strings.substring8(str,0,pos);
	}
	return hx_strings_Strings.substring8(str,0,pos) + hx_strings_Strings.substring8(str,pos + length);
};
hx_strings_Strings.removeBefore = function(str,searchFor) {
	return hx_strings_Strings.substringAfter(str,searchFor);
};
hx_strings_Strings.removeBeforeLast = function(str,searchFor) {
	return hx_strings_Strings.substringAfterLast(str,searchFor);
};
hx_strings_Strings.removeBeforeIgnoreCase = function(str,searchFor) {
	return hx_strings_Strings.substringAfterIgnoreCase(str,searchFor);
};
hx_strings_Strings.removeBeforeLastIgnoreCase = function(str,searchFor) {
	return hx_strings_Strings.substringAfterLastIgnoreCase(str,searchFor);
};
hx_strings_Strings.removeAll = function(searchIn,searchFor) {
	return hx_strings_Strings.replaceAll(searchIn,searchFor,"");
};
hx_strings_Strings.removeFirst = function(searchIn,searchFor) {
	return hx_strings_Strings.replaceFirst(searchIn,searchFor,"");
};
hx_strings_Strings.removeFirstIgnoreCase = function(searchIn,searchFor) {
	return hx_strings_Strings.replaceFirstIgnoreCase(searchIn,searchFor,"");
};
hx_strings_Strings.removeAnsi = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	return str.replace(hx_strings_Strings.REGEX_ANSI_ESC.ereg.r,"");
};
hx_strings_Strings.removeLeading = function(searchIn,searchFor) {
	if(searchIn == null || searchIn.length == 0 || (searchFor == null || searchFor.length == 0)) {
		return searchIn;
	}
	while(hx_strings_Strings.startsWith(searchIn,searchFor)) searchIn = searchIn.substring(searchFor.length,searchIn.length);
	return searchIn;
};
hx_strings_Strings.removeTags = function(xml) {
	if(xml == null || xml.length == 0) {
		return xml;
	}
	return xml.replace(hx_strings_Strings.REGEX_REMOVE_XML_TAGS.ereg.r,"");
};
hx_strings_Strings.removeTrailing = function(searchIn,searchFor) {
	if(searchIn == null || searchIn.length == 0 || (searchFor == null || searchFor.length == 0)) {
		return searchIn;
	}
	while(hx_strings_Strings.endsWith(searchIn,searchFor)) searchIn = searchIn.substring(0,searchIn.length - searchFor.length);
	return searchIn;
};
hx_strings_Strings.repeat = function(str,count,separator) {
	if(separator == null) {
		separator = "";
	}
	if(str == null) {
		return null;
	}
	if(count < 1) {
		return "";
	}
	if(count == 1) {
		return str;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < count) {
		++_g1;
		_g.push(str);
	}
	return _g.join(separator);
};
hx_strings_Strings.replaceAll = function(searchIn,searchFor,replaceWith) {
	if(searchIn == null || (searchIn == null || searchIn.length == 0) || searchFor == null) {
		return searchIn;
	}
	if(replaceWith == null) {
		replaceWith = "null";
	}
	return StringTools.replace(searchIn,searchFor,replaceWith);
};
hx_strings_Strings.replaceFirst = function(searchIn,searchFor,replaceWith) {
	if(searchIn == null || (searchIn == null || searchIn.length == 0) || searchFor == null) {
		return searchIn;
	}
	if(replaceWith == null) {
		replaceWith = "null";
	}
	var foundAt;
	if(searchFor.length == 0) {
		if((searchIn == null ? 0 : searchIn.length) > 1) {
			foundAt = 1;
		} else {
			return searchIn;
		}
	} else {
		foundAt = hx_strings_Strings.indexOf8(searchIn,searchFor);
	}
	return hx_strings_Strings.substr8(searchIn,0,foundAt) + replaceWith + hx_strings_Strings.substr8(searchIn,foundAt + (searchFor == null ? 0 : searchFor.length));
};
hx_strings_Strings.replaceFirstIgnoreCase = function(searchIn,searchFor,replaceWith) {
	if(searchIn == null || (searchIn == null || searchIn.length == 0) || searchFor == null) {
		return searchIn;
	}
	if(replaceWith == null) {
		replaceWith = "null";
	}
	searchFor = searchFor.toLowerCase();
	var foundAt;
	if(searchFor.length == 0) {
		if((searchIn == null ? 0 : searchIn.length) > 1) {
			foundAt = 1;
		} else {
			return searchIn;
		}
	} else {
		foundAt = hx_strings_Strings.indexOf8(searchIn.toLowerCase(),searchFor);
	}
	return hx_strings_Strings.substr8(searchIn,0,foundAt) + replaceWith + hx_strings_Strings.substr8(searchIn,foundAt + (searchFor == null ? 0 : searchFor.length));
};
hx_strings_Strings.reverse = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var chars = hx_strings_Strings.split8(str,[""]);
	chars.reverse();
	return chars.join("");
};
hx_strings_Strings.right = function(str,len) {
	if(str == null || str.length == 0) {
		return str;
	}
	return hx_strings_Strings.substring8(str,(str == null ? 0 : str.length) - len);
};
hx_strings_Strings.rpad = function(str,targetLength,padStr,canOverflow) {
	if(canOverflow == null) {
		canOverflow = true;
	}
	if(padStr == null) {
		padStr = " ";
	}
	var strLen = str == null ? 0 : str.length;
	if(str == null || strLen > targetLength) {
		return str;
	}
	if(padStr == null || padStr.length == 0) {
		padStr = " ";
	}
	var padLen = padStr == null ? 0 : padStr.length;
	var sb = new hx_strings_StringBuilder(str);
	while(strLen < targetLength) {
		sb.add(padStr);
		strLen += padLen;
	}
	if(canOverflow) {
		return sb.toString();
	}
	var str = sb.toString();
	if((str == null ? 0 : str.length) <= targetLength) {
		return str;
	} else {
		return hx_strings_Strings.substring8(str,0,targetLength);
	}
};
hx_strings_Strings.split8 = function(str,separator,maxParts) {
	if(maxParts == null) {
		maxParts = 0;
	}
	if(str == null || separator == null) {
		return null;
	}
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0) {
		return [];
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = separator;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	if(_g.length == 0) {
		return null;
	}
	if(maxParts <= 0 && _g.length == 1) {
		return str.split(_g[0]);
	}
	if(_g.indexOf("") > -1) {
		if(maxParts <= 0) {
			var _g1 = [];
			var _g2 = 0;
			var _g3 = strLen;
			while(_g2 < _g3) _g1.push(HxOverrides.substr(str,_g2++,1));
			return _g1;
		}
		if(maxParts > strLen) {
			maxParts = strLen;
		}
		--maxParts;
		var _g1 = [];
		var _g2 = 0;
		var _g3 = maxParts;
		while(_g2 < _g3) _g1.push(HxOverrides.substr(str,_g2++,1));
		_g1.push(HxOverrides.substr(str,maxParts,strLen - maxParts));
		return _g1;
	}
	var _g1 = [];
	var _g2 = 0;
	while(_g2 < _g.length) {
		var sep = _g[_g2];
		++_g2;
		_g1.push(sep == null ? 0 : sep.length);
	}
	var lastFoundAt = 0;
	var result = [];
	var resultCount = 0;
	while(true) {
		var separatorLen = 0;
		var foundAt = -1;
		var _g2 = 0;
		var _g3 = _g.length;
		while(_g2 < _g3) {
			var i = _g2++;
			var sepFoundAt = hx_strings_Strings.indexOf8(str,_g[i],lastFoundAt);
			if(sepFoundAt != -1) {
				if(foundAt == -1 || sepFoundAt < foundAt) {
					foundAt = sepFoundAt;
					separatorLen = _g1[i];
				}
			}
		}
		++resultCount;
		if(foundAt == -1 || resultCount == maxParts) {
			result.push(HxOverrides.substr(str,lastFoundAt,strLen - lastFoundAt));
			break;
		}
		result.push(HxOverrides.substr(str,lastFoundAt,foundAt - lastFoundAt));
		lastFoundAt = foundAt + separatorLen;
	}
	return result;
};
hx_strings_Strings.splitAt = function(str,splitPos) {
	if(str == null) {
		return null;
	}
	if(splitPos == null || splitPos.length == 0) {
		return [str];
	}
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0) {
		return [str];
	}
	var pos = [];
	var _g = 0;
	var _g1 = splitPos;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p < 0) {
			p = strLen + p;
		}
		if(p < 0 || p >= strLen) {
			continue;
		}
		if(pos.indexOf(p) > -1) {
			continue;
		}
		pos.push(p);
	}
	pos.sort(function(a,b) {
		if(a < b) {
			return -1;
		} else if(a > b) {
			return 1;
		} else {
			return 0;
		}
	});
	var result = [];
	var lastPos = 0;
	var _g = 0;
	while(_g < pos.length) {
		var p = pos[_g];
		++_g;
		var chunk = hx_strings_Strings.substring8(str,lastPos,p);
		if(chunk != null && chunk.length > 0) {
			result.push(chunk);
		}
		lastPos = p;
	}
	var chunk = hx_strings_Strings.substring8(str,lastPos);
	if(chunk != null && chunk.length > 0) {
		result.push(chunk);
	}
	return result;
};
hx_strings_Strings.splitEvery = function(str,count) {
	if(str == null) {
		return null;
	}
	if(count < 1) {
		throw haxe_Exception.thrown("[count] must be greater than 0");
	}
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0 || count >= strLen) {
		return [str];
	}
	var result = [];
	var pos = 0;
	while(true) {
		var chunk = hx_strings_Strings.substr8(str,pos,count);
		pos += count;
		if(chunk == null || chunk.length == 0) {
			break;
		}
		result.push(chunk);
	}
	return result;
};
hx_strings_Strings.splitLines = function(str) {
	if(str == null || str.length == 0) {
		return [];
	} else {
		return hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(str);
	}
};
hx_strings_Strings.startsWith = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	if(searchFor == null || searchFor.length == 0 || searchIn == searchFor) {
		return true;
	}
	return StringTools.startsWith(searchIn,searchFor);
};
hx_strings_Strings.startsWithAny = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(candidate != null && hx_strings_Strings.startsWith(searchIn,candidate)) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.startsWithAnyIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	searchIn = hx_strings_Strings.toLowerCase8(searchIn);
	var _g = 0;
	while(_g < searchFor.length) {
		var candidate = searchFor[_g];
		++_g;
		if(candidate != null && hx_strings_Strings.startsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))) {
			return true;
		}
	}
	return false;
};
hx_strings_Strings.startsWithIgnoreCase = function(searchIn,searchFor) {
	if(searchIn == null || searchFor == null) {
		return false;
	}
	if(searchFor == null || searchFor.length == 0) {
		return true;
	}
	return hx_strings_Strings.startsWith(searchIn.toLowerCase(),searchFor.toLowerCase());
};
hx_strings_Strings.substr8 = function(str,startAt,len) {
	if(str == null || str.length == 0) {
		return str;
	}
	if(len == null) {
		len = str == null ? 0 : str.length;
	}
	if(len <= 0) {
		return "";
	}
	if(startAt < 0) {
		startAt += str == null ? 0 : str.length;
		if(startAt < 0) {
			startAt = 0;
		}
	}
	return HxOverrides.substr(str,startAt,len);
};
hx_strings_Strings.substring8 = function(str,startAt,endAt) {
	if(str == null || str.length == 0) {
		return str;
	}
	if(endAt == null) {
		endAt = str == null ? 0 : str.length;
	}
	return str.substring(startAt,endAt);
};
hx_strings_Strings.substringAfter = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundAt = str.indexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAt + searchFor.length);
};
hx_strings_Strings.substringAfterIgnoreCase = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	searchFor = searchFor.toLowerCase();
	var foundAt = str.toLowerCase().indexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAt + searchFor.length);
};
hx_strings_Strings.substringBetween = function(str,after,before,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(before == null) {
		before = after;
	}
	if(str == "" || (after == null || after.length == 0) || (before == null || before.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundAfterAt = str.indexOf(after);
	if(foundAfterAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundBeforeAt = str.indexOf(before,foundAfterAt + after.length);
	if(foundBeforeAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAfterAt + after.length,foundBeforeAt);
};
hx_strings_Strings.substringBetweenIgnoreCase = function(str,after,before,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(before == null) {
		before = after;
	}
	if(str == "" || (after == null || after.length == 0) || (before == null || before.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var strLower = hx_strings_Strings.toLowerCase8(str);
	after = hx_strings_Strings.toLowerCase8(after);
	before = hx_strings_Strings.toLowerCase8(before);
	var foundAfterAt = strLower.indexOf(after);
	if(foundAfterAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundBeforeAt = strLower.indexOf(before,foundAfterAt + after.length);
	if(foundBeforeAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAfterAt + after.length,foundBeforeAt);
};
hx_strings_Strings.substringAfterLast = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundAt = str.lastIndexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAt + searchFor.length);
};
hx_strings_Strings.substringAfterLastIgnoreCase = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	searchFor = searchFor.toLowerCase();
	var foundAt = str.toLowerCase().lastIndexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(foundAt + searchFor.length);
};
hx_strings_Strings.substringBefore = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundAt = str.indexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(0,foundAt);
};
hx_strings_Strings.substringBeforeIgnoreCase = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	searchFor = searchFor.toLowerCase();
	var foundAt = str.toLowerCase().indexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(0,foundAt);
};
hx_strings_Strings.substringBeforeLast = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	var foundAt = str.lastIndexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(0,foundAt);
};
hx_strings_Strings.substringBeforeLastIgnoreCase = function(str,searchFor,notFoundDefault) {
	if(notFoundDefault == null) {
		notFoundDefault = 2;
	}
	if(str == null) {
		return null;
	}
	if(str == "" || (searchFor == null || searchFor.length == 0)) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	searchFor = searchFor.toLowerCase();
	var foundAt = str.toLowerCase().lastIndexOf(searchFor);
	if(foundAt == -1) {
		switch(notFoundDefault) {
		case 1:
			return null;
		case 2:
			return "";
		case 3:
			return str;
		}
	}
	return str.substring(0,foundAt);
};
hx_strings_Strings.toBool = function(str) {
	if(str == null || str.length == 0) {
		return false;
	}
	switch(str.toLowerCase()) {
	case "0":case "false":case "no":
		return false;
	default:
		return true;
	}
};
hx_strings_Strings.toBytes = function(str) {
	if(str == null) {
		return null;
	}
	return haxe_io_Bytes.ofString(str);
};
hx_strings_Strings.toChar = function(charCode) {
	return charCode;
};
hx_strings_Strings.toCharIterator = function(str) {
	if(str == null) {
		return hx_strings__$CharIterator_NullCharIterator.INSTANCE;
	} else {
		return new hx_strings__$CharIterator_StringCharIterator(str,0);
	}
};
hx_strings_Strings.toChars = function(str) {
	if(str == null) {
		return null;
	}
	var strLen = str == null ? 0 : str.length;
	if(strLen == 0) {
		return [];
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = strLen;
	while(_g1 < _g2) _g.push(HxOverrides.cca(str,_g1++));
	return _g;
};
hx_strings_Strings.toPattern = function(str,options) {
	if(str == null) {
		return null;
	}
	return hx_strings_Pattern.compile(str,options);
};
hx_strings_Strings.toEReg = function(str,opt) {
	if(opt == null) {
		opt = "";
	}
	if(str == null) {
		return null;
	}
	return new EReg(str,opt);
};
hx_strings_Strings.toFloat = function(str,ifUnparseable) {
	var result = parseFloat(str);
	if(isNaN(result)) {
		return ifUnparseable;
	}
	return result;
};
hx_strings_Strings.toHex = function(num,minDigits,upperCase) {
	if(upperCase == null) {
		upperCase = true;
	}
	if(minDigits == null) {
		minDigits = 0;
	}
	var hexed = StringTools.hex(num,0);
	if(!upperCase) {
		return hexed.toLowerCase();
	}
	if(hexed.length >= minDigits) {
		return hexed;
	}
	return hx_strings_Strings.lpad(hexed,minDigits,"0");
};
hx_strings_Strings.toInt = function(str,ifUnparseable) {
	var result = Std.parseInt(str);
	if(result == null) {
		return ifUnparseable;
	}
	return result;
};
hx_strings_Strings.toLowerCase8 = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	return str.toLowerCase();
};
hx_strings_Strings.toLowerCaseFirstChar = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var this1 = HxOverrides.cca(str,0);
	var lowerChar = hx_strings_Char.CHAR_CASE_MAPPER.mapU2L.h[this1];
	var firstChar = lowerChar == null ? this1 : lowerChar;
	if(str.length == 1) {
		return String.fromCodePoint(firstChar);
	}
	var other = hx_strings_Strings.substr8(str,1);
	return String.fromCodePoint(firstChar) + other;
};
hx_strings_Strings.toLowerCamel = function(str,keepUppercasedWords) {
	if(keepUppercasedWords == null) {
		keepUppercasedWords = true;
	}
	if(str == null || str.length == 0) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	if(keepUppercasedWords) {
		var _g = 0;
		var _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(str);
		while(_g < _g1.length) sb.add(hx_strings_Strings.toUpperCaseFirstChar(_g1[_g++]));
	} else {
		var _g = 0;
		var _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(str);
		while(_g < _g1.length) sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(_g1[_g++])));
	}
	return hx_strings_Strings.toLowerCaseFirstChar(sb.toString());
};
hx_strings_Strings.toLowerHyphen = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings._splitAsciiWordsUnsafe(str);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = hx_strings_Strings.toLowerCase8(_this[i]);
	}
	return result.join("-");
};
hx_strings_Strings.toLowerUnderscore = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings._splitAsciiWordsUnsafe(str);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = hx_strings_Strings.toLowerCase8(_this[i]);
	}
	return result.join("_");
};
hx_strings_Strings.toTitle = function(str,keepUppercasedWords) {
	if(keepUppercasedWords == null) {
		keepUppercasedWords = true;
	}
	if(str == null || str.length == 0) {
		return str;
	}
	if(keepUppercasedWords) {
		var _this = hx_strings_Strings._splitAsciiWordsUnsafe(str);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var s = _this[i];
			result[i] = hx_strings_Strings.toUpperCase8(s) == s ? s : hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s));
		}
		return result.join(" ");
	}
	var _this = hx_strings_Strings._splitAsciiWordsUnsafe(str);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(_this[i]));
	}
	return result.join(" ");
};
hx_strings_Strings.toUpperCamel = function(str,keepUppercasedWords) {
	if(keepUppercasedWords == null) {
		keepUppercasedWords = true;
	}
	if(str == null || str.length == 0) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	if(keepUppercasedWords) {
		var _g = 0;
		var _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(str);
		while(_g < _g1.length) sb.add(hx_strings_Strings.toUpperCaseFirstChar(_g1[_g++]));
	} else {
		var _g = 0;
		var _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(str);
		while(_g < _g1.length) sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(_g1[_g++])));
	}
	return sb.toString();
};
hx_strings_Strings.toUpperUnderscore = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings._splitAsciiWordsUnsafe(str);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = hx_strings_Strings.toUpperCase8(_this[i]);
	}
	return result.join("_");
};
hx_strings_Strings.toString = function(str) {
	if(str == null) {
		return "null";
	} else {
		return str;
	}
};
hx_strings_Strings.toUpperCase8 = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	var _g = 0;
	var _g1 = str == null ? 0 : str.length;
	while(_g < _g1) {
		var this1 = HxOverrides.cca(str,_g++);
		var upperChar = hx_strings_Char.CHAR_CASE_MAPPER.mapL2U.h[this1];
		sb.addChar(upperChar == null ? this1 : upperChar);
	}
	return sb.toString();
};
hx_strings_Strings.toUpperCaseFirstChar = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	var this1 = HxOverrides.cca(str,0);
	var upperChar = hx_strings_Char.CHAR_CASE_MAPPER.mapL2U.h[this1];
	var firstChar = upperChar == null ? this1 : upperChar;
	if(str.length == 1) {
		return String.fromCodePoint(firstChar);
	}
	var other = hx_strings_Strings.substr8(str,1);
	return String.fromCodePoint(firstChar) + other;
};
hx_strings_Strings.trim = function(str,charsToRemove) {
	if(str == null || str.length == 0) {
		return str;
	}
	if(charsToRemove == null) {
		return StringTools.trim(str);
	}
	var removableChars;
	var _g = charsToRemove;
	switch(_g._hx_index) {
	case 0:
		removableChars = hx_strings_Strings.toChars(_g.v);
		break;
	case 1:
		removableChars = _g.v;
		break;
	}
	return hx_strings_Strings.trimLeft(hx_strings_Strings.trimRight(str,hx_strings_internal__$Either2__$Either2.b(removableChars)),hx_strings_internal__$Either2__$Either2.b(removableChars));
};
hx_strings_Strings.trimRight = function(str,charsToRemove) {
	if(str == null || str.length == 0) {
		return str;
	}
	if(charsToRemove == null) {
		return StringTools.rtrim(str);
	}
	var removableChars;
	var _g = charsToRemove;
	switch(_g._hx_index) {
	case 0:
		removableChars = hx_strings_Strings.toChars(_g.v);
		break;
	case 1:
		removableChars = _g.v;
		break;
	}
	if(removableChars.length == 0) {
		return str;
	}
	var len = str == null ? 0 : str.length;
	var i = len - 1;
	while(true) {
		var tmp;
		if(i > -1) {
			var str1 = hx_strings_Strings.charAt8(str,i);
			var strLen = str1 == null ? 0 : str1.length;
			tmp = removableChars.indexOf(strLen == 0 || 0 >= strLen ? -1 : HxOverrides.cca(str1,0)) > -1;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--i;
	}
	if(i < len - 1) {
		return hx_strings_Strings.substring8(str,0,i + 1);
	}
	return str;
};
hx_strings_Strings.trimLeft = function(str,charsToRemove) {
	if(str == null) {
		return str;
	}
	if(charsToRemove == null) {
		return StringTools.ltrim(str);
	}
	var removableChars;
	var _g = charsToRemove;
	switch(_g._hx_index) {
	case 0:
		removableChars = hx_strings_Strings.toChars(_g.v);
		break;
	case 1:
		removableChars = _g.v;
		break;
	}
	if(removableChars.length == 0) {
		return str;
	}
	var len = str == null ? 0 : str.length;
	var i = 0;
	while(true) {
		var tmp;
		if(i < len) {
			var str1 = hx_strings_Strings.charAt8(str,i);
			var strLen = str1 == null ? 0 : str1.length;
			tmp = removableChars.indexOf(strLen == 0 || 0 >= strLen ? -1 : HxOverrides.cca(str1,0)) > -1;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		++i;
	}
	if(i > 0) {
		return hx_strings_Strings.substring8(str,i,len);
	}
	return str;
};
hx_strings_Strings.trimLines = function(str,charsToRemove) {
	if(str == null || str.length == 0) {
		return str;
	}
	var _this = hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(str);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = hx_strings_Strings.trim(_this[i],charsToRemove);
	}
	return result.join("\n");
};
hx_strings_Strings.trimToNull = function(str) {
	if(str == null) {
		return null;
	}
	var trimmed = hx_strings_Strings.trim(str);
	if(trimmed == null || trimmed.length == 0) {
		return null;
	}
	return trimmed;
};
hx_strings_Strings.trimToEmpty = function(str) {
	var trimmed = hx_strings_Strings.trim(str);
	if(trimmed == null || trimmed.length == 0) {
		return "";
	}
	return trimmed;
};
hx_strings_Strings.truncate = function(str,maxLength) {
	if((str == null ? 0 : str.length) <= maxLength) {
		return str;
	} else {
		return hx_strings_Strings.substring8(str,0,maxLength);
	}
};
hx_strings_Strings.urlDecode = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	return decodeURIComponent(str.split("+").join(" "));
};
hx_strings_Strings.urlEncode = function(str) {
	if(str == null || str.length == 0) {
		return str;
	}
	return encodeURIComponent(str);
};
hx_strings_Strings.wrap = function(str,maxLineLength,splitLongWords,newLineSeparator) {
	if(newLineSeparator == null) {
		newLineSeparator = "\n";
	}
	if(splitLongWords == null) {
		splitLongWords = true;
	}
	if((str == null ? 0 : str.length) <= maxLineLength || maxLineLength < 1) {
		return str;
	}
	var sb = new hx_strings_StringBuilder();
	var wordChars = [];
	var currLineLength = 0;
	var _g = 0;
	var _g1 = hx_strings_Strings.toChars(str);
	while(_g < _g1.length) {
		var ch = _g1[_g];
		++_g;
		if(ch > 8 && ch < 14 || ch == 32) {
			if(wordChars.length > 0) {
				var _g2 = 0;
				while(_g2 < wordChars.length) {
					var wordCh = wordChars[_g2++];
					if(currLineLength == maxLineLength && splitLongWords) {
						sb.add(newLineSeparator);
						currLineLength = 0;
					}
					++currLineLength;
					sb.addChar(wordCh);
				}
				wordChars = [];
			}
			if(currLineLength >= maxLineLength) {
				sb.add(newLineSeparator);
				currLineLength = 0;
			}
			sb.addChar(ch);
			++currLineLength;
		} else {
			wordChars.push(ch);
		}
	}
	if(wordChars.length > 0) {
		var _g = 0;
		while(_g < wordChars.length) {
			var wordCh = wordChars[_g++];
			if(currLineLength == maxLineLength && splitLongWords) {
				sb.add(newLineSeparator);
				currLineLength = 0;
			}
			++currLineLength;
			sb.addChar(wordCh);
		}
	}
	return sb.toString();
};
var hx_strings_StringDiff = function() {
};
hx_strings_StringDiff.__name__ = "hx.strings.StringDiff";
hx_strings_StringDiff.prototype = {
	at: null
	,left: null
	,right: null
	,toString: function() {
		return "StringDiff[at=" + this.at + ", left=" + this.left + ", right=" + this.right + "]";
	}
	,__class__: hx_strings_StringDiff
};
var hx_strings_HashCodeAlgorithm = $hxEnums["hx.strings.HashCodeAlgorithm"] = { __ename__:"hx.strings.HashCodeAlgorithm",__constructs__:null
	,PLATFORM_SPECIFIC: {_hx_name:"PLATFORM_SPECIFIC",_hx_index:0,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
	,ADLER32: {_hx_name:"ADLER32",_hx_index:1,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
	,CRC32B: {_hx_name:"CRC32B",_hx_index:2,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
	,DJB2A: {_hx_name:"DJB2A",_hx_index:3,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
	,JAVA: {_hx_name:"JAVA",_hx_index:4,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
	,SDBM: {_hx_name:"SDBM",_hx_index:5,__enum__:"hx.strings.HashCodeAlgorithm",toString:$estr}
};
hx_strings_HashCodeAlgorithm.__constructs__ = [hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC,hx_strings_HashCodeAlgorithm.ADLER32,hx_strings_HashCodeAlgorithm.CRC32B,hx_strings_HashCodeAlgorithm.DJB2A,hx_strings_HashCodeAlgorithm.JAVA,hx_strings_HashCodeAlgorithm.SDBM];
var hx_strings_AnsiToHtmlRenderMethod = $hxEnums["hx.strings.AnsiToHtmlRenderMethod"] = { __ename__:"hx.strings.AnsiToHtmlRenderMethod",__constructs__:null
	,StyleAttributes: {_hx_name:"StyleAttributes",_hx_index:0,__enum__:"hx.strings.AnsiToHtmlRenderMethod",toString:$estr}
	,CssClasses: {_hx_name:"CssClasses",_hx_index:1,__enum__:"hx.strings.AnsiToHtmlRenderMethod",toString:$estr}
	,CssClassesCallback: ($_=function(func) { return {_hx_index:2,func:func,__enum__:"hx.strings.AnsiToHtmlRenderMethod",toString:$estr}; },$_._hx_name="CssClassesCallback",$_.__params__ = ["func"],$_)
};
hx_strings_AnsiToHtmlRenderMethod.__constructs__ = [hx_strings_AnsiToHtmlRenderMethod.StyleAttributes,hx_strings_AnsiToHtmlRenderMethod.CssClasses,hx_strings_AnsiToHtmlRenderMethod.CssClassesCallback];
var hx_strings_AnsiState = function(copyFrom) {
	if(copyFrom == null) {
		this.reset();
	} else {
		this.copyFrom(copyFrom);
	}
};
hx_strings_AnsiState.__name__ = "hx.strings.AnsiState";
hx_strings_AnsiState.defaultCssClassesCallback = function(state) {
	var classes = [];
	if(state.fgcolor != null) {
		classes.push("ansi_fg_" + state.fgcolor);
	}
	if(state.bgcolor != null) {
		classes.push("ansi_bg_" + state.bgcolor);
	}
	if(state.bold) {
		classes.push("ansi_bold");
	}
	if(state.underline) {
		classes.push("ansi_underline");
	}
	if(state.blink) {
		classes.push("ansi_blink");
	}
	return classes.join(" ");
};
hx_strings_AnsiState.prototype = {
	bgcolor: null
	,blink: null
	,bold: null
	,fgcolor: null
	,underline: null
	,isActive: function() {
		if(!(this.fgcolor != null || this.bgcolor != null || this.bold || this.underline)) {
			return this.blink;
		} else {
			return true;
		}
	}
	,reset: function() {
		this.fgcolor = null;
		this.bgcolor = null;
		this.bold = false;
		this.underline = false;
		this.blink = false;
	}
	,copyFrom: function(other) {
		this.fgcolor = other.fgcolor;
		this.bgcolor = other.bgcolor;
		this.bold = other.bold;
		this.underline = other.underline;
		this.blink = other.blink;
	}
	,setGraphicModeParameter: function(param) {
		switch(param) {
		case 0:
			this.reset();
			break;
		case 1:
			this.bold = true;
			break;
		case 4:
			this.underline = true;
			break;
		case 5:
			this.blink = true;
			break;
		case 30:
			this.fgcolor = "black";
			break;
		case 31:
			this.fgcolor = "red";
			break;
		case 32:
			this.fgcolor = "green";
			break;
		case 33:
			this.fgcolor = "yellow";
			break;
		case 34:
			this.fgcolor = "blue";
			break;
		case 35:
			this.fgcolor = "magenta";
			break;
		case 36:
			this.fgcolor = "cyan";
			break;
		case 37:
			this.fgcolor = "white";
			break;
		case 40:
			this.bgcolor = "black";
			break;
		case 41:
			this.bgcolor = "red";
			break;
		case 42:
			this.bgcolor = "green";
			break;
		case 43:
			this.bgcolor = "yellow";
			break;
		case 44:
			this.bgcolor = "blue";
			break;
		case 45:
			this.bgcolor = "magenta";
			break;
		case 46:
			this.bgcolor = "cyan";
			break;
		case 47:
			this.bgcolor = "white";
			break;
		}
	}
	,toCSS: function(renderMethod) {
		if(this.fgcolor != null || this.bgcolor != null || this.bold || this.underline || this.blink) {
			var sb = new hx_strings_StringBuilder();
			if(renderMethod == null) {
				renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes;
			}
			switch(renderMethod._hx_index) {
			case 0:
				if(this.fgcolor != null) {
					sb.add("color:").add(this.fgcolor).add(";");
				}
				if(this.bgcolor != null) {
					sb.add("background-color:").add(this.bgcolor).add(";");
				}
				if(this.bold) {
					sb.add("font-weight:bold;");
				}
				if(this.underline) {
					sb.add("text-decoration:underline;");
				}
				if(this.blink) {
					sb.add("text-decoration:blink;");
				}
				break;
			case 1:
				sb.add(hx_strings_AnsiState.defaultCssClassesCallback(this));
				break;
			case 2:
				sb.add(renderMethod.func(this));
				break;
			}
			return sb.toString();
		}
		return "";
	}
	,__class__: hx_strings_AnsiState
};
var hx_strings_internal_Bits = function() { };
hx_strings_internal_Bits.__name__ = "hx.strings.internal.Bits";
hx_strings_internal_Bits.clearBit = function(num,bitPos) {
	return num & ~(1 << bitPos - 1);
};
hx_strings_internal_Bits.setBit = function(num,bitPos) {
	return num | 1 << bitPos - 1;
};
hx_strings_internal_Bits.toggleBit = function(num,bitPos) {
	return num ^ 1 << bitPos - 1;
};
hx_strings_internal_Bits.getBit = function(num,bitPos) {
	return 1 == (num >> bitPos - 1 & 1);
};
var hx_strings_internal_Either2 = {};
hx_strings_internal_Either2.__properties__ = {get_value:"get_value"};
hx_strings_internal_Either2._new = function(value) {
	return value;
};
hx_strings_internal_Either2.get_value = function(this1) {
	return this1;
};
hx_strings_internal_Either2.fromA = function(value) {
	return hx_strings_internal__$Either2__$Either2.a(value);
};
hx_strings_internal_Either2.fromB = function(value) {
	return hx_strings_internal__$Either2__$Either2.b(value);
};
var hx_strings_internal__$Either2__$Either2 = $hxEnums["hx.strings.internal._Either2._Either2"] = { __ename__:"hx.strings.internal._Either2._Either2",__constructs__:null
	,a: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hx.strings.internal._Either2._Either2",toString:$estr}; },$_._hx_name="a",$_.__params__ = ["v"],$_)
	,b: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hx.strings.internal._Either2._Either2",toString:$estr}; },$_._hx_name="b",$_.__params__ = ["v"],$_)
};
hx_strings_internal__$Either2__$Either2.__constructs__ = [hx_strings_internal__$Either2__$Either2.a,hx_strings_internal__$Either2__$Either2.b];
var hx_strings_internal_Either3 = {};
hx_strings_internal_Either3.__properties__ = {get_value:"get_value"};
hx_strings_internal_Either3._new = function(value) {
	return value;
};
hx_strings_internal_Either3.get_value = function(this1) {
	return this1;
};
hx_strings_internal_Either3.fromA = function(value) {
	return hx_strings_internal__$Either3__$Either3.a(value);
};
hx_strings_internal_Either3.fromB = function(value) {
	return hx_strings_internal__$Either3__$Either3.b(value);
};
hx_strings_internal_Either3.fromC = function(value) {
	return hx_strings_internal__$Either3__$Either3.c(value);
};
var hx_strings_internal_OneOrMany = {};
hx_strings_internal_OneOrMany.fromSingle = function(value) {
	return [value];
};
var hx_strings_internal_RingBuffer = {};
hx_strings_internal_RingBuffer._new = function(size) {
	return new hx_strings_internal__$RingBuffer_RingBufferImpl(size);
};
hx_strings_internal_RingBuffer.get = function(this1,index) {
	return this1.get(index);
};
var hx_strings_internal__$RingBuffer_RingBufferIterator = function(buff) {
	this.idx = -1;
	this.buff = buff;
};
hx_strings_internal__$RingBuffer_RingBufferIterator.__name__ = "hx.strings.internal._RingBuffer.RingBufferIterator";
hx_strings_internal__$RingBuffer_RingBufferIterator.prototype = {
	buff: null
	,idx: null
	,hasNext: function() {
		return this.idx + 1 < this.buff.length;
	}
	,next: function() {
		this.idx++;
		return this.buff.get(this.idx);
	}
	,__class__: hx_strings_internal__$RingBuffer_RingBufferIterator
};
var ihx_ConsoleReader = function(maxHistory,historyFile) {
	if(historyFile == null) {
		historyFile = "";
	}
	if(maxHistory == null) {
		maxHistory = -1;
	}
	this.code = 0;
	this.cmd = new ihx_PartialCommand();
	this.history = new ihx_History(maxHistory,historyFile);
	if(Sys.systemName() == "Windows") {
		this.codeSet = { arrow : 224, up : 72, down : 80, right : 77, left : 75, home : 71, end : 79, backspace : 8, ctrlc : 3, enter : 13, ctrla : 1, ctrle : 5, ctrlb : 2, ctrlf : 6, ctrld : 4, ctrlp : -1, ctrln : -1, ctrlk : -1, ctrlu : -1, ctrly : -1};
	} else {
		this.codeSet = { arrow : 27, up : 65, down : 66, right : 67, left : 68, home : 72, end : 70, backspace : 127, ctrlc : 3, enter : 13, ctrla : 1, ctrle : 5, ctrlb : 2, ctrlf : 6, ctrld : 4, ctrlp : 16, ctrln : 14, ctrlk : 11, ctrlu : 21, ctrly : 25};
	}
};
ihx_ConsoleReader.__name__ = "ihx.ConsoleReader";
ihx_ConsoleReader.main = function() {
	var cmdStr = new ihx_ConsoleReader().readLine();
	process.stdout.write(Std.string("\n" + cmdStr));
	process.stdout.write("\n");
};
ihx_ConsoleReader.prototype = {
	cmd: null
	,code: null
	,history: null
	,codeSet: null
	,saveHistory: function() {
		this.history.save();
	}
	,readLine: function() {
		this.cmd.set("");
		while(true) {
			var clearPrevCommand = this.cmd.clearString();
			this.code = Sys.getChar(false);
			if(this.code == this.codeSet.arrow) {
				if(Sys.systemName() != "Windows") {
					Sys.getChar(false);
				}
				this.code = Sys.getChar(false);
				if(this.code == this.codeSet.up) {
					this.cmd.set(this.history.prev());
				} else if(this.code == this.codeSet.down) {
					this.cmd.set(this.history.next());
				} else if(this.code == this.codeSet.right) {
					this.cmd.cursorForward();
				} else if(this.code == this.codeSet.left) {
					this.cmd.cursorBack();
				} else if(this.code == this.codeSet.home) {
					this.cmd.home();
				} else if(this.code == this.codeSet.end) {
					this.cmd.end();
				} else if(this.code == this.codeSet.ctrld && Sys.systemName() == "Windows") {
					this.cmd.del();
				}
			} else if(this.code == this.codeSet.ctrlc) {
				if(this.cmd.toString().length > 0) {
					this.cmd.set("");
				} else {
					process.stdout.write("");
					process.stdout.write("\n");
					this.history.save();
					process.exit(1);
				}
			} else if(this.code == this.codeSet.enter) {
				process.stdout.write("");
				process.stdout.write("\n");
				this.history.add(this.cmd.toString());
				return this.cmd.toString();
			} else if(this.code == this.codeSet.ctrld) {
				if(this.cmd.toString().length > 0) {
					this.cmd.del();
				} else {
					process.stdout.write("");
					process.stdout.write("\n");
					this.history.save();
					process.exit(1);
				}
			} else if(this.code == this.codeSet.ctrlp) {
				this.cmd.set(this.history.prev());
			} else if(this.code == this.codeSet.ctrln) {
				this.cmd.set(this.history.next());
			} else if(this.code == this.codeSet.ctrlk) {
				this.cmd.killRight();
			} else if(this.code == this.codeSet.ctrlu) {
				this.cmd.killLeft();
			} else if(this.code == this.codeSet.ctrly) {
				this.cmd.yank();
			} else if(this.code == this.codeSet.ctrla) {
				this.cmd.home();
			} else if(this.code == this.codeSet.ctrle) {
				this.cmd.end();
			} else if(this.code == this.codeSet.ctrlf) {
				this.cmd.cursorForward();
			} else if(this.code == this.codeSet.ctrlb) {
				this.cmd.cursorBack();
			} else if(this.code == this.codeSet.backspace) {
				this.cmd.backspace();
			} else if(this.code >= 32 && this.code <= 126) {
				var code = this.code;
				this.cmd.addChar(String.fromCodePoint(code));
			}
			process.stdout.write(Std.string(clearPrevCommand));
			var v = this.cmd.toConsole();
			process.stdout.write(Std.string(v));
		}
	}
	,__class__: ihx_ConsoleReader
};
var ihx_History = function(maxCommands,saveFile) {
	if(saveFile == null) {
		saveFile = "";
	}
	if(maxCommands == null) {
		maxCommands = -1;
	}
	this.maxCommands = maxCommands + 1;
	this.saveFile = saveFile;
	if(saveFile.length > 0) {
		this.load();
	} else {
		this.commands = [""];
		this.pos = 1;
	}
	this.save();
	this.pos = this.commands.length;
};
ihx_History.__name__ = "ihx.History";
ihx_History.prototype = {
	commands: null
	,maxCommands: null
	,saveFile: null
	,pos: null
	,load: function() {
		try {
			this.commands = js_node_Fs.readFileSync(this.saveFile,{ encoding : "utf8"}).split("\n");
			this.commands.splice(0,0,"");
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			var v = "Warning! Failed to read history from " + this.saveFile + ": " + Std.string(_g1);
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
			this.commands = [""];
		}
		if(this.isFull()) {
			this.commands = this.commands.splice(0,this.commands.length - this.maxCommands);
		}
	}
	,save: function() {
		if(this.saveFile.length > 0) {
			try {
				js_node_Fs.writeFileSync(this.saveFile,this.commands.slice(1).join("\n"));
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				var _g1 = haxe_Exception.caught(_g).unwrap();
				var v = "Warning! Failed to write history to " + this.saveFile + ": " + Std.string(_g1);
				process.stdout.write(Std.string(v));
				process.stdout.write("\n");
				this.saveFile = "";
			}
		}
	}
	,isFull: function() {
		if(this.maxCommands > 0) {
			return this.commands.length > this.maxCommands;
		} else {
			return false;
		}
	}
	,add: function(cmd) {
		this.commands.push(cmd);
		if(this.isFull()) {
			this.commands.shift();
		}
		this.pos = this.commands.length;
	}
	,next: function() {
		this.pos += 1;
		return this.commands[this.pos % this.commands.length];
	}
	,prev: function() {
		this.pos -= 1;
		if(this.pos < 0) {
			this.pos += this.commands.length;
		}
		return this.commands[this.pos % this.commands.length];
	}
	,__class__: ihx_History
};
var ihx_PartialCommand = function(initialCommand) {
	if(initialCommand == null) {
		initialCommand = "";
	}
	this.set(initialCommand);
	this.prompt = "";
	this.killedText = "";
};
ihx_PartialCommand.__name__ = "ihx.PartialCommand";
ihx_PartialCommand.prototype = {
	str: null
	,pos: null
	,killedText: null
	,prompt: null
	,addChar: function(ch) {
		if(this.pos == this.str.length) {
			this.str += ch;
		} else {
			this.str = HxOverrides.substr(this.str,0,this.pos) + ch + HxOverrides.substr(this.str,this.pos,null);
		}
		this.cursorForward();
	}
	,backspace: function() {
		if(this.pos == 0) {
			return;
		}
		this.str = HxOverrides.substr(this.str,0,this.pos - 1) + HxOverrides.substr(this.str,this.pos,null);
		this.cursorBack();
	}
	,del: function() {
		if(this.pos == this.str.length) {
			return;
		}
		this.str = HxOverrides.substr(this.str,0,this.pos) + HxOverrides.substr(this.str,this.pos + 1,null);
	}
	,cursorForward: function() {
		this.pos += 1;
		this.pos = Math.min(this.pos,this.str.length) | 0;
	}
	,cursorBack: function() {
		this.pos -= 1;
		this.pos = Math.max(this.pos,0) | 0;
	}
	,home: function() {
		this.pos = 0;
	}
	,end: function() {
		this.pos = this.str.length;
	}
	,set: function(newStr) {
		this.str = newStr;
		this.pos = this.str.length;
	}
	,toString: function() {
		return this.str;
	}
	,toConsole: function() {
		return "\r" + this.prompt + this.str + " " + "\r" + this.prompt + HxOverrides.substr(this.str,0,this.pos);
	}
	,clearString: function() {
		return "\r" + StringTools.rpad(""," ",this.str.length + this.prompt.length);
	}
	,killLeft: function() {
		this.killText(0,this.pos);
	}
	,killRight: function() {
		this.killText(this.pos,this.str.length);
	}
	,killText: function(startIndex,endIndex) {
		if(startIndex < this.pos && this.pos <= endIndex) {
			this.pos = startIndex;
		}
		this.killedText = this.str.substring(startIndex,endIndex);
		this.str = this.str.substring(0,startIndex) + HxOverrides.substr(this.str,endIndex,null);
	}
	,yank: function() {
		this.str = this.str.substring(0,this.pos) + this.killedText + HxOverrides.substr(this.str,this.pos,null);
		this.pos += this.killedText.length;
	}
	,__class__: ihx_PartialCommand
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_Fs = require("fs");
var js_node_Http = require("http");
var js_node_Https = require("https");
var js_node_KeyValue = {};
js_node_KeyValue.__properties__ = {get_value:"get_value",get_key:"get_key"};
js_node_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_node_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_node_Url = require("url");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_stream_WritableNewOptionsAdapter = {};
js_node_stream_WritableNewOptionsAdapter.from = function(options) {
	if(!Object.prototype.hasOwnProperty.call(options,"final")) {
		Object.defineProperty(options,"final",{ get : function() {
			return options.final_;
		}});
	}
	return options;
};
var js_node_url_URLSearchParamsEntry = {};
js_node_url_URLSearchParamsEntry.__properties__ = {get_value:"get_value",get_name:"get_name"};
js_node_url_URLSearchParamsEntry._new = function(name,value) {
	return [name,value];
};
js_node_url_URLSearchParamsEntry.get_name = function(this1) {
	return this1[0];
};
js_node_url_URLSearchParamsEntry.get_value = function(this1) {
	return this1[1];
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = "sys.io.FileInput";
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fd: null
	,pos: null
	,readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
	,__class__: sys_io_FileInput
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = "sys.io.FileOutput";
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	fd: null
	,pos: null
	,writeByte: function(b) {
		var buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,__class__: sys_io_FileOutput
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__:"sys.io.FileSeek",__constructs__:null
	,SeekBegin: {_hx_name:"SeekBegin",_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_name:"SeekCur",_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_name:"SeekEnd",_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
sys_io_FileSeek.__constructs__ = [sys_io_FileSeek.SeekBegin,sys_io_FileSeek.SeekCur,sys_io_FileSeek.SeekEnd];
var utest_Assert = function() { };
utest_Assert.__name__ = "utest.Assert";
utest_Assert.results = null;
utest_Assert.processResult = function(cond,getMessage,pos) {
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(getMessage(),pos));
	}
	return cond;
};
utest_Assert.isTrue = function(cond,msg,pos) {
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected true",pos));
	}
	return cond;
};
utest_Assert.isFalse = function(value,msg,pos) {
	var cond = value == false;
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected false",pos));
	}
	return cond;
};
utest_Assert.isNull = function(value,msg,pos) {
	var cond = value == null;
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected null but it is " + utest_Assert.q(value),pos));
	}
	return cond;
};
utest_Assert.notNull = function(value,msg,pos) {
	var cond = value != null;
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected not null",pos));
	}
	return cond;
};
utest_Assert.is = function(value,type,msg,pos) {
	return utest_Assert.isOfType(value,type,msg,pos);
};
utest_Assert.isOfType = function(value,type,msg,pos) {
	var cond = js_Boot.__instanceof(value,type);
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected type " + utest_Assert.typeToString(type) + " but it is " + utest_Assert.typeToString(value),pos));
	}
	return cond;
};
utest_Assert.notEquals = function(expected,value,msg,pos) {
	var cond = expected != value;
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected " + utest_Assert.q(expected) + " and test value " + utest_Assert.q(value) + " should be different",pos));
	}
	return cond;
};
utest_Assert.equals = function(expected,value,msg,pos) {
	var cond = expected == value;
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value),pos));
	}
	return cond;
};
utest_Assert.match = function(pattern,value,msg,pos) {
	var cond = pattern.match(value);
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "the value " + utest_Assert.q(value) + " does not match the provided pattern",pos));
	}
	return cond;
};
utest_Assert.floatEquals = function(expected,value,approx,msg,pos) {
	var cond = utest_Assert._floatEquals(expected,value,approx);
	if(utest_Assert.results == null) {
		throw haxe_Exception.thrown("Assert at " + pos.fileName + ":" + pos.lineNumber + " out of context. Most likely you are trying to assert after a test timeout.");
	}
	if(cond) {
		utest_Assert.results.add(utest_Assertation.Success(pos));
	} else {
		utest_Assert.results.add(utest_Assertation.Failure(msg != null ? msg : "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value),pos));
	}
	return cond;
};
utest_Assert._floatEquals = function(expected,value,approx) {
	if(isNaN(expected)) {
		return isNaN(value);
	} else if(isNaN(value)) {
		return false;
	} else if(!isFinite(expected) && !isFinite(value)) {
		return expected > 0 == value > 0;
	}
	if(null == approx) {
		approx = 1e-5;
	}
	return Math.abs(value - expected) <= approx;
};
utest_Assert.getTypeName = function(v) {
	var _g = Type.typeof(v);
	switch(_g._hx_index) {
	case 0:
		return "`null`";
	case 1:
		return "Int";
	case 2:
		return "Float";
	case 3:
		return "Bool";
	case 4:
		return "Object";
	case 5:
		return "function";
	case 6:
		var c = _g.c;
		return c.__name__;
	case 7:
		var e = _g.e;
		return e.__ename__;
	case 8:
		return "`Unknown`";
	}
};
utest_Assert.isIterable = function(v,isAnonym) {
	if(!Lambda.has(isAnonym ? Reflect.fields(v) : Type.getInstanceFields(js_Boot.getClass(v)),"iterator")) {
		return false;
	}
	return Reflect.isFunction(Reflect.field(v,"iterator"));
};
utest_Assert.isIterator = function(v,isAnonym) {
	var fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(js_Boot.getClass(v));
	if(!Lambda.has(fields,"next") || !Lambda.has(fields,"hasNext")) {
		return false;
	}
	if(Reflect.isFunction(Reflect.field(v,"next"))) {
		return Reflect.isFunction(Reflect.field(v,"hasNext"));
	} else {
		return false;
	}
};
utest_Assert.sameAs = function(expected,value,status,approx) {
	var texpected = utest_Assert.getTypeName(expected);
	var tvalue = utest_Assert.getTypeName(value);
	status.expectedValue = expected;
	status.actualValue = value;
	if(texpected != tvalue && !(texpected == "Int" && tvalue == "Float" || texpected == "Float" && tvalue == "Int")) {
		status.error = "expected type " + texpected + " but it is " + tvalue + (status.path == "" ? "" : " for field " + status.path);
		return false;
	}
	var _g = Type.typeof(expected);
	switch(_g._hx_index) {
	case 1:case 2:
		if(!utest_Assert._floatEquals(expected,value,approx)) {
			status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		return true;
	case 0:case 3:
		if(expected != value) {
			status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		return true;
	case 4:
		if(status.recursive || status.path == "") {
			var tfields = Reflect.fields(value);
			var fields = Reflect.fields(expected);
			var path = status.path;
			var _g1 = 0;
			while(_g1 < fields.length) {
				var field = fields[_g1];
				++_g1;
				HxOverrides.remove(tfields,field);
				status.path = path == "" ? field : path + "." + field;
				if(!Object.prototype.hasOwnProperty.call(value,field)) {
					status.error = "expected field " + status.path + " does not exist in " + utest_Assert.q(value);
					return false;
				}
				var e = Reflect.field(expected,field);
				if(Reflect.isFunction(e)) {
					continue;
				}
				if(!utest_Assert.sameAs(e,Reflect.field(value,field),status,approx)) {
					return false;
				}
			}
			if(tfields.length > 0) {
				status.error = "the tested object has extra field(s) (" + tfields.join(", ") + ") not included in the expected ones";
				return false;
			}
		}
		if(utest_Assert.isIterator(expected,true)) {
			if(!utest_Assert.isIterator(value,true)) {
				status.error = "expected Iterable but it is not " + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			if(status.recursive || status.path == "") {
				var evalues = Lambda.array({ iterator : function() {
					return expected;
				}});
				var vvalues = Lambda.array({ iterator : function() {
					return value;
				}});
				if(evalues.length != vvalues.length) {
					status.error = "expected " + evalues.length + " values in Iterator but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				var _g2 = evalues.length;
				while(_g1 < _g2) {
					var i = _g1++;
					status.path = path == "" ? "iterator[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
						status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
				}
			}
			return true;
		}
		if(utest_Assert.isIterable(expected,true)) {
			if(!utest_Assert.isIterable(value,true)) {
				status.error = "expected Iterator but it is not " + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			if(status.recursive || status.path == "") {
				var evalues = Lambda.array(expected);
				var vvalues = Lambda.array(value);
				if(evalues.length != vvalues.length) {
					status.error = "expected " + evalues.length + " values in Iterable but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				var _g2 = evalues.length;
				while(_g1 < _g2) {
					var i = _g1++;
					status.path = path == "" ? "iterable[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
						return false;
					}
				}
			}
			return true;
		}
		return true;
	case 5:
		if(!Reflect.compareMethods(expected,value)) {
			status.error = "expected same function reference" + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		return true;
	case 6:
		var c = _g.c;
		var cexpected = c.__name__;
		var c = js_Boot.getClass(value);
		var cvalue = c.__name__;
		if(cexpected != cvalue) {
			status.error = "expected instance of " + utest_Assert.q(cexpected) + " but it is " + utest_Assert.q(cvalue) + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		if(typeof(expected) == "string") {
			if(expected == value) {
				return true;
			} else {
				status.error = "expected string '" + Std.string(expected) + "' but it is '" + Std.string(value) + "'";
				return false;
			}
		}
		if(((expected) instanceof Array)) {
			if(status.recursive || status.path == "") {
				if(expected.length != value.length) {
					status.error = "expected " + Std.string(expected.length) + " elements but they are " + Std.string(value.length) + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				var _g2 = expected.length;
				while(_g1 < _g2) {
					var i = _g1++;
					status.path = path == "" ? "array[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(expected[i],value[i],status,approx)) {
						status.error = "expected array element at [" + i + "] to have " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
				}
			}
			return true;
		}
		if(((expected) instanceof Date)) {
			if(expected.getTime() != value.getTime()) {
				status.error = "expected " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			return true;
		}
		if(((expected) instanceof haxe_io_Bytes)) {
			if(status.recursive || status.path == "") {
				var ebytes = expected;
				var vbytes = value;
				if(ebytes.length != vbytes.length) {
					status.error = "expected " + ebytes.length + " bytes length but it is " + vbytes.length;
					return false;
				}
				var _g1 = 0;
				var _g2 = ebytes.length;
				while(_g1 < _g2) {
					var i = _g1++;
					if(ebytes.b[i] != vbytes.b[i]) {
						status.error = "expected byte #" + i + " to be " + ebytes.b[i] + " but it is " + vbytes.b[i] + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
				}
			}
			return true;
		}
		if(js_Boot.__implements(expected,haxe_IMap)) {
			if(status.recursive || status.path == "") {
				var map = js_Boot.__cast(expected , haxe_IMap);
				var vmap = js_Boot.__cast(value , haxe_IMap);
				var _g1 = [];
				var k = map.keys();
				while(k.hasNext()) _g1.push(k.next());
				var keys = _g1;
				var _g1 = [];
				var k = vmap.keys();
				while(k.hasNext()) _g1.push(k.next());
				var vkeys = _g1;
				if(keys.length != vkeys.length) {
					status.error = "expected " + keys.length + " keys but they are " + vkeys.length + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				while(_g1 < keys.length) {
					var key = keys[_g1];
					++_g1;
					status.path = path == "" ? "hash[" + Std.string(key) + "]" : path + "[" + Std.string(key) + "]";
					if(!utest_Assert.sameAs(map.get(key),vmap.get(key),status,approx)) {
						status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
				}
			}
			return true;
		}
		if(utest_Assert.isIterator(expected,false)) {
			if(status.recursive || status.path == "") {
				var evalues = Lambda.array({ iterator : function() {
					return expected;
				}});
				var vvalues = Lambda.array({ iterator : function() {
					return value;
				}});
				if(evalues.length != vvalues.length) {
					status.error = "expected " + evalues.length + " values in Iterator but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				var _g2 = evalues.length;
				while(_g1 < _g2) {
					var i = _g1++;
					status.path = path == "" ? "iterator[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
						status.error = "expected " + utest_Assert.q(status.expectedValue) + " but it is " + utest_Assert.q(status.actualValue) + (status.path == "" ? "" : " for field " + status.path);
						return false;
					}
				}
			}
			return true;
		}
		if(utest_Assert.isIterable(expected,false)) {
			if(status.recursive || status.path == "") {
				var evalues = Lambda.array(expected);
				var vvalues = Lambda.array(value);
				if(evalues.length != vvalues.length) {
					status.error = "expected " + evalues.length + " values in Iterable but they are " + vvalues.length + (status.path == "" ? "" : " for field " + status.path);
					return false;
				}
				var path = status.path;
				var _g1 = 0;
				var _g2 = evalues.length;
				while(_g1 < _g2) {
					var i = _g1++;
					status.path = path == "" ? "iterable[" + i + "]" : path + "[" + i + "]";
					if(!utest_Assert.sameAs(evalues[i],vvalues[i],status,approx)) {
						return false;
					}
				}
			}
			return true;
		}
		if(status.recursive || status.path == "") {
			var fields = Type.getInstanceFields(js_Boot.getClass(expected));
			var path = status.path;
			var _g1 = 0;
			while(_g1 < fields.length) {
				var field = fields[_g1];
				++_g1;
				status.path = path == "" ? field : path + "." + field;
				var e = Reflect.field(expected,field);
				if(Reflect.isFunction(e)) {
					continue;
				}
				if(!utest_Assert.sameAs(e,Reflect.field(value,field),status,approx)) {
					return false;
				}
			}
		}
		return true;
	case 7:
		var e = _g.e;
		var eexpected = e.__ename__;
		var e = Type.getEnum(value);
		var evalue = e.__ename__;
		if(eexpected != evalue) {
			status.error = "expected enumeration of " + utest_Assert.q(eexpected) + " but it is " + utest_Assert.q(evalue) + (status.path == "" ? "" : " for field " + status.path);
			return false;
		}
		if(status.recursive || status.path == "") {
			if(expected._hx_index != value._hx_index) {
				var e = expected;
				var tmp = "expected enum constructor " + utest_Assert.q($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name) + " but it is ";
				var e = value;
				status.error = tmp + utest_Assert.q($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name) + (status.path == "" ? "" : " for field " + status.path);
				return false;
			}
			var eparams = Type.enumParameters(expected);
			var vparams = Type.enumParameters(value);
			var path = status.path;
			var _g = 0;
			var _g1 = eparams.length;
			while(_g < _g1) {
				var i = _g++;
				status.path = path == "" ? "enum[" + i + "]" : path + "[" + i + "]";
				if(!utest_Assert.sameAs(eparams[i],vparams[i],status,approx)) {
					status.error = "expected enum param " + utest_Assert.q(expected) + " but it is " + utest_Assert.q(value) + (status.path == "" ? "" : " for field " + status.path) + " with " + status.error;
					return false;
				}
			}
		}
		return true;
	case 8:
		throw haxe_Exception.thrown("Unable to compare two unknown types");
	}
};
utest_Assert.q = function(v) {
	if(typeof(v) == "string") {
		return "\"" + StringTools.replace(v,"\"","\\\"") + "\"";
	} else {
		return Std.string(v);
	}
};
utest_Assert.same = function(expected,value,recursive,msg,approx,pos) {
	if(null == approx) {
		approx = 1e-5;
	}
	var status = { recursive : null == recursive ? true : recursive, path : "", error : null, expectedValue : expected, actualValue : value};
	if(utest_Assert.sameAs(expected,value,status,approx)) {
		return utest_Assert.pass(msg,pos);
	} else {
		return utest_Assert.fail(msg == null ? status.error : msg,pos);
	}
};
utest_Assert.raises = function(method,type,msgNotThrown,msgWrongType,pos) {
	var name = type != null ? type.__name__ : "Dynamic";
	try {
		method();
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var ex = haxe_Exception.caught(_g).unwrap();
		if(null == type) {
			return utest_Assert.pass(null,pos);
		} else {
			if(null == msgWrongType) {
				msgWrongType = "expected throw of type " + name + " but it is " + Std.string(ex);
			}
			return utest_Assert.isTrue(js_Boot.__instanceof(ex,type),msgWrongType,pos);
		}
	}
	if(null == msgNotThrown) {
		msgNotThrown = "exception of type " + name + " not raised";
	}
	return utest_Assert.fail(msgNotThrown,pos);
};
utest_Assert.allows = function(possibilities,value,msg,pos) {
	if(Lambda.has(possibilities,value)) {
		return utest_Assert.isTrue(true,msg,pos);
	} else {
		return utest_Assert.fail(msg == null ? "value " + utest_Assert.q(value) + " not found in the expected possibilities " + Std.string(possibilities) : msg,pos);
	}
};
utest_Assert.contains = function(match,values,msg,pos) {
	if(Lambda.has(values,match)) {
		return utest_Assert.isTrue(true,msg,pos);
	} else {
		return utest_Assert.fail(msg == null ? "values " + utest_Assert.q(values) + " do not contain " + Std.string(match) : msg,pos);
	}
};
utest_Assert.notContains = function(match,values,msg,pos) {
	if(!Lambda.has(values,match)) {
		return utest_Assert.isTrue(true,msg,pos);
	} else {
		return utest_Assert.fail(msg == null ? "values " + utest_Assert.q(values) + " do contain " + Std.string(match) : msg,pos);
	}
};
utest_Assert.stringContains = function(match,value,msg,pos) {
	if(value != null && value.indexOf(match) >= 0) {
		return utest_Assert.isTrue(true,msg,pos);
	} else {
		return utest_Assert.fail(msg == null ? "value " + utest_Assert.q(value) + " does not contain " + utest_Assert.q(match) : msg,pos);
	}
};
utest_Assert.stringSequence = function(sequence,value,msg,pos) {
	if(null == value) {
		return utest_Assert.fail(msg == null ? "null argument value" : msg,pos);
	}
	var p = 0;
	var _g = 0;
	while(_g < sequence.length) {
		var s = sequence[_g];
		++_g;
		var p2 = value.indexOf(s,p);
		if(p2 < 0) {
			if(msg == null) {
				msg = "expected '" + s + "' after ";
				if(p > 0) {
					var cut = HxOverrides.substr(value,0,p);
					if(cut.length > 30) {
						cut = "..." + HxOverrides.substr(cut,-27,null);
					}
					msg += " '" + cut + "'";
				} else {
					msg += " begin";
				}
			}
			return utest_Assert.fail(msg,pos);
		}
		p = p2 + s.length;
	}
	return utest_Assert.isTrue(true,msg,pos);
};
utest_Assert.pass = function(msg,pos) {
	if(msg == null) {
		msg = "pass expected";
	}
	return utest_Assert.isTrue(true,msg,pos);
};
utest_Assert.fail = function(msg,pos) {
	if(msg == null) {
		msg = "failure expected";
	}
	return utest_Assert.isTrue(false,msg,pos);
};
utest_Assert.warn = function(msg) {
	utest_Assert.results.add(utest_Assertation.Warning(msg));
};
utest_Assert.createAsync = function(f,timeout) {
	return function() {
	};
};
utest_Assert.createEvent = function(f,timeout) {
	return function(e) {
	};
};
utest_Assert.typeToString = function(t) {
	try {
		var _t = js_Boot.getClass(t);
		if(_t != null) {
			t = _t;
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	try {
		return t.__name__;
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	try {
		var _t = Type.getEnum(t);
		if(_t != null) {
			t = _t;
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	try {
		return t.__ename__;
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	try {
		return Std.string(Type.typeof(t));
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	try {
		return Std.string(t);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
	}
	return "<unable to retrieve type name>";
};
var utest_Assertation = $hxEnums["utest.Assertation"] = { __ename__:"utest.Assertation",__constructs__:null
	,Success: ($_=function(pos) { return {_hx_index:0,pos:pos,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["pos"],$_)
	,Failure: ($_=function(msg,pos) { return {_hx_index:1,msg:msg,pos:pos,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Failure",$_.__params__ = ["msg","pos"],$_)
	,Error: ($_=function(e,stack) { return {_hx_index:2,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Error",$_.__params__ = ["e","stack"],$_)
	,SetupError: ($_=function(e,stack) { return {_hx_index:3,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="SetupError",$_.__params__ = ["e","stack"],$_)
	,TeardownError: ($_=function(e,stack) { return {_hx_index:4,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="TeardownError",$_.__params__ = ["e","stack"],$_)
	,TimeoutError: ($_=function(missedAsyncs,stack) { return {_hx_index:5,missedAsyncs:missedAsyncs,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="TimeoutError",$_.__params__ = ["missedAsyncs","stack"],$_)
	,AsyncError: ($_=function(e,stack) { return {_hx_index:6,e:e,stack:stack,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="AsyncError",$_.__params__ = ["e","stack"],$_)
	,Warning: ($_=function(msg) { return {_hx_index:7,msg:msg,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Warning",$_.__params__ = ["msg"],$_)
	,Ignore: ($_=function(reason) { return {_hx_index:8,reason:reason,__enum__:"utest.Assertation",toString:$estr}; },$_._hx_name="Ignore",$_.__params__ = ["reason"],$_)
};
utest_Assertation.__constructs__ = [utest_Assertation.Success,utest_Assertation.Failure,utest_Assertation.Error,utest_Assertation.SetupError,utest_Assertation.TeardownError,utest_Assertation.TimeoutError,utest_Assertation.AsyncError,utest_Assertation.Warning,utest_Assertation.Ignore];
var utest_Async = function(timeoutMs) {
	if(timeoutMs == null) {
		timeoutMs = 250;
	}
	this.branches = [];
	this.callbacks = [];
	this.timedOut = false;
	this.resolved = false;
	this.timeoutMs = timeoutMs;
	var hrtime = process.hrtime();
	this.startTime = hrtime[0] + hrtime[1] / 1e9;
	this.timer = haxe_Timer.delay($bind(this,this.setTimedOutState),timeoutMs);
};
utest_Async.__name__ = "utest.Async";
utest_Async.resolvedInstance = null;
utest_Async.getResolved = function() {
	if(utest_Async.resolvedInstance == null) {
		utest_Async.resolvedInstance = new utest_Async();
		utest_Async.resolvedInstance.done({ fileName : "utest/Async.hx", lineNumber : 30, className : "utest.Async", methodName : "getResolved"});
	}
	return utest_Async.resolvedInstance;
};
utest_Async.prototype = {
	resolved: null
	,timedOut: null
	,callbacks: null
	,timeoutMs: null
	,startTime: null
	,timer: null
	,branches: null
	,done: function(pos) {
		if(this.resolved) {
			if(this.timedOut) {
				throw haxe_Exception.thrown("Cannot done() at " + pos.fileName + ":" + pos.lineNumber + " because async is timed out.");
			} else {
				throw haxe_Exception.thrown("Cannot done() at " + pos.fileName + ":" + pos.lineNumber + " because async is done already.");
			}
		}
		this.resolved = true;
		this.timer.stop();
		var _g = 0;
		var _g1 = this.callbacks;
		while(_g < _g1.length) _g1[_g++]();
	}
	,setTimeout: function(timeoutMs,pos) {
		if(this.resolved) {
			throw haxe_Exception.thrown("Cannot setTimeout(" + timeoutMs + ") at " + pos.fileName + ":" + pos.lineNumber + " because async is done.");
		}
		if(this.timedOut) {
			throw haxe_Exception.thrown("Cannot setTimeout(" + timeoutMs + ") at " + pos.fileName + ":" + pos.lineNumber + " because async is timed out.");
		}
		this.timer.stop();
		this.timeoutMs = timeoutMs;
		var hrtime = process.hrtime();
		this.timer = haxe_Timer.delay($bind(this,this.setTimedOutState),timeoutMs - Math.round(1000 * (hrtime[0] + hrtime[1] / 1e9 - this.startTime)));
	}
	,branch: function(fn) {
		var branch = new utest_Async(this.timeoutMs);
		this.branches.push(branch);
		branch.then($bind(this,this.checkBranches));
		if(fn != null) {
			fn(branch);
		}
		return branch;
	}
	,checkBranches: function() {
		var _gthis = this;
		if(this.resolved) {
			return;
		}
		var _g = 0;
		var _g1 = this.branches;
		while(_g < _g1.length) {
			var branch = _g1[_g];
			++_g;
			if(!branch.resolved) {
				return;
			}
			if(branch.timedOut) {
				this.setTimedOutState();
				return;
			}
		}
		var branchCount = this.branches.length;
		haxe_Timer.delay(function() {
			if(branchCount == _gthis.branches.length) {
				_gthis.done({ fileName : "utest/Async.hx", lineNumber : 97, className : "utest.Async", methodName : "checkBranches"});
			}
		},5);
	}
	,then: function(cb) {
		if(this.resolved) {
			cb();
		} else {
			this.callbacks.push(cb);
		}
	}
	,setTimedOutState: function() {
		if(this.resolved) {
			return;
		}
		this.timedOut = true;
		this.done({ fileName : "utest/Async.hx", lineNumber : 115, className : "utest.Async", methodName : "setTimedOutState"});
	}
	,__class__: utest_Async
};
var utest__$Dispatcher_EventException = $hxEnums["utest._Dispatcher.EventException"] = { __ename__:"utest._Dispatcher.EventException",__constructs__:null
	,StopPropagation: {_hx_name:"StopPropagation",_hx_index:0,__enum__:"utest._Dispatcher.EventException",toString:$estr}
};
utest__$Dispatcher_EventException.__constructs__ = [utest__$Dispatcher_EventException.StopPropagation];
var utest_Dispatcher = function() {
	this.handlers = [];
};
utest_Dispatcher.__name__ = "utest.Dispatcher";
utest_Dispatcher.stop = function() {
	throw haxe_Exception.thrown(utest__$Dispatcher_EventException.StopPropagation);
};
utest_Dispatcher.prototype = {
	handlers: null
	,add: function(h) {
		this.handlers.push(h);
		return h;
	}
	,remove: function(h) {
		var _g = 0;
		var _g1 = this.handlers.length;
		while(_g < _g1) {
			var i = _g++;
			if(Reflect.compareMethods(this.handlers[i],h)) {
				return this.handlers.splice(i,1)[0];
			}
		}
		return null;
	}
	,clear: function() {
		this.handlers = [];
	}
	,dispatch: function(e) {
		try {
			var list = this.handlers.slice();
			var _g = 0;
			while(_g < list.length) list[_g++](e);
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(js_Boot.__instanceof(haxe_Exception.caught(_g).unwrap(),utest__$Dispatcher_EventException)) {
				return false;
			} else {
				throw _g;
			}
		}
	}
	,has: function() {
		return this.handlers.length > 0;
	}
	,__class__: utest_Dispatcher
};
var utest_Notifier = function() {
	this.handlers = [];
};
utest_Notifier.__name__ = "utest.Notifier";
utest_Notifier.stop = function() {
	throw haxe_Exception.thrown(utest__$Dispatcher_EventException.StopPropagation);
};
utest_Notifier.prototype = {
	handlers: null
	,add: function(h) {
		this.handlers.push(h);
		return h;
	}
	,remove: function(h) {
		var _g = 0;
		var _g1 = this.handlers.length;
		while(_g < _g1) {
			var i = _g++;
			if(Reflect.compareMethods(this.handlers[i],h)) {
				return this.handlers.splice(i,1)[0];
			}
		}
		return null;
	}
	,clear: function() {
		this.handlers = [];
	}
	,dispatch: function() {
		try {
			var list = this.handlers.slice();
			var _g = 0;
			while(_g < list.length) list[_g++]();
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(js_Boot.__instanceof(haxe_Exception.caught(_g).unwrap(),utest__$Dispatcher_EventException)) {
				return false;
			} else {
				throw _g;
			}
		}
	}
	,has: function() {
		return this.handlers.length > 0;
	}
	,__class__: utest_Notifier
};
var utest_TestHandler = function(fixture) {
	this.wasBound = false;
	this.finished = false;
	if(fixture == null) {
		throw haxe_Exception.thrown("fixture argument is null");
	}
	this.fixture = fixture;
	this.results = new haxe_ds_List();
	this.asyncStack = new haxe_ds_List();
	this.onTested = new utest_Dispatcher();
	this.onTimeout = new utest_Dispatcher();
	this.onComplete = new utest_Dispatcher();
	this.onPrecheck = new utest_Dispatcher();
	if(fixture.ignoringInfo != null) {
		this.results.add(utest_Assertation.Ignore(fixture.ignoringInfo));
	}
};
utest_TestHandler.__name__ = "utest.TestHandler";
utest_TestHandler.exceptionStack = function(pops) {
	if(pops == null) {
		pops = 2;
	}
	var stack = haxe_CallStack.exceptionStack();
	while(pops-- > 0) stack.pop();
	return stack;
};
utest_TestHandler.prototype = {
	results: null
	,fixture: null
	,finished: null
	,asyncStack: null
	,onTested: null
	,onTimeout: null
	,onComplete: null
	,onPrecheck: null
	,precheck: null
	,wasBound: null
	,execute: function() {
		var _gthis = this;
		if(this.fixture.ignoringInfo != null) {
			this.executeFinally();
			return;
		}
		var isSync = true;
		var expectingAsync = true;
		var run = function() {
			if(isSync) {
				expectingAsync = false;
				return;
			}
			_gthis.executeFixtureMethod();
			_gthis.executeFinally();
		};
		try {
			this.executeMethod(this.fixture.setup);
			this.executeAsyncMethod(this.fixture.setupAsync,run);
			if(!expectingAsync) {
				this.executeFixtureMethod();
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.SetupError(_g1,utest_TestHandler.exceptionStack()));
		}
		isSync = false;
		if(!expectingAsync) {
			this.executeFinally();
		}
	}
	,executeFixtureMethod: function() {
		try {
			this.executeMethod(this.fixture.method);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.Error(_g1,utest_TestHandler.exceptionStack()));
		}
	}
	,executeFinally: function() {
		this.onPrecheck.dispatch(this);
		this.checkTested();
	}
	,checkTested: function() {
		if(this.expiration == null || this.asyncStack.length == 0) {
			this.tested();
		} else {
			var hrtime = process.hrtime();
			if(hrtime[0] + hrtime[1] / 1e9 > this.expiration) {
				this.timeout();
			} else {
				haxe_Timer.delay($bind(this,this.checkTested),10);
			}
		}
	}
	,expiration: null
	,setTimeout: function(timeout) {
		var hrtime = process.hrtime();
		var newExpire = hrtime[0] + hrtime[1] / 1e9 + timeout / 1000;
		this.expiration = this.expiration == null ? newExpire : newExpire > this.expiration ? newExpire : this.expiration;
	}
	,bindHandler: function() {
		if(this.wasBound) {
			return;
		}
		utest_Assert.results = this.results;
		utest_Assert.createAsync = $bind(this,this.addAsync);
		utest_Assert.createEvent = $bind(this,this.addEvent);
		this.wasBound = true;
	}
	,unbindHandler: function() {
		if(!this.wasBound) {
			return;
		}
		utest_Assert.results = null;
		utest_Assert.createAsync = function(f,t) {
			return function() {
			};
		};
		utest_Assert.createEvent = function(f,t) {
			return function(e) {
			};
		};
		this.wasBound = false;
	}
	,addAsync: function(f,timeout) {
		if(timeout == null) {
			timeout = 250;
		}
		if(null == f) {
			f = function() {
			};
		}
		this.asyncStack.add(f);
		var handler = this;
		this.setTimeout(timeout);
		return function() {
			if(!handler.asyncStack.remove(f)) {
				handler.results.add(utest_Assertation.AsyncError("async function already executed",[]));
				return;
			}
			try {
				handler.bindHandler();
				f();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				var _g1 = haxe_Exception.caught(_g).unwrap();
				handler.results.add(utest_Assertation.AsyncError(_g1,utest_TestHandler.exceptionStack(0)));
			}
		};
	}
	,addEvent: function(f,timeout) {
		if(timeout == null) {
			timeout = 250;
		}
		this.asyncStack.add(f);
		var handler = this;
		this.setTimeout(timeout);
		return function(e) {
			if(!handler.asyncStack.remove(f)) {
				handler.results.add(utest_Assertation.AsyncError("event already executed",[]));
				return;
			}
			try {
				handler.bindHandler();
				f(e);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				var _g1 = haxe_Exception.caught(_g).unwrap();
				handler.results.add(utest_Assertation.AsyncError(_g1,utest_TestHandler.exceptionStack(0)));
			}
		};
	}
	,executeMethod: function(name) {
		if(name == null) {
			return;
		}
		this.bindHandler();
		Reflect.field(this.fixture.target,name).apply(this.fixture.target,[]);
	}
	,executeAsyncMethod: function(name,done) {
		if(name == null) {
			done();
			return;
		}
		this.bindHandler();
		Reflect.field(this.fixture.target,name).apply(this.fixture.target,[done]);
	}
	,tested: function() {
		if(this.results.length == 0) {
			this.results.add(utest_Assertation.Warning("no assertions"));
		}
		this.onTested.dispatch(this);
		this.completed();
	}
	,timeout: function() {
		this.results.add(utest_Assertation.TimeoutError(this.asyncStack.length,[]));
		this.onTimeout.dispatch(this);
		this.completed();
	}
	,completed: function() {
		var _gthis = this;
		if(this.fixture.ignoringInfo != null) {
			this.completedFinally();
			return;
		}
		var isSync = true;
		var expectingAsync = true;
		var complete = function() {
			if(isSync) {
				expectingAsync = false;
				return;
			}
			_gthis.completedFinally();
		};
		try {
			this.executeMethod(this.fixture.teardown);
			this.executeAsyncMethod(this.fixture.teardownAsync,complete);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.TeardownError(_g1,utest_TestHandler.exceptionStack(2)));
		}
		isSync = false;
		if(!expectingAsync) {
			this.completedFinally();
		}
	}
	,completedFinally: function() {
		this.finished = true;
		this.unbindHandler();
		this.onComplete.dispatch(this);
	}
	,__class__: utest_TestHandler
};
var utest_ITestHandler = function(fixture) {
	utest_TestHandler.call(this,fixture);
	if(!fixture.isITest) {
		throw haxe_Exception.thrown("Invalid fixture type for utest.ITestHandler");
	}
	this.testCase = js_Boot.__cast(fixture.target , utest_ITest);
	this.test = fixture.test;
	if(this.test == null) {
		throw haxe_Exception.thrown("Fixture is missing test data");
	}
};
utest_ITestHandler.__name__ = "utest.ITestHandler";
utest_ITestHandler.__super__ = utest_TestHandler;
utest_ITestHandler.prototype = $extend(utest_TestHandler.prototype,{
	testCase: null
	,test: null
	,setupAsync: null
	,testAsync: null
	,teardownAsync: null
	,execute: function() {
		if(this.fixture.ignoringInfo != null) {
			this.executeFinally();
			return;
		}
		this.bindHandler();
		this.runSetup();
	}
	,runSetup: function() {
		try {
			this.setupAsync = this.fixture.setupMethod();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.SetupError(_g1,haxe_CallStack.exceptionStack()));
			this.completedFinally();
			return;
		}
		this.setupAsync.then($bind(this,this.checkSetup));
	}
	,checkSetup: function() {
		if(this.setupAsync.timedOut) {
			this.results.add(utest_Assertation.SetupError("Setup timeout",[]));
			this.completedFinally();
		} else {
			this.runTest();
		}
	}
	,runTest: function() {
		try {
			this.testAsync = this.test.execute();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.Error(_g1,haxe_CallStack.exceptionStack()));
			this.runTeardown();
			return;
		}
		this.testAsync.then($bind(this,this.checkTest));
	}
	,checkTest: function() {
		this.onPrecheck.dispatch(this);
		if(this.testAsync.timedOut) {
			this.results.add(utest_Assertation.TimeoutError(1,[]));
			this.onTimeout.dispatch(this);
		} else if(this.testAsync.resolved) {
			if(this.results.length == 0) {
				this.results.add(utest_Assertation.Warning("no assertions"));
			}
			this.onTested.dispatch(this);
		} else {
			throw haxe_Exception.thrown("Unexpected test state");
		}
		this.runTeardown();
	}
	,runTeardown: function() {
		try {
			this.teardownAsync = this.fixture.teardownMethod();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			this.results.add(utest_Assertation.TeardownError(_g1,haxe_CallStack.exceptionStack()));
			this.completedFinally();
			return;
		}
		this.teardownAsync.then($bind(this,this.checkTeardown));
	}
	,checkTeardown: function() {
		if(this.teardownAsync.timedOut) {
			this.results.add(utest_Assertation.TeardownError("Teardown timeout",[]));
		}
		this.completedFinally();
	}
	,bindHandler: function() {
		if(this.wasBound) {
			return;
		}
		utest_Assert.results = this.results;
		var msg = " is not allowed in tests extending utest.ITest. Add `async:utest.Async` argument to the test method instead.";
		utest_Assert.createAsync = function(f,t) {
			throw haxe_Exception.thrown("Assert.createAsync() " + msg);
		};
		utest_Assert.createEvent = function(f,t) {
			throw haxe_Exception.thrown("Assert.createEvent() " + msg);
		};
		this.wasBound = true;
	}
	,__class__: utest_ITestHandler
});
var utest_IgnoredFixture = {};
utest_IgnoredFixture.__properties__ = {get_ignoreReason:"get_ignoreReason",get_isIgnored:"get_isIgnored"};
utest_IgnoredFixture.NotIgnored = function() {
	return null;
};
utest_IgnoredFixture.Ignored = function(reason) {
	return reason != null ? reason : "";
};
utest_IgnoredFixture._new = function(reason) {
	return reason;
};
utest_IgnoredFixture.get_isIgnored = function(this1) {
	return this1 != null;
};
utest_IgnoredFixture.get_ignoreReason = function(this1) {
	return this1;
};
var utest_Runner = function() {
	this.executedFixtures = 0;
	this.pos = 0;
	this.complete = false;
	this.globalPattern = null;
	this.iTestFixtures = new haxe_ds_StringMap();
	this.fixtures = [];
	this.onProgress = new utest_Dispatcher();
	this.onStart = new utest_Dispatcher();
	this.onComplete = new utest_Dispatcher();
	this.onPrecheck = new utest_Dispatcher();
	this.onTestStart = new utest_Dispatcher();
	this.onTestComplete = new utest_Dispatcher();
	this.length = 0;
};
utest_Runner.__name__ = "utest.Runner";
utest_Runner.prototype = {
	fixtures: null
	,iTestFixtures: null
	,onProgress: null
	,onStart: null
	,onComplete: null
	,onPrecheck: null
	,onTestStart: null
	,onTestComplete: null
	,length: null
	,globalPattern: null
	,complete: null
	,addCase: function(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync) {
		if(teardownAsync == null) {
			teardownAsync = "teardownAsync";
		}
		if(setupAsync == null) {
			setupAsync = "setupAsync";
		}
		if(prefix == null) {
			prefix = "test";
		}
		if(teardown == null) {
			teardown = "teardown";
		}
		if(setup == null) {
			setup = "setup";
		}
		if(js_Boot.__implements(test,utest_ITest)) {
			this.addITest(test,pattern);
		} else {
			this.addCaseOld(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync);
		}
	}
	,addITest: function(testCase,pattern) {
		var c = js_Boot.getClass(testCase);
		var className = c.__name__;
		if(Object.prototype.hasOwnProperty.call(this.iTestFixtures.h,className)) {
			throw haxe_Exception.thrown("Cannot add the same test twice.");
		}
		var fixtures = [];
		var init = testCase.__initializeUtest__();
		var _g = 0;
		var _g1 = init.tests;
		while(_g < _g1.length) {
			var test = _g1[_g];
			++_g;
			if(!this.isTestFixtureName(className,test.name,["test","spec"],pattern,this.globalPattern)) {
				continue;
			}
			var fixture = utest_TestFixture.ofData(testCase,test,init.accessories);
			this.addFixture(fixture);
			fixtures.push(fixture);
		}
		if(fixtures.length > 0) {
			this.iTestFixtures.h[className] = { caseInstance : testCase, setupClass : utest_utils_AccessoriesUtils.getSetupClass(init.accessories), dependencies : init.dependencies, fixtures : fixtures, teardownClass : utest_utils_AccessoriesUtils.getTeardownClass(init.accessories)};
		}
	}
	,addCaseOld: function(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync) {
		if(teardownAsync == null) {
			teardownAsync = "teardownAsync";
		}
		if(setupAsync == null) {
			setupAsync = "setupAsync";
		}
		if(prefix == null) {
			prefix = "test";
		}
		if(teardown == null) {
			teardown = "teardown";
		}
		if(setup == null) {
			setup = "setup";
		}
		if(!Reflect.isObject(test)) {
			throw haxe_Exception.thrown("can't add a null object as a test case");
		}
		if(!this.isMethod(test,setup)) {
			setup = null;
		}
		if(!this.isMethod(test,setupAsync)) {
			setupAsync = null;
		}
		if(!this.isMethod(test,teardown)) {
			teardown = null;
		}
		if(!this.isMethod(test,teardownAsync)) {
			teardownAsync = null;
		}
		var fields = Type.getInstanceFields(js_Boot.getClass(test));
		var c = js_Boot.getClass(test);
		var className = c.__name__;
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			if(!this.isMethod(test,field)) {
				continue;
			}
			if(!this.isTestFixtureName(className,field,[prefix],pattern,this.globalPattern)) {
				continue;
			}
			this.addFixture(new utest_TestFixture(test,field,setup,teardown,setupAsync,teardownAsync));
		}
	}
	,isTestFixtureName: function(caseName,testName,prefixes,pattern,globalPattern) {
		if(pattern == null && globalPattern == null) {
			var _g = 0;
			while(_g < prefixes.length) if(StringTools.startsWith(testName,prefixes[_g++])) {
				return true;
			}
			return false;
		}
		if(pattern == null) {
			pattern = globalPattern;
		}
		return pattern.match("" + caseName + "." + testName);
	}
	,addFixture: function(fixture) {
		this.fixtures.push(fixture);
		this.length++;
	}
	,getFixture: function(index) {
		return this.fixtures[index];
	}
	,isMethod: function(test,name) {
		try {
			return Reflect.isFunction(Reflect.field(test,name));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
	}
	,run: function() {
		this.onStart.dispatch(this);
		new utest__$Runner_ITestRunner(this).run();
		this.waitForCompletion();
	}
	,waitForCompletion: function() {
		if(!this.complete) {
			haxe_Timer.delay($bind(this,this.waitForCompletion),100);
		}
	}
	,pos: null
	,executedFixtures: null
	,runNext: function(finishedHandler) {
		var currentCase = null;
		var _g = this.pos;
		var _g1 = this.fixtures.length;
		while(_g < _g1) {
			_g++;
			var fixture = this.fixtures[this.pos++];
			if(fixture.isITest) {
				continue;
			}
			if(currentCase != fixture.target) {
				currentCase = fixture.target;
				var c = js_Boot.getClass(currentCase);
				c.__name__;
			}
			var handler = this.runFixture(fixture);
			if(!handler.finished) {
				handler.onComplete.add($bind(this,this.runNext));
				return;
			}
		}
		this.complete = true;
		this.onComplete.dispatch(this);
	}
	,runFixture: function(fixture) {
		var handler = fixture.isITest ? new utest_ITestHandler(fixture) : new utest_TestHandler(fixture);
		handler.onComplete.add($bind(this,this.testComplete));
		handler.onPrecheck.add(($_=this.onPrecheck,$bind($_,$_.dispatch)));
		this.onTestStart.dispatch(handler);
		handler.execute();
		return handler;
	}
	,testComplete: function(h) {
		++this.executedFixtures;
		this.onTestComplete.dispatch(h);
		this.onProgress.dispatch({ result : utest_TestResult.ofHandler(h), done : this.executedFixtures, totals : this.length});
	}
	,__class__: utest_Runner
};
var utest__$Runner_ITestRunner = function(runner) {
	this.failedCases = [];
	this.failedTestsInCurrentCase = [];
	var _gthis = this;
	this.runner = runner;
	runner.onTestComplete.add(function(handler) {
		var _g_head = handler.results.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			if(val._hx_index != 0) {
				_gthis.failedTestsInCurrentCase.push(handler.fixture.method);
				var c = js_Boot.getClass(handler.fixture.target);
				_gthis.failedCases.push(c.__name__);
			}
		}
	});
};
utest__$Runner_ITestRunner.__name__ = "utest._Runner.ITestRunner";
utest__$Runner_ITestRunner.prototype = {
	runner: null
	,cases: null
	,currentCaseName: null
	,currentCase: null
	,currentCaseFixtures: null
	,teardownClass: null
	,setupAsync: null
	,teardownAsync: null
	,failedTestsInCurrentCase: null
	,failedCases: null
	,run: function() {
		this.cases = this.orderClassesByDependencies();
		this.runCases();
	}
	,orderClassesByDependencies: function() {
		var _gthis = this;
		var result = [];
		var error = function(testCase,msg) {
			_gthis.runner.onProgress.dispatch({ totals : _gthis.runner.length, result : utest_TestResult.ofFailedSetupClass(testCase,utest_Assertation.SetupError(msg,[])), done : _gthis.runner.executedFixtures});
		};
		var added_h = Object.create(null);
		var addClass = null;
		addClass = function(cls,stack) {
			if(Object.prototype.hasOwnProperty.call(added_h,cls)) {
				return;
			}
			var data = _gthis.runner.iTestFixtures.h[cls];
			if(stack.indexOf(cls) >= 0) {
				error(data.caseInstance,"Circular dependencies among test classes detected: " + stack.join(" -> "));
				return;
			}
			stack.push(cls);
			var dependencies = data.dependencies;
			var _g = 0;
			while(_g < dependencies.length) {
				var dependency = dependencies[_g];
				++_g;
				if(Object.prototype.hasOwnProperty.call(_gthis.runner.iTestFixtures.h,dependency)) {
					addClass(dependency,stack);
				} else {
					error(data.caseInstance,"This class depends on " + dependency + ", but it cannot be found. Was it added to test runner?");
					return;
				}
			}
			result.push(cls);
			added_h[cls] = true;
		};
		var cls_keys = Object.keys(this.runner.iTestFixtures.h);
		var cls_length = cls_keys.length;
		var cls_current = 0;
		while(cls_current < cls_length) addClass(cls_keys[cls_current++],[]);
		return new haxe_iterators_ArrayIterator(result);
	}
	,failedDependencies: function(data) {
		var _g = 0;
		var _g1 = data.dependencies;
		while(_g < _g1.length) if(this.failedCases.indexOf(_g1[_g++]) >= 0) {
			return true;
		}
		return false;
	}
	,runCases: function() {
		while(this.cases.hasNext()) {
			this.currentCaseName = this.cases.next();
			var data = this.runner.iTestFixtures.h[this.currentCaseName];
			this.currentCase = data.caseInstance;
			this.failedTestsInCurrentCase = [];
			if(this.failedDependencies(data)) {
				this.failedCases.push(this.currentCaseName);
				continue;
			}
			this.currentCaseFixtures = data.fixtures;
			this.teardownClass = data.teardownClass;
			try {
				this.setupAsync = data.setupClass();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				this.setupFailed(utest_Assertation.SetupError("setupClass failed: " + Std.string(haxe_Exception.caught(_g).unwrap()),haxe_CallStack.exceptionStack()));
				return;
			}
			if(this.setupAsync.resolved) {
				if(!this.runFixtures()) {
					return;
				}
			} else {
				this.setupAsync.then($bind(this,this.checkSetup));
				return;
			}
		}
		this.runner.runNext();
	}
	,checkSetup: function() {
		if(this.setupAsync.timedOut) {
			this.setupFailed(utest_Assertation.SetupError("setupClass timeout",[]));
		} else {
			this.runFixtures();
		}
	}
	,setupFailed: function(assertation) {
		this.runner.executedFixtures += this.currentCaseFixtures.length;
		this.runner.onProgress.dispatch({ totals : this.runner.length, result : utest_TestResult.ofFailedSetupClass(this.currentCase,assertation), done : this.runner.executedFixtures});
		this.runCases();
	}
	,runFixtures: function(finishedHandler) {
		while(this.currentCaseFixtures.length > 0) {
			var fixture = this.currentCaseFixtures.shift();
			var _g = 0;
			var _g1 = fixture.test.dependencies;
			while(_g < _g1.length) if(this.failedTestsInCurrentCase.indexOf(_g1[_g++]) >= 0) {
				fixture.ignoringInfo = utest_IgnoredFixture.Ignored("Failed dependencies");
				break;
			}
			var handler = this.runner.runFixture(fixture);
			if(!handler.finished) {
				handler.onComplete.add($bind(this,this.runFixtures));
				return false;
			}
		}
		try {
			this.teardownAsync = this.teardownClass();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			this.teardownFailed(utest_Assertation.TeardownError("teardownClass failed: " + Std.string(haxe_Exception.caught(_g).unwrap()),haxe_CallStack.exceptionStack()));
			return true;
		}
		if(this.teardownAsync.resolved && finishedHandler == null) {
			return true;
		}
		this.teardownAsync.then($bind(this,this.checkTeardown));
		return false;
	}
	,checkTeardown: function() {
		if(this.teardownAsync.timedOut) {
			this.teardownFailed(utest_Assertation.TeardownError("teardownClass timeout",[]));
		}
		this.runCases();
	}
	,teardownFailed: function(assertation) {
		this.runner.onProgress.dispatch({ totals : this.runner.length, result : utest_TestResult.ofFailedTeardownClass(this.currentCase,assertation), done : this.runner.executedFixtures});
	}
	,__class__: utest__$Runner_ITestRunner
};
var utest_AccessoryName = function() { };
utest_AccessoryName.__name__ = "utest.AccessoryName";
var utest_TestFixture = function(target,method,setup,teardown,setupAsync,teardownAsync) {
	this.isITest = false;
	this.target = target;
	this.method = method;
	this.setup = setup;
	this.setupAsync = setupAsync;
	this.teardown = teardown;
	this.teardownAsync = teardownAsync;
	this.ignoringInfo = this.getIgnored();
};
utest_TestFixture.__name__ = "utest.TestFixture";
utest_TestFixture.ofData = function(target,test,accessories) {
	var fixture = new utest_TestFixture(target,test.name);
	fixture.isITest = true;
	fixture.test = test;
	fixture.setupMethod = utest_utils_AccessoriesUtils.getSetup(accessories);
	fixture.teardownMethod = utest_utils_AccessoriesUtils.getTeardown(accessories);
	return fixture;
};
utest_TestFixture.prototype = {
	target: null
	,method: null
	,setup: null
	,setupAsync: null
	,teardown: null
	,teardownAsync: null
	,ignoringInfo: null
	,isITest: null
	,test: null
	,setupMethod: null
	,teardownMethod: null
	,checkMethod: function(name,arg) {
		var field = Reflect.field(this.target,name);
		if(field == null) {
			throw haxe_Exception.thrown(arg + " function " + name + " is not a field of target");
		}
		if(!Reflect.isFunction(field)) {
			throw haxe_Exception.thrown(arg + " function " + name + " is not a function");
		}
	}
	,getIgnored: function() {
		var metasForTestMetas = Reflect.getProperty(haxe_rtti_Meta.getFields(js_Boot.getClass(this.target)),this.method);
		if(metasForTestMetas == null || !Object.prototype.hasOwnProperty.call(metasForTestMetas,"Ignored")) {
			return utest_IgnoredFixture.NotIgnored();
		}
		var ignoredArgs = Reflect.getProperty(metasForTestMetas,"Ignored");
		if(ignoredArgs == null || ignoredArgs.length == 0 || ignoredArgs[0] == null) {
			return utest_IgnoredFixture.Ignored();
		}
		return utest_IgnoredFixture.Ignored(Std.string(ignoredArgs[0]));
	}
	,__class__: utest_TestFixture
};
var utest_TestResult = function() {
};
utest_TestResult.__name__ = "utest.TestResult";
utest_TestResult.ofHandler = function(handler) {
	var r = new utest_TestResult();
	var c = js_Boot.getClass(handler.fixture.target);
	var path = c.__name__.split(".");
	r.cls = path.pop();
	r.pack = path.join(".");
	r.method = handler.fixture.method;
	r.setup = handler.fixture.setup;
	r.setupAsync = handler.fixture.setupAsync;
	r.teardown = handler.fixture.teardown;
	r.teardownAsync = handler.fixture.teardownAsync;
	r.assertations = handler.results;
	return r;
};
utest_TestResult.ofFailedSetupClass = function(testCase,assertation) {
	var r = new utest_TestResult();
	var c = js_Boot.getClass(testCase);
	var path = c.__name__.split(".");
	r.cls = path.pop();
	r.pack = path.join(".");
	r.method = "setup";
	r.assertations = new haxe_ds_List();
	r.assertations.add(assertation);
	return r;
};
utest_TestResult.ofFailedTeardownClass = function(testCase,assertation) {
	var r = new utest_TestResult();
	var c = js_Boot.getClass(testCase);
	var path = c.__name__.split(".");
	r.cls = path.pop();
	r.pack = path.join(".");
	r.method = "setup";
	r.assertations = new haxe_ds_List();
	r.assertations.add(assertation);
	return r;
};
utest_TestResult.prototype = {
	pack: null
	,cls: null
	,method: null
	,setup: null
	,setupAsync: null
	,teardown: null
	,teardownAsync: null
	,assertations: null
	,__class__: utest_TestResult
};
var utest_ui_common_ClassResult = function(className,setupName,teardownName) {
	this.fixtures = new haxe_ds_StringMap();
	this.className = className;
	this.setupName = setupName;
	this.hasSetup = setupName != null;
	this.teardownName = teardownName;
	this.hasTeardown = teardownName != null;
	this.methods = 0;
	this.stats = new utest_ui_common_ResultStats();
};
utest_ui_common_ClassResult.__name__ = "utest.ui.common.ClassResult";
utest_ui_common_ClassResult.prototype = {
	fixtures: null
	,className: null
	,setupName: null
	,teardownName: null
	,hasSetup: null
	,hasTeardown: null
	,methods: null
	,stats: null
	,add: function(result) {
		if(Object.prototype.hasOwnProperty.call(this.fixtures.h,result.methodName)) {
			throw haxe_Exception.thrown("invalid duplicated fixture: " + this.className + "." + result.methodName);
		}
		this.stats.wire(result.stats);
		this.methods++;
		this.fixtures.h[result.methodName] = result;
	}
	,get: function(method) {
		return this.fixtures.h[method];
	}
	,exists: function(method) {
		return Object.prototype.hasOwnProperty.call(this.fixtures.h,method);
	}
	,methodNames: function(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		var names = [];
		var name_keys = Object.keys(this.fixtures.h);
		var name_length = name_keys.length;
		var name_current = 0;
		while(name_current < name_length) names.push(name_keys[name_current++]);
		if(errorsHavePriority) {
			var me = this;
			names.sort(function(a,b) {
				var as = me.get(a).stats;
				var bs = me.get(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
	,__class__: utest_ui_common_ClassResult
};
var utest_ui_common_FixtureResult = function(methodName) {
	this.methodName = methodName;
	this.list = new haxe_ds_List();
	this.hasTestError = false;
	this.hasSetupError = false;
	this.hasTeardownError = false;
	this.hasTimeoutError = false;
	this.hasAsyncError = false;
	this.stats = new utest_ui_common_ResultStats();
};
utest_ui_common_FixtureResult.__name__ = "utest.ui.common.FixtureResult";
utest_ui_common_FixtureResult.prototype = {
	methodName: null
	,hasTestError: null
	,hasSetupError: null
	,hasTeardownError: null
	,hasTimeoutError: null
	,hasAsyncError: null
	,stats: null
	,list: null
	,iterator: function() {
		return new haxe_ds__$List_ListIterator(this.list.h);
	}
	,add: function(assertation) {
		this.list.add(assertation);
		switch(assertation._hx_index) {
		case 0:
			this.stats.addSuccesses(1);
			break;
		case 1:
			this.stats.addFailures(1);
			break;
		case 2:
			this.stats.addErrors(1);
			break;
		case 3:
			this.stats.addErrors(1);
			this.hasSetupError = true;
			break;
		case 4:
			this.stats.addErrors(1);
			this.hasTeardownError = true;
			break;
		case 5:
			this.stats.addErrors(1);
			this.hasTimeoutError = true;
			break;
		case 6:
			this.stats.addErrors(1);
			this.hasAsyncError = true;
			break;
		case 7:
			this.stats.addWarnings(1);
			break;
		case 8:
			this.stats.addIgnores(1);
			break;
		}
	}
	,__class__: utest_ui_common_FixtureResult
};
var utest_ui_common_HeaderDisplayMode = $hxEnums["utest.ui.common.HeaderDisplayMode"] = { __ename__:"utest.ui.common.HeaderDisplayMode",__constructs__:null
	,AlwaysShowHeader: {_hx_name:"AlwaysShowHeader",_hx_index:0,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
	,NeverShowHeader: {_hx_name:"NeverShowHeader",_hx_index:1,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
	,ShowHeaderWithResults: {_hx_name:"ShowHeaderWithResults",_hx_index:2,__enum__:"utest.ui.common.HeaderDisplayMode",toString:$estr}
};
utest_ui_common_HeaderDisplayMode.__constructs__ = [utest_ui_common_HeaderDisplayMode.AlwaysShowHeader,utest_ui_common_HeaderDisplayMode.NeverShowHeader,utest_ui_common_HeaderDisplayMode.ShowHeaderWithResults];
var utest_ui_common_SuccessResultsDisplayMode = $hxEnums["utest.ui.common.SuccessResultsDisplayMode"] = { __ename__:"utest.ui.common.SuccessResultsDisplayMode",__constructs__:null
	,AlwaysShowSuccessResults: {_hx_name:"AlwaysShowSuccessResults",_hx_index:0,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
	,NeverShowSuccessResults: {_hx_name:"NeverShowSuccessResults",_hx_index:1,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
	,ShowSuccessResultsWithNoErrors: {_hx_name:"ShowSuccessResultsWithNoErrors",_hx_index:2,__enum__:"utest.ui.common.SuccessResultsDisplayMode",toString:$estr}
};
utest_ui_common_SuccessResultsDisplayMode.__constructs__ = [utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults,utest_ui_common_SuccessResultsDisplayMode.NeverShowSuccessResults,utest_ui_common_SuccessResultsDisplayMode.ShowSuccessResultsWithNoErrors];
var utest_ui_common_PackageResult = function(packageName) {
	this.isEmpty = true;
	this.packageName = packageName;
	this.classes = new haxe_ds_StringMap();
	this.packages = new haxe_ds_StringMap();
	this.stats = new utest_ui_common_ResultStats();
};
utest_ui_common_PackageResult.__name__ = "utest.ui.common.PackageResult";
utest_ui_common_PackageResult.prototype = {
	packageName: null
	,isEmpty: null
	,classes: null
	,packages: null
	,stats: null
	,addResult: function(result,flattenPackage) {
		this.isEmpty = false;
		this.getOrCreateClass(this.getOrCreatePackage(result.pack,flattenPackage,this),result.cls,result.setup,result.teardown).add(this.createFixture(result.method,result.assertations));
	}
	,addClass: function(result) {
		this.isEmpty = false;
		this.classes.h[result.className] = result;
		this.stats.wire(result.stats);
	}
	,addPackage: function(result) {
		this.isEmpty = false;
		this.packages.h[result.packageName] = result;
		this.stats.wire(result.stats);
	}
	,existsPackage: function(name) {
		return Object.prototype.hasOwnProperty.call(this.packages.h,name);
	}
	,existsClass: function(name) {
		return Object.prototype.hasOwnProperty.call(this.classes.h,name);
	}
	,getPackage: function(name) {
		if(this.packageName == null && name == "") {
			return this;
		}
		return this.packages.h[name];
	}
	,getClass: function(name) {
		return this.classes.h[name];
	}
	,classNames: function(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		var names = [];
		var name_keys = Object.keys(this.classes.h);
		var name_length = name_keys.length;
		var name_current = 0;
		while(name_current < name_length) names.push(name_keys[name_current++]);
		if(errorsHavePriority) {
			var me = this;
			names.sort(function(a,b) {
				var as = me.getClass(a).stats;
				var bs = me.getClass(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
	,packageNames: function(errorsHavePriority) {
		if(errorsHavePriority == null) {
			errorsHavePriority = true;
		}
		var names = [];
		if(this.packageName == null) {
			names.push("");
		}
		var name_keys = Object.keys(this.packages.h);
		var name_length = name_keys.length;
		var name_current = 0;
		while(name_current < name_length) names.push(name_keys[name_current++]);
		if(errorsHavePriority) {
			var me = this;
			names.sort(function(a,b) {
				var as = me.getPackage(a).stats;
				var bs = me.getPackage(b).stats;
				if(as.hasErrors) {
					if(!bs.hasErrors) {
						return -1;
					} else if(as.errors == bs.errors) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.errors,bs.errors);
					}
				} else if(bs.hasErrors) {
					return 1;
				} else if(as.hasFailures) {
					if(!bs.hasFailures) {
						return -1;
					} else if(as.failures == bs.failures) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.failures,bs.failures);
					}
				} else if(bs.hasFailures) {
					return 1;
				} else if(as.hasWarnings) {
					if(!bs.hasWarnings) {
						return -1;
					} else if(as.warnings == bs.warnings) {
						return Reflect.compare(a,b);
					} else {
						return Reflect.compare(as.warnings,bs.warnings);
					}
				} else if(bs.hasWarnings) {
					return 1;
				} else {
					return Reflect.compare(a,b);
				}
			});
		} else {
			names.sort(function(a,b) {
				return Reflect.compare(a,b);
			});
		}
		return names;
	}
	,createFixture: function(method,assertations) {
		var f = new utest_ui_common_FixtureResult(method);
		var assertation = $getIterator(assertations);
		while(assertation.hasNext()) f.add(assertation.next());
		return f;
	}
	,getOrCreateClass: function(pack,cls,setup,teardown) {
		if(pack.existsClass(cls)) {
			return pack.getClass(cls);
		}
		var c = new utest_ui_common_ClassResult(cls,setup,teardown);
		pack.addClass(c);
		return c;
	}
	,getOrCreatePackage: function(pack,flat,ref) {
		if(pack == null || pack == "") {
			return ref;
		}
		if(flat) {
			if(ref.existsPackage(pack)) {
				return ref.getPackage(pack);
			}
			var p = new utest_ui_common_PackageResult(pack);
			ref.addPackage(p);
			return p;
		} else {
			var parts = pack.split(".");
			var _g = 0;
			while(_g < parts.length) ref = this.getOrCreatePackage(parts[_g++],true,ref);
			return ref;
		}
	}
	,__class__: utest_ui_common_PackageResult
};
var utest_ui_common_ReportTools = function() { };
utest_ui_common_ReportTools.__name__ = "utest.ui.common.ReportTools";
utest_ui_common_ReportTools.hasHeader = function(report,stats) {
	switch(report.displayHeader._hx_index) {
	case 0:
		return true;
	case 1:
		return false;
	case 2:
		if(!stats.isOk) {
			return true;
		}
		switch(report.displaySuccessResults._hx_index) {
		case 0:case 2:
			return true;
		case 1:
			return false;
		}
		break;
	}
};
utest_ui_common_ReportTools.skipResult = function(report,stats,isOk) {
	if(!stats.isOk) {
		return false;
	}
	switch(report.displaySuccessResults._hx_index) {
	case 0:
		return false;
	case 1:
		return true;
	case 2:
		return !isOk;
	}
};
utest_ui_common_ReportTools.hasOutput = function(report,stats) {
	if(!stats.isOk) {
		return true;
	}
	return utest_ui_common_ReportTools.hasHeader(report,stats);
};
var utest_ui_common_ResultAggregator = function(runner,flattenPackage) {
	if(flattenPackage == null) {
		flattenPackage = false;
	}
	if(runner == null) {
		throw haxe_Exception.thrown("runner argument is null");
	}
	this.flattenPackage = flattenPackage;
	this.runner = runner;
	runner.onStart.add($bind(this,this.start));
	runner.onProgress.add($bind(this,this.progress));
	runner.onComplete.add($bind(this,this.complete));
	this.onStart = new utest_Notifier();
	this.onComplete = new utest_Dispatcher();
	this.onProgress = new utest_Dispatcher();
};
utest_ui_common_ResultAggregator.__name__ = "utest.ui.common.ResultAggregator";
utest_ui_common_ResultAggregator.prototype = {
	runner: null
	,flattenPackage: null
	,root: null
	,onStart: null
	,onComplete: null
	,onProgress: null
	,start: function(runner) {
		this.checkNonITest();
		this.root = new utest_ui_common_PackageResult(null);
		this.onStart.dispatch();
	}
	,checkNonITest: function() {
		var first = null;
		var total = 0;
		var _g = 0;
		var _g1 = this.runner.length;
		while(_g < _g1) {
			var fixture = this.runner.getFixture(_g++);
			if(!fixture.isITest) {
				++total;
				if(first == null) {
					var c = js_Boot.getClass(fixture.target);
					first = c.__name__;
				}
			}
		}
		if(total > 0) {
			var baseMsg = "implement utest.ITest. Non-ITest tests are deprecated. Implement utest.ITest or extend utest.Test.";
			var msg;
			switch(total) {
			case 1:
				msg = "" + first + " doesn't " + baseMsg;
				break;
			case 2:
				msg = "" + first + " and 1 other don't " + baseMsg;
				break;
			default:
				msg = "" + first + " and " + total + " others don't " + baseMsg;
			}
			haxe_Log.trace(msg,{ fileName : "utest/ui/common/ResultAggregator.hx", lineNumber : 54, className : "utest.ui.common.ResultAggregator", methodName : "checkNonITest"});
		}
	}
	,getOrCreatePackage: function(pack,flat,ref) {
		if(ref == null) {
			ref = this.root;
		}
		if(pack == null || pack == "") {
			return ref;
		}
		if(flat) {
			if(ref.existsPackage(pack)) {
				return ref.getPackage(pack);
			}
			var p = new utest_ui_common_PackageResult(pack);
			ref.addPackage(p);
			return p;
		} else {
			var parts = pack.split(".");
			var _g = 0;
			while(_g < parts.length) ref = this.getOrCreatePackage(parts[_g++],true,ref);
			return ref;
		}
	}
	,getOrCreateClass: function(pack,cls,setup,teardown) {
		if(pack.existsClass(cls)) {
			return pack.getClass(cls);
		}
		var c = new utest_ui_common_ClassResult(cls,setup,teardown);
		pack.addClass(c);
		return c;
	}
	,createFixture: function(result) {
		var f = new utest_ui_common_FixtureResult(result.method);
		var _g_head = result.assertations.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			f.add(val);
		}
		return f;
	}
	,progress: function(e) {
		this.root.addResult(e.result,this.flattenPackage);
		this.onProgress.dispatch(e);
	}
	,complete: function(runner) {
		if(this.root.isEmpty) {
			this.root.addResult(this.createNoTestsResult(),false);
		}
		this.onComplete.dispatch(this.root);
	}
	,createNoTestsResult: function() {
		var result = new utest_TestResult();
		result.pack = "";
		result.cls = "";
		result.method = "";
		result.assertations = new haxe_ds_List();
		result.assertations.add(utest_Assertation.Failure("No tests executed.",{ fileName : "", lineNumber : 1, className : "utest.Runner", methodName : "run"}));
		return result;
	}
	,__class__: utest_ui_common_ResultAggregator
};
var utest_ui_common_ResultStats = function() {
	this.assertations = 0;
	this.successes = 0;
	this.failures = 0;
	this.errors = 0;
	this.warnings = 0;
	this.ignores = 0;
	this.isOk = true;
	this.hasFailures = false;
	this.hasErrors = false;
	this.hasWarnings = false;
	this.hasIgnores = false;
	this.onAddSuccesses = new utest_Dispatcher();
	this.onAddFailures = new utest_Dispatcher();
	this.onAddErrors = new utest_Dispatcher();
	this.onAddWarnings = new utest_Dispatcher();
	this.onAddIgnores = new utest_Dispatcher();
};
utest_ui_common_ResultStats.__name__ = "utest.ui.common.ResultStats";
utest_ui_common_ResultStats.prototype = {
	assertations: null
	,successes: null
	,failures: null
	,errors: null
	,warnings: null
	,ignores: null
	,onAddSuccesses: null
	,onAddFailures: null
	,onAddErrors: null
	,onAddWarnings: null
	,onAddIgnores: null
	,isOk: null
	,hasFailures: null
	,hasErrors: null
	,hasWarnings: null
	,hasIgnores: null
	,addSuccesses: function(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.successes += v;
		this.onAddSuccesses.dispatch(v);
	}
	,addFailures: function(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.failures += v;
		this.hasFailures = this.failures > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddFailures.dispatch(v);
	}
	,addErrors: function(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.errors += v;
		this.hasErrors = this.errors > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddErrors.dispatch(v);
	}
	,addIgnores: function(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.ignores += v;
		this.hasIgnores = this.ignores > 0;
		this.onAddIgnores.dispatch(v);
	}
	,addWarnings: function(v) {
		if(v == 0) {
			return;
		}
		this.assertations += v;
		this.warnings += v;
		this.hasWarnings = this.warnings > 0;
		this.isOk = !(this.hasFailures || this.hasErrors || this.hasWarnings);
		this.onAddWarnings.dispatch(v);
	}
	,sum: function(other) {
		this.addSuccesses(other.successes);
		this.addFailures(other.failures);
		this.addErrors(other.errors);
		this.addWarnings(other.warnings);
		this.addIgnores(other.ignores);
	}
	,subtract: function(other) {
		this.addSuccesses(-other.successes);
		this.addFailures(-other.failures);
		this.addErrors(-other.errors);
		this.addWarnings(-other.warnings);
		this.addIgnores(-other.ignores);
	}
	,wire: function(dependant) {
		dependant.onAddSuccesses.add($bind(this,this.addSuccesses));
		dependant.onAddFailures.add($bind(this,this.addFailures));
		dependant.onAddErrors.add($bind(this,this.addErrors));
		dependant.onAddWarnings.add($bind(this,this.addWarnings));
		dependant.onAddIgnores.add($bind(this,this.addIgnores));
		this.sum(dependant);
	}
	,unwire: function(dependant) {
		dependant.onAddSuccesses.remove($bind(this,this.addSuccesses));
		dependant.onAddFailures.remove($bind(this,this.addFailures));
		dependant.onAddErrors.remove($bind(this,this.addErrors));
		dependant.onAddWarnings.remove($bind(this,this.addWarnings));
		dependant.onAddIgnores.remove($bind(this,this.addIgnores));
		this.subtract(dependant);
	}
	,__class__: utest_ui_common_ResultStats
};
var utest_utils_AccessoriesUtils = function() { };
utest_utils_AccessoriesUtils.__name__ = "utest.utils.AccessoriesUtils";
utest_utils_AccessoriesUtils.getSetupClass = function(accessories) {
	if(accessories.setupClass == null) {
		return utest_Async.getResolved;
	} else {
		return accessories.setupClass;
	}
};
utest_utils_AccessoriesUtils.getSetup = function(accessories) {
	if(accessories.setup == null) {
		return utest_Async.getResolved;
	} else {
		return accessories.setup;
	}
};
utest_utils_AccessoriesUtils.getTeardown = function(accessories) {
	if(accessories.teardown == null) {
		return utest_Async.getResolved;
	} else {
		return accessories.teardown;
	}
};
utest_utils_AccessoriesUtils.getTeardownClass = function(accessories) {
	if(accessories.teardownClass == null) {
		return utest_Async.getResolved;
	} else {
		return accessories.teardownClass;
	}
};
var utest_utils_AsyncUtils = function() { };
utest_utils_AsyncUtils.__name__ = "utest.utils.AsyncUtils";
utest_utils_AsyncUtils.orResolved = function(_async) {
	if(_async == null) {
		return utest_Async.getResolved();
	} else {
		return _async;
	}
};
var utest_utils_Misc = function() { };
utest_utils_Misc.__name__ = "utest.utils.Misc";
utest_utils_Misc.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
var utest_utils_Print = function() { };
utest_utils_Print.__name__ = "utest.utils.Print";
utest_utils_Print.immediately = function(msg) {
	console.log(msg);
};
utest_utils_Print.startCase = function(caseName) {
};
utest_utils_Print.startTest = function(name) {
};
var uuid_Uuid = function() { };
uuid_Uuid.__name__ = "uuid.Uuid";
uuid_Uuid.splitmix64_seed = function(index) {
	var a_low = index;
	var high = (index >> 31) + -1640531527 | 0;
	var low = a_low + (2135587861) | 0;
	if(haxe_Int32.ucompare(low,a_low) < 0) {
		++high;
		high = high | 0;
	}
	var result = new haxe__$Int64__$_$_$Int64(high,low);
	var b = new haxe__$Int64__$_$_$Int64(result.high >> 30,result.high << 2 | result.low >>> 30);
	var high = result.high ^ b.high;
	var low = result.low ^ b.low;
	var b_low = 484763065;
	var al = low & 65535;
	var ah = low >>> 16;
	var bl = b_low & 65535;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var low1 = p00;
	var high1 = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low1 = p00 + p01 | 0;
	if(haxe_Int32.ucompare(low1,p01) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	p10 <<= 16;
	low1 = low1 + p10 | 0;
	if(haxe_Int32.ucompare(low1,p10) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	high1 = high1 + (haxe_Int32._mul(low,-1084733587) + haxe_Int32._mul(high,b_low) | 0) | 0;
	result = new haxe__$Int64__$_$_$Int64(high1,low1);
	var b = new haxe__$Int64__$_$_$Int64(result.high >> 27,result.high << 5 | result.low >>> 27);
	var high = result.high ^ b.high;
	var low = result.low ^ b.low;
	var b_low = 321982955;
	var al = low & 65535;
	var ah = low >>> 16;
	var bl = b_low & 65535;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var low1 = p00;
	var high1 = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low1 = p00 + p01 | 0;
	if(haxe_Int32.ucompare(low1,p01) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	p10 <<= 16;
	low1 = low1 + p10 | 0;
	if(haxe_Int32.ucompare(low1,p10) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	high1 = high1 + (haxe_Int32._mul(low,-1798288965) + haxe_Int32._mul(high,b_low) | 0) | 0;
	result = new haxe__$Int64__$_$_$Int64(high1,low1);
	var b = new haxe__$Int64__$_$_$Int64(result.high >> 31,result.high << 1 | result.low >>> 31);
	return new haxe__$Int64__$_$_$Int64(result.high ^ b.high,result.low ^ b.low);
};
uuid_Uuid.randomFromRange = function(min,max) {
	var s1 = uuid_Uuid.state0;
	var s0 = uuid_Uuid.state1;
	uuid_Uuid.state0 = s0;
	var b = new haxe__$Int64__$_$_$Int64(s1.high << 23 | s1.low >>> 9,s1.low << 23);
	s1 = new haxe__$Int64__$_$_$Int64(s1.high ^ b.high,s1.low ^ b.low);
	var b = new haxe__$Int64__$_$_$Int64(s1.high >>> 18,s1.high << 14 | s1.low >>> 18);
	var b1 = new haxe__$Int64__$_$_$Int64(s0.high >>> 5,s0.high << 27 | s0.low >>> 5);
	uuid_Uuid.state1 = new haxe__$Int64__$_$_$Int64(s1.high ^ s0.high ^ b.high ^ b1.high,s1.low ^ s0.low ^ b.low ^ b1.low);
	var a = uuid_Uuid.state1;
	var high = a.high + s0.high | 0;
	var low = a.low + s0.low | 0;
	if(haxe_Int32.ucompare(low,a.low) < 0) {
		++high;
		high = high | 0;
	}
	var x = max - min + 1;
	var result = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
	if(result < 0) {
		result = -result;
	}
	return result + min;
};
uuid_Uuid.randomByte = function() {
	return uuid_Uuid.randomFromRange(0,255);
};
uuid_Uuid.fromShort = function(shortUuid,separator,fromAlphabet) {
	if(fromAlphabet == null) {
		fromAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(separator == null) {
		separator = "-";
	}
	return uuid_Uuid.hexToUuid(uuid_Uuid.convert(shortUuid,fromAlphabet,"0123456789abcdef"),separator);
};
uuid_Uuid.toShort = function(uuid,separator,toAlphabet) {
	if(toAlphabet == null) {
		toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(separator == null) {
		separator = "-";
	}
	uuid = StringTools.replace(uuid,separator,"").toLowerCase();
	return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet);
};
uuid_Uuid.v1 = function(node,optClockSequence,msecs,optNsecs,randomFunc,separator,shortUuid,toAlphabet) {
	if(toAlphabet == null) {
		toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(shortUuid == null) {
		shortUuid = false;
	}
	if(separator == null) {
		separator = "-";
	}
	if(optNsecs == null) {
		optNsecs = -1;
	}
	if(msecs == null) {
		msecs = -1;
	}
	if(optClockSequence == null) {
		optClockSequence = -1;
	}
	if(randomFunc == null) {
		randomFunc = uuid_Uuid.randomByte;
	}
	var buffer = new haxe_io_Bytes(new ArrayBuffer(16));
	if(node == null) {
		node = new haxe_io_Bytes(new ArrayBuffer(6));
		var v = randomFunc();
		node.b[0] = v;
		var v = randomFunc();
		node.b[1] = v;
		var v = randomFunc();
		node.b[2] = v;
		var v = randomFunc();
		node.b[3] = v;
		var v = randomFunc();
		node.b[4] = v;
		var v = randomFunc();
		node.b[5] = v;
		node.b[0] |= 1;
	}
	if(uuid_Uuid.clockSequenceBuffer == -1) {
		uuid_Uuid.clockSequenceBuffer = (randomFunc() << 8 | randomFunc()) & 16383;
	}
	var clockSeq = optClockSequence;
	if(optClockSequence == -1) {
		clockSeq = uuid_Uuid.clockSequenceBuffer;
	}
	if(msecs == -1) {
		var hrtime = process.hrtime();
		msecs = hrtime[0] + hrtime[1] / 1e9;
	}
	var nsecs = optNsecs;
	if(optNsecs == -1) {
		nsecs = uuid_Uuid.lastNSecs + 1;
	}
	var dt = msecs - uuid_Uuid.lastMSecs + (nsecs - uuid_Uuid.lastNSecs) / 10000;
	if(dt < 0 && optClockSequence == -1) {
		clockSeq = clockSeq + 1 & 16383;
	}
	if((dt < 0 || msecs > uuid_Uuid.lastMSecs) && optNsecs == -1) {
		nsecs = 0;
	}
	if(nsecs >= 10000) {
		throw haxe_Exception.thrown("Can't create more than 10M uuids/sec");
	}
	uuid_Uuid.lastMSecs = msecs;
	uuid_Uuid.lastNSecs = nsecs;
	uuid_Uuid.clockSequenceBuffer = clockSeq;
	msecs += 12219292800000;
	var dvs = new haxe__$Int64__$_$_$Int64(1,0);
	var a = haxe_Int64Helper.fromFloat(msecs);
	var high = a.high & 0;
	var low = a.low & 268435455;
	var b_low = 10000;
	var al = low & 65535;
	var ah = low >>> 16;
	var bl = b_low & 65535;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var low1 = p00;
	var high1 = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low1 = p00 + p01 | 0;
	if(haxe_Int32.ucompare(low1,p01) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	p10 <<= 16;
	low1 = low1 + p10 | 0;
	if(haxe_Int32.ucompare(low1,p10) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	high1 = high1 + (haxe_Int32._mul(low,0) + haxe_Int32._mul(high,b_low) | 0) | 0;
	var a_low = low1;
	var high = high1 + (nsecs >> 31) | 0;
	var low = a_low + nsecs | 0;
	if(haxe_Int32.ucompare(low,a_low) < 0) {
		++high;
		high = high | 0;
	}
	var tl = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),dvs).modulus.low;
	buffer.b[0] = tl >>> 24 & 255;
	buffer.b[1] = tl >>> 16 & 255;
	buffer.b[2] = tl >>> 8 & 255;
	buffer.b[3] = tl & 255;
	var a = haxe_Int64.divMod(haxe_Int64Helper.fromFloat(msecs),dvs).quotient;
	var b_low = 10000;
	var al = a.low & 65535;
	var ah = a.low >>> 16;
	var bl = b_low & 65535;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	haxe_Int32._mul(ah,bh);
	var low = p00;
	p01 <<= 16;
	low = p00 + p01 | 0;
	p10 <<= 16;
	low = low + p10 | 0;
	haxe_Int32._mul(a.low,0);
	haxe_Int32._mul(a.high,b_low);
	var tmh = low & 268435455;
	buffer.b[4] = tmh >>> 8 & 255;
	buffer.b[5] = tmh & 255;
	buffer.b[6] = tmh >>> 24 & 15 | 16;
	buffer.b[7] = tmh >>> 16 & 255;
	buffer.b[8] = clockSeq >>> 8 | 128;
	buffer.b[9] = clockSeq & 255;
	buffer.b[10] = node.b[0];
	buffer.b[11] = node.b[1];
	buffer.b[12] = node.b[2];
	buffer.b[13] = node.b[3];
	buffer.b[14] = node.b[4];
	buffer.b[15] = node.b[5];
	var uuid = uuid_Uuid.stringify(buffer,separator);
	if(shortUuid) {
		uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
	}
	return uuid;
};
uuid_Uuid.v3 = function(name,namespace,separator,shortUuid,toAlphabet) {
	if(toAlphabet == null) {
		toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(shortUuid == null) {
		shortUuid = false;
	}
	if(separator == null) {
		separator = "-";
	}
	if(namespace == null) {
		namespace = "";
	}
	namespace = StringTools.replace(namespace,"-","");
	var buffer = haxe_crypto_Md5.make(haxe_io_Bytes.ofHex(namespace + haxe_io_Bytes.ofString(name).toHex()));
	buffer.b[6] = buffer.b[6] & 15 | 48;
	buffer.b[8] = buffer.b[8] & 63 | 128;
	var uuid = uuid_Uuid.stringify(buffer,separator);
	if(shortUuid) {
		uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
	}
	return uuid;
};
uuid_Uuid.v4 = function(randBytes,randomFunc,separator,shortUuid,toAlphabet) {
	if(toAlphabet == null) {
		toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(shortUuid == null) {
		shortUuid = false;
	}
	if(separator == null) {
		separator = "-";
	}
	if(randomFunc == null) {
		randomFunc = uuid_Uuid.randomByte;
	}
	var buffer = randBytes;
	if(randBytes == null) {
		buffer = new haxe_io_Bytes(new ArrayBuffer(16));
		var v = randomFunc();
		buffer.b[0] = v;
		var v = randomFunc();
		buffer.b[1] = v;
		var v = randomFunc();
		buffer.b[2] = v;
		var v = randomFunc();
		buffer.b[3] = v;
		var v = randomFunc();
		buffer.b[4] = v;
		var v = randomFunc();
		buffer.b[5] = v;
		var v = randomFunc();
		buffer.b[6] = v;
		var v = randomFunc();
		buffer.b[7] = v;
		var v = randomFunc();
		buffer.b[8] = v;
		var v = randomFunc();
		buffer.b[9] = v;
		var v = randomFunc();
		buffer.b[10] = v;
		var v = randomFunc();
		buffer.b[11] = v;
		var v = randomFunc();
		buffer.b[12] = v;
		var v = randomFunc();
		buffer.b[13] = v;
		var v = randomFunc();
		buffer.b[14] = v;
		var v = randomFunc();
		buffer.b[15] = v;
	} else if(randBytes.length < 16) {
		throw haxe_Exception.thrown("Random bytes should be at least 16 bytes");
	}
	buffer.b[6] = buffer.b[6] & 15 | 64;
	buffer.b[8] = buffer.b[8] & 63 | 128;
	var uuid = uuid_Uuid.stringify(buffer,separator);
	if(shortUuid) {
		uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
	}
	return uuid;
};
uuid_Uuid.v5 = function(name,namespace,separator,shortUuid,toAlphabet) {
	if(toAlphabet == null) {
		toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
	}
	if(shortUuid == null) {
		shortUuid = false;
	}
	if(separator == null) {
		separator = "-";
	}
	if(namespace == null) {
		namespace = "";
	}
	namespace = StringTools.replace(namespace,"-","");
	var buffer = haxe_crypto_Sha1.make(haxe_io_Bytes.ofHex(namespace + haxe_io_Bytes.ofString(name).toHex()));
	buffer.b[6] = buffer.b[6] & 15 | 80;
	buffer.b[8] = buffer.b[8] & 63 | 128;
	var uuid = uuid_Uuid.stringify(buffer,separator);
	if(shortUuid) {
		uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
	}
	return uuid;
};
uuid_Uuid.stringify = function(data,separator) {
	if(separator == null) {
		separator = "-";
	}
	return uuid_Uuid.hexToUuid(data.toHex(),separator);
};
uuid_Uuid.parse = function(uuid,separator) {
	if(separator == null) {
		separator = "-";
	}
	return haxe_io_Bytes.ofHex(StringTools.replace(uuid,separator,""));
};
uuid_Uuid.validate = function(uuid,separator) {
	if(separator == null) {
		separator = "-";
	}
	if(separator == "") {
		uuid = HxOverrides.substr(uuid,0,8) + "-" + HxOverrides.substr(uuid,8,4) + "-" + HxOverrides.substr(uuid,12,4) + "-" + HxOverrides.substr(uuid,16,4) + "-" + HxOverrides.substr(uuid,20,12);
	} else if(separator != "-") {
		uuid = StringTools.replace(uuid,separator,"-");
	}
	return uuid_Uuid.regexp.match(uuid);
};
uuid_Uuid.version = function(uuid,separator) {
	if(separator == null) {
		separator = "-";
	}
	uuid = StringTools.replace(uuid,separator,"");
	return Std.parseInt("0x" + HxOverrides.substr(uuid,12,1));
};
uuid_Uuid.hexToUuid = function(hex,separator) {
	return HxOverrides.substr(hex,0,8) + separator + HxOverrides.substr(hex,8,4) + separator + HxOverrides.substr(hex,12,4) + separator + HxOverrides.substr(hex,16,4) + separator + HxOverrides.substr(hex,20,12);
};
uuid_Uuid.convert = function(number,fromAlphabet,toAlphabet) {
	var fromBase = fromAlphabet.length;
	var toBase = toAlphabet.length;
	var len = number.length;
	var buf = "";
	var numberMap = new Array(len);
	var divide = 0;
	var newlen = 0;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		numberMap[i] = fromAlphabet.indexOf(number.charAt(i));
	}
	while(true) {
		divide = 0;
		newlen = 0;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			divide = divide * fromBase + numberMap[_g++];
			if(divide >= toBase) {
				numberMap[newlen++] = Math.floor(divide / toBase);
				divide %= toBase;
			} else if(newlen > 0) {
				numberMap[newlen++] = 0;
			}
		}
		len = newlen;
		buf = toAlphabet.charAt(divide) + buf;
		if(!(newlen != 0)) {
			break;
		}
	}
	return buf;
};
uuid_Uuid.nanoId = function(len,alphabet,randomFunc) {
	if(alphabet == null) {
		alphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	}
	if(len == null) {
		len = 21;
	}
	if(randomFunc == null) {
		randomFunc = uuid_Uuid.randomByte;
	}
	if(alphabet == null) {
		throw haxe_Exception.thrown("Alphabet cannot be null");
	}
	if(alphabet.length == 0 || alphabet.length >= 256) {
		throw haxe_Exception.thrown("Alphabet must contain between 1 and 255 symbols");
	}
	if(len <= 0) {
		throw haxe_Exception.thrown("Length must be greater than zero");
	}
	var mask = (2 << Math.floor(Math.log(alphabet.length - 1) / Math.log(2))) - 1;
	var step = Math.ceil(1.6 * mask * len / alphabet.length);
	var sb_b = "";
	while(sb_b.length != len) {
		var _g = 0;
		while(_g < step) {
			++_g;
			var aIndex = randomFunc() & mask;
			if(aIndex < alphabet.length) {
				sb_b += Std.string(alphabet.charAt(aIndex));
				if(sb_b.length == len) {
					break;
				}
			}
		}
	}
	return sb_b;
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = "String";
Array.__name__ = "Array";
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
hiss_HStream.dummyCount = 0;
hiss_HStream.WHITESPACE = [" ","\n","\t"];
hiss_HissTestCase.functionsTested = new haxe_ds_StringMap();
hiss_HissTestCase.printTestCommands = true;
hiss_HissTestCase.reallyTrace = null;
hiss_HissTestCase.tempTrace = null;
hiss_SpecialForms._ccNum = 0;
hiss_StaticFiles.files = new haxe_ds_StringMap();
hiss_StaticFiles.groups = new haxe_ds_StringMap();
hiss_Stdlib.recursivePrintDepth = 100;
hiss_Stdlib.maxObjectRepLength = 50;
hiss_VariadicFunctions.lesser_cc = (function($this) {
	var $r;
	var type = hiss_Comparison.Lesser;
	$r = function(interp,args,env,cc) {
		hiss_VariadicFunctions._numCompare(type,interp,args,env,cc);
	};
	return $r;
}(this));
hiss_VariadicFunctions.lesserEqual_cc = (function($this) {
	var $r;
	var type = hiss_Comparison.LesserEqual;
	$r = function(interp,args,env,cc) {
		hiss_VariadicFunctions._numCompare(type,interp,args,env,cc);
	};
	return $r;
}(this));
hiss_VariadicFunctions.greater_cc = (function($this) {
	var $r;
	var type = hiss_Comparison.Greater;
	$r = function(interp,args,env,cc) {
		hiss_VariadicFunctions._numCompare(type,interp,args,env,cc);
	};
	return $r;
}(this));
hiss_VariadicFunctions.greaterEqual_cc = (function($this) {
	var $r;
	var type = hiss_Comparison.GreaterEqual;
	$r = function(interp,args,env,cc) {
		hiss_VariadicFunctions._numCompare(type,interp,args,env,cc);
	};
	return $r;
}(this));
hiss_VariadicFunctions.equal_cc = (function($this) {
	var $r;
	var type = hiss_Comparison.Equal;
	$r = function(interp,args,env,cc) {
		hiss_VariadicFunctions._numCompare(type,interp,args,env,cc);
	};
	return $r;
}(this));
hiss_wrappers_HStringTools.startsWith = StringTools.startsWith;
hiss_wrappers_HStringTools.endsWith = StringTools.endsWith;
hiss_wrappers_HStringTools.lpad = StringTools.lpad;
hiss_wrappers_HStringTools.rpad = StringTools.rpad;
hiss_wrappers_HStringTools.trim = StringTools.trim;
hiss_wrappers_HStringTools.ltrim = StringTools.ltrim;
hiss_wrappers_HStringTools.rtrim = StringTools.rtrim;
hiss_wrappers_HStringTools.replace = StringTools.replace;
hx_strings_Char.CHAR_CASE_MAPPER = new hx_strings__$Char_CharCaseMapper();
hx_strings_Char.BACKSPACE = 8;
hx_strings_Char.TAB = 9;
hx_strings_Char.LF = 10;
hx_strings_Char.CR = 13;
hx_strings_Char.ESC = 27;
hx_strings_Char.SPACE = 32;
hx_strings_Char.EXCLAMATION_MARK = 33;
hx_strings_Char.DOUBLE_QUOTE = 34;
hx_strings_Char.HASH = 35;
hx_strings_Char.DOLLAR = 36;
hx_strings_Char.AMPERSAND = 38;
hx_strings_Char.SINGLE_QUOTE = 39;
hx_strings_Char.BRACKET_ROUND_LEFT = 40;
hx_strings_Char.BRACKET_ROUND_RIGHT = 41;
hx_strings_Char.ASTERISK = 42;
hx_strings_Char.PLUS = 43;
hx_strings_Char.COMMA = 44;
hx_strings_Char.MINUS = 45;
hx_strings_Char.DOT = 46;
hx_strings_Char.SLASH = 47;
hx_strings_Char.ZERO = 48;
hx_strings_Char.ONE = 49;
hx_strings_Char.TWO = 50;
hx_strings_Char.TRHEE = 51;
hx_strings_Char.FOUR = 52;
hx_strings_Char.FIVE = 53;
hx_strings_Char.SIX = 54;
hx_strings_Char.SEVEN = 55;
hx_strings_Char.EIGHT = 56;
hx_strings_Char.NINE = 57;
hx_strings_Char.COLON = 58;
hx_strings_Char.SEMICOLON = 59;
hx_strings_Char.LOWER_THAN = 60;
hx_strings_Char.EQUALS = 61;
hx_strings_Char.GREATER_THAN = 62;
hx_strings_Char.QUESTION_MARK = 63;
hx_strings_Char.BRACKET_SQUARE_LEFT = 91;
hx_strings_Char.BACKSLASH = 92;
hx_strings_Char.BRACKET_SQUARE_RIGHT = 93;
hx_strings_Char.CARET = 94;
hx_strings_Char.UNDERSCORE = 95;
hx_strings_Char.BRACKET_CURLY_LEFT = 123;
hx_strings_Char.PIPE = 124;
hx_strings_Char.BRACKET_CURLY_RIGHT = 125;
hx_strings__$CharIterator_NullCharIterator.INSTANCE = new hx_strings__$CharIterator_NullCharIterator();
hx_strings_Pattern.__meta__ = { obj : { immutable : null, threadSafe : null}};
hx_strings_Matcher.__meta__ = { obj : { notThreadSafe : null}};
hx_strings_internal_OS.isNodeJS = (typeof process !== 'undefined') && (typeof process.release !== 'undefined') && (process.release.name === 'node');
hx_strings_internal_OS.isWindows = (function($this) {
	var $r;
	var os = hx_strings_internal_OS.isNodeJS ? process.platform : $global.navigator.platform;
	$r = new EReg("win","i").match(os);
	return $r;
}(this));
hx_strings_Strings.REGEX_ANSI_ESC = hx_strings_Pattern.compile(String.fromCodePoint(27) + "\\[[;\\d]*m",hx_strings_internal__$Either3__$Either3.b("g"));
hx_strings_Strings.REGEX_HTML_UNESCAPE = hx_strings_Pattern.compile("&(#\\d+|amp|nbsp|apos|lt|gt|quot);",hx_strings_internal__$Either3__$Either3.b("g"));
hx_strings_Strings.REGEX_SPLIT_LINES = hx_strings_Pattern.compile("\\r?\\n",hx_strings_internal__$Either3__$Either3.b("g"));
hx_strings_Strings.REGEX_REMOVE_XML_TAGS = hx_strings_Pattern.compile("<[!a-zA-Z\\/][^>]*>",hx_strings_internal__$Either3__$Either3.b("g"));
hx_strings_Strings.POS_NOT_FOUND = -1;
hx_strings_Strings.NEW_LINE_NIX = "\n";
hx_strings_Strings.NEW_LINE_WIN = "\r\n";
hx_strings_Strings.NEW_LINE = hx_strings_internal_OS.isWindows ? "\r\n" : "\n";
utest_TestHandler.POLLING_TIME = 10;
utest_AccessoryName.SETUP_NAME = "setup";
utest_AccessoryName.SETUP_CLASS_NAME = "setupClass";
utest_AccessoryName.TEARDOWN_NAME = "teardown";
utest_AccessoryName.TEARDOWN_CLASS_NAME = "teardownClass";
uuid_Uuid.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.ISO_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.X500_DN = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.NIL = "00000000-0000-0000-0000-000000000000";
uuid_Uuid.LOWERCASE_BASE26 = "abcdefghijklmnopqrstuvwxyz";
uuid_Uuid.UPPERCASE_BASE26 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
uuid_Uuid.NO_LOOK_ALIKES_BASE51 = "2346789ABCDEFGHJKLMNPQRTUVWXYZabcdefghijkmnpqrtwxyz";
uuid_Uuid.FLICKR_BASE58 = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
uuid_Uuid.BASE_70 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+!@#$^";
uuid_Uuid.COOKIE_BASE90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";
uuid_Uuid.NANO_ID_ALPHABET = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
uuid_Uuid.NUMBERS_BIN = "01";
uuid_Uuid.NUMBERS_OCT = "01234567";
uuid_Uuid.NUMBERS_DEC = "0123456789";
uuid_Uuid.NUMBERS_HEX = "0123456789abcdef";
uuid_Uuid.lastMSecs = 0;
uuid_Uuid.lastNSecs = 0;
uuid_Uuid.clockSequenceBuffer = -1;
uuid_Uuid.regexp = new EReg("^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$","i");
uuid_Uuid.rndSeed = (function($this) {
	var $r;
	var hrtime = process.hrtime();
	$r = (hrtime[0] + hrtime[1] / 1e9) * 1000 | 0;
	return $r;
}(this));
uuid_Uuid.state0 = uuid_Uuid.splitmix64_seed(uuid_Uuid.rndSeed);
uuid_Uuid.state1 = uuid_Uuid.splitmix64_seed(uuid_Uuid.rndSeed + 1);
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
